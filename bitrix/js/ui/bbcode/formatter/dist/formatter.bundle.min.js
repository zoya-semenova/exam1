this.BX=this.BX||{};this.BX.UI=this.BX.UI||{};(function(t,e,n,o){"use strict";const r=Symbol("name");const s=Symbol("group");const i=Symbol("validate");const a=Symbol("before");const l=Symbol("convert");const h=Symbol("forChild");const c=Symbol("after");const u=()=>true;const d=({node:t})=>t;const f=({element:t})=>t;class m{constructor(t={}){this[r]="unknown";this[s]=null;this[a]=null;this[l]=null;this[h]=null;this[c]=null;if(n.Type.isArray(t.name)){this[s]=[...t.name]}else{this.setName(t.name)}this.setValidate(t.validate);this.setBefore(t.before);this.setConvert(t.convert);this.setForChild(t.forChild);this.setAfter(t.after)}setName(t){if(!n.Type.isStringFilled(t)){throw new TypeError("Name is not a string")}this[r]=t}getName(){return this[r]}setValidate(t){if(n.Type.isFunction(t)){this[i]=t}else{this[i]=u}}validate(t){const e=this[i](t);if(n.Type.isBoolean(e)){return e}throw new TypeError(`Validate callback for "${this.getName()}" returned not boolean`)}setBefore(t){if(n.Type.isFunction(t)){this[a]=t}else{this[a]=d}}runBefore(t){return this[a](t)}setConvert(t){if(!n.Type.isFunction(t)){throw new TypeError("Convert is not a function")}this[l]=t}runConvert(t){return this[l](t)}setForChild(t){if(n.Type.isFunction(t)){this[h]=t}else{this[h]=f}}runForChild(t){return this[h](t)}setAfter(t){if(n.Type.isFunction(t)){this[c]=t}else{this[c]=f}}runAfter(t){return this[c](t)}}const p=Symbol("formatters");const y=Symbol("onUnknown");class w{constructor(t={}){this[p]=new Map;this[y]=null;this.setNodeFormatters(t.formatters);if(n.Type.isNil(t.onUnknown)){this.setOnUnknown(this.getDefaultUnknownNodeCallback())}else{this.setOnUnknown(t.onUnknown)}}static isElement(t){return n.Type.isObject(t)&&n.Type.isFunction(t.appendChild)}static prepareSourceNode(t){if(t instanceof o.BBCodeNode){return t}if(n.Type.isString(t)){return(new e.BBCodeParser).parse(t)}return null}setNodeFormatters(t){if(n.Type.isArrayFilled(t)){t.forEach((t=>{this.setNodeFormatter(t)}))}}setNodeFormatter(t){if(t instanceof m){this[p].set(t.getName(),t)}else{throw new TypeError("formatter is not a NodeFormatter instance.")}}getDefaultUnknownNodeCallback(){throw new TypeError("Must be implemented in subclass")}setOnUnknown(t){if(n.Type.isFunction(t)){this[y]=t}else{throw new TypeError("OnUnknown callback is not a function.")}}runOnUnknown(t){const e=this[y](t);if(e instanceof m||n.Type.isNull(e)){return e}throw new TypeError("OnUnknown callback returned not NodeFormatter instance or null.")}getNodeFormatter(t){const e=this[p].get(t.getName());if(e instanceof m){return e}return this.runOnUnknown({node:t,formatter:this})}format(t){if(!n.Type.isPlainObject(t)){throw new TypeError("options is not a object")}const{source:e,data:o={}}=t;if(!n.Type.isUndefined(o)&&!n.Type.isPlainObject(o)){throw new TypeError("options.data is not a object")}const r=w.prepareSourceNode(e);if(n.Type.isNull(r)){throw new TypeError("options.source is not a BBCodeNode or string")}const s=this.getNodeFormatter(r);const i=s.validate({node:r,formatter:this,data:o});if(!i){return null}const a=s.runBefore({node:r,formatter:this,data:o});if(n.Type.isNull(a)){return null}const l=s.runConvert({node:a,formatter:this,data:o});if(n.Type.isNull(l)){return null}a.getChildren().forEach((t=>{const e=this.format({source:t,data:o});if(w.isElement(e)){const n=s.runForChild({node:t,element:e,formatter:this,data:o});if(w.isElement(n)){l.appendChild(n)}}}));return s.runAfter({node:a,element:l,formatter:this,data:o})}}t.Formatter=w;t.NodeFormatter=m})(this.BX.UI.BBCode=this.BX.UI.BBCode||{},BX.UI.BBCode,BX,BX.UI.BBCode);
//# sourceMappingURL=formatter.bundle.map.js