{"version":3,"file":"lexical.dev.bundle.js","sources":["../../node_modules/lexical/Lexical.dev.mjs","../../node_modules/lexical/Lexical.prod.mjs","../../node_modules/lexical/Lexical.mjs","../../node_modules/@lexical/selection/LexicalSelection.dev.mjs","../../node_modules/@lexical/selection/LexicalSelection.prod.mjs","../../node_modules/@lexical/selection/LexicalSelection.mjs","../../node_modules/@lexical/utils/LexicalUtils.dev.mjs","../../node_modules/@lexical/utils/LexicalUtils.prod.mjs","../../node_modules/@lexical/utils/LexicalUtils.mjs","../../node_modules/@lexical/html/LexicalHtml.dev.mjs","../../node_modules/@lexical/html/LexicalHtml.prod.mjs","../../node_modules/@lexical/html/LexicalHtml.mjs","../../node_modules/@lexical/list/LexicalList.dev.mjs","../../node_modules/@lexical/list/LexicalList.prod.mjs","../../node_modules/@lexical/list/LexicalList.mjs","../../node_modules/@lexical/link/LexicalLink.dev.mjs","../../node_modules/@lexical/link/LexicalLink.prod.mjs","../../node_modules/@lexical/link/LexicalLink.mjs","../../node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs","../../node_modules/@lexical/clipboard/LexicalClipboard.prod.mjs","../../node_modules/@lexical/clipboard/LexicalClipboard.mjs","../../node_modules/@lexical/history/LexicalHistory.dev.mjs","../../node_modules/@lexical/history/LexicalHistory.prod.mjs","../../node_modules/@lexical/history/LexicalHistory.mjs","../../node_modules/@lexical/text/LexicalText.dev.mjs","../../node_modules/@lexical/text/LexicalText.prod.mjs","../../node_modules/@lexical/text/LexicalText.mjs","../../node_modules/@lexical/rich-text/LexicalRichText.dev.mjs","../../node_modules/@lexical/rich-text/LexicalRichText.prod.mjs","../../node_modules/@lexical/rich-text/LexicalRichText.mjs","../../node_modules/@lexical/table/LexicalTable.dev.mjs","../../node_modules/@lexical/table/LexicalTable.prod.mjs","../../node_modules/@lexical/table/LexicalTable.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcessingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  return (\n    // @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom ||\n    // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            handleTextMutation(\n            // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n              if (correctDOM === null) {\n                continue;\n              }\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (activeElement === null) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' &&\n  // @ts-ignore iternal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n    if (editor != null) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  }\n  return newFormat;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  // @ts-ignore We intentionally add this to the Node.\n  const key = dom[`__lexicalKey_${editor._key}`];\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n    if (editorState.isEmpty()) {\n      return;\n    }\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n    const nodeMap = editorState._nodeMap;\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOM(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(keyCode);\n}\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(keyCode);\n}\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\nfunction isCopy(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 67) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 88) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\nfunction isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(keyCode, ctrlKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(keyCode, ctrlKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(keyCode) {\n  return keyCode === 32;\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\nfunction isSelectAll(keyCode, metaKey, ctrlKey) {\n  return keyCode === 65 && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll() {\n  const root = $getRoot();\n  const selection = root.select(0, root.getChildrenSize());\n  $setSelection($normalizeSelection(selection));\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n  if (defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  // @ts-expect-error\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n  const replaceFunc = registeredNode.replace;\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\n        throw Error(`Children of a root must be ElementNode`);\n      }\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node) && !node.isInline()) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nfunction $getEditor() {\n  return getActiveEditor();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet subTreeTextFormat = null;\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n    const node = activeNextNodeMap.get(children[startIndex]);\n    if (node !== null && subTreeTextFormat === null && $isTextNode(node)) {\n      subTreeTextFormat = node.getFormat();\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n      if (element != null) {\n        dom.removeChild(element);\n      }\n\n      // @ts-expect-error: internal field\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br');\n    // @ts-expect-error: internal field\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\nfunction reconcileParagraphFormat(element) {\n  if ($isParagraphNode(element) && subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat) {\n    element.setTextFormat(subTreeTextFormat);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent =\n  // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent;\n  // @ts-expect-error: internal field\n  const previousDirection = dom.__lexicalDir;\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = normalizeClassNames(previousDirectionTheme);\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = normalizeClassNames(nextDirectionTheme);\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    // @ts-expect-error: internal field\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    // @ts-expect-error: internal field\n    dom.__lexicalDir = direction;\n  }\n}\nfunction reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  subTreeTextFormat = null;\n  reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  reconcileParagraphFormat(nextElement);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n  subTreeTextFormat = null;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFrstChildKey) {\n      reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n    const nextChildNode = activeNextNodeMap.get(nextFrstChildKey);\n    if (subTreeTextFormat === null && $isTextNode(nextChildNode)) {\n      subTreeTextFormat = nextChildNode.getFormat();\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n\n      // @ts-expect-error: internal field\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n          reconcileNode(nextKey, dom);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n    const node = activeNextNodeMap.get(nextKey);\n    if (node !== null && subTreeTextFormat === null && $isTextNode(node)) {\n      subTreeTextFormat = node.getFormat();\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  // @ts-ignore We intentionally add this to the Node.\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = 0;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nconst rootElementsRegistered = new WeakMap();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range  then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        const root = $getRoot();\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Point.getNode() must return TextNode when type is text`);\n            }\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            const lastNode = anchor.getNode();\n            if (lastNode instanceof ParagraphNode && lastNode.getChildrenSize() === 0) {\n              selection.format = lastNode.getTextFormat();\n            } else {\n              selection.format = 0;\n            }\n            selection.style = '';\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if ($isTextNode(node) && textContentSize !== 0 &&\n          // Exclude empty text nodes at boundaries resulting from user's selection\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Tripple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        if (domAnchorNode !== null) {\n          const nodeType = domAnchorNode.nodeType;\n          // If the user is attempting to click selection back onto text, then\n          // we should attempt create a range selection.\n          // When we click on an empty paragraph node or the end of a paragraph that ends\n          // with an image/poll, the nodeType will be ELEMENT_NODE\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\n            const newSelection = internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Anchor node must be a TextNode`);\n            }\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNodeText = selection.anchor.getNode().getTextContent();\n          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;\n          const shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode;\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n          }\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const offset = anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.keyCode;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(keyCode)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(keyCode, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n      // FF does it well (no need to override behavior)\n    } else if (!IS_FIREFOX && isSelectAll(keyCode, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (domAnchorNode === null) {\n        return;\n      }\n      const nodeType = domAnchorNode.nodeType;\n      // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\n      $setSelection(newSelection);\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined || documentRootElementsCount < 1) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, documentRootElementsCount || 0 + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable() || eventName === 'click') {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable()) {\n        switch (eventName) {\n          case 'cut':\n            return dispatchCommand(editor, CUT_COMMAND, event);\n          case 'copy':\n            return dispatchCommand(editor, COPY_COMMAND, event);\n          case 'paste':\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n          case 'dragstart':\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n          case 'dragover':\n            return dispatchCommand(editor, DRAGOVER_COMMAND, event);\n          case 'dragend':\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\n          case 'focus':\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n          case 'blur':\n            {\n              return dispatchCommand(editor, BLUR_COMMAND, event);\n            }\n          case 'drop':\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (!(documentRootElementsCount !== undefined)) {\n    throw Error(`Root element not registered`);\n  } // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  rootElementsRegistered.set(doc, documentRootElementsCount - 1);\n  if (rootElementsRegistered.get(doc) === 0) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n\n  // @ts-expect-error: internal field\n  const editor = rootElement.__lexicalEditor;\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // Allow us to look up the type including static props\n\n  /** @internal */\n\n  /** @internal */\n  //@ts-ignore We set the key in the constructor.\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType() {\n    return this.__type;\n  }\n  isInline() {\n    {\n      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\n    }\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        if (!$isElementNode(node)) {\n          throw Error(`Children of root nodes must be elements`);\n        }\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node. Will throw an error if\n   * called outside of a Lexical Editor {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const constructor = latestNode.constructor;\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      if ($isParagraphNode(latestNode) && $isParagraphNode(mutableNode)) {\n        mutableNode.__textFormat = latestNode.__textFormat;\n      }\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n\n    // @ts-expect-error\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent() {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform() {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent) {\n    removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired() {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectStart() {\n    return this.selectPrevious();\n  }\n  selectEnd() {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty() {\n    this.getWritable();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\n  const lastToInsert2 = lastToInsert || firstToInsert.getParentOrThrow().getLastChild();\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      {\n        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\n      }\n    }\n    current = current.getNextSibling();\n    nodesToInsert.push(current);\n  }\n  let currentNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        if (isOnlyChild(node)) {\n          return null;\n        }\n        return {\n          conversion: convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n}\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\nfunction isOnlyChild(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null) {\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      const lastChild = parentElement.lastChild;\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isWhitespaceDomTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n/** @noInheritDoc */\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat() {\n    return true;\n  }\n\n  // View\n\n  createDOM(config, editor) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!(element !== null && isHTMLElement(element))) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap';\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.toggleUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type) {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  selectStart() {\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore() {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter() {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  const style = span.style;\n  const fontWeight = style.fontWeight;\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = fontWeight === '700' || fontWeight === 'bold';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = style.textDecoration === 'line-through';\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = style.textDecoration === 'underline';\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = style.verticalAlign;\n  return {\n    forChild: lexicalNode => {\n      if (!$isTextNode(lexicalNode)) {\n        return lexicalNode;\n      }\n      if (hasBoldFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      if (hasLinethroughTextDecoration) {\n        lexicalNode.toggleFormat('strikethrough');\n      }\n      if (hasItalicFontStyle) {\n        lexicalNode.toggleFormat('italic');\n      }\n      if (hasUnderlineTextDecoration) {\n        lexicalNode.toggleFormat('underline');\n      }\n      if (verticalAlign === 'sub') {\n        lexicalNode.toggleFormat('subscript');\n      }\n      if (verticalAlign === 'super') {\n        lexicalNode.toggleFormat('superscript');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  return node.nodeName === 'PRE' || node.nodeType === DOM_ELEMENT_TYPE && node.style !== undefined && node.style.whiteSpace !== undefined && node.style.whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nconst inlineParents = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, 'i');\nfunction findTextInLine(text, forward) {\n  let node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\n      const display = node.style.display;\n      if (display === '' && node.nodeName.match(inlineParents) === null || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {\n        lexicalNode.toggleFormat(format);\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    const newNode = new TabNode(node.__key);\n    // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\n    newNode.__text = node.__text;\n    newNode.__format = node.__format;\n    newNode.__style = node.__style;\n    return newNode;\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedTabNode) {\n    const node = $createTabNode();\n    node.setFormat(serializedTabNode.format);\n    node.setStyle(serializedTabNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'tab',\n      version: 1\n    };\n  }\n  setTextContent(_text) {\n    {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n  }\n  setDetail(_detail) {\n    {\n      throw Error(`TabNode does not support setDetail`);\n    }\n  }\n  setMode(_type) {\n    {\n      throw Error(`TabNode does not support setMode`);\n    }\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return false;\n  }\n  getStartEndPoints() {\n    return null;\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n    const style = this.style;\n    if (isBefore && anchor.type === 'element') {\n      $transferStartingElementPointToTextPoint(anchor, focus, format, style);\n    } else if (!isBefore && focus.type === 'element') {\n      $transferStartingElementPointToTextPoint(focus, anchor, format, style);\n    }\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText() {\n    this.insertText('');\n  }\n\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   */\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize()) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      if (!textNode.isToken()) {\n        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n        textNode.setFormat(nextFormat);\n      }\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accomodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes) {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        throw Error(`Expected RangeSelection after insertParagraph`);\n      }\n      return selection.insertNodes(nodes);\n    }\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstBlock = $getAncestor(firstPoint.getNode(), INTERNAL_$isBlock);\n    const last = nodes[nodes.length - 1];\n\n    // CASE 1: insert inside a code block\n    if ('__language' in firstBlock && $isElementNode(firstBlock)) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n    if (!nodes.some(notInline)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\n      }\n      const index = removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant();\n    const blocks = blocksParent.getChildren();\n    const isLI = node => '__value' in node && '__checked' in node;\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || isLI(firstBlock));\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\n      }\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (isLI(insertedParagraph) || INTERNAL_$isBlock(lastToInsert))) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph() {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = removeTextAndSplitBlock(this);\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);\n    if (!$isElementNode(block)) {\n      throw Error(`Expected ancestor to be an ElementNode`);\n    }\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\n    const newBlock = block.insertNewAfter(this, false);\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart) {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(anchor, anchorNode, isBackward) {\n    if (!isBackward && (\n    // Delete forward handle case\n    anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n      const parent = anchorNode.getParent();\n      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      if (this.anchor.type === 'text') {\n        this.modify('extend', isBackward, 'lineboundary');\n      }\n\n      // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n      const endPoint = isBackward ? this.focus : this.anchor;\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n    }\n    this.removeText();\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction $getCharacterOffsets(selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === editor._blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (editor._blockCursorElement !== null) {\n      resolvedOffset--;\n    }\n    resolvedNode = getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset);\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = getNodeFromDOM(anchorDOM);\n    const focusNode = getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return internalCreateRangeSelection(lastSelection, domSelection, editor, null);\n  }\n  return lastSelection.clone();\n}\nfunction $createRangeSelectionFromDom(domSelection, editor) {\n  return internalCreateRangeSelection(null, domSelection, editor, null);\n}\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction removeTextAndSplitBlock(selection) {\n  if (!selection.isCollapsed()) {\n    selection.removeText();\n  }\n  const anchor = selection.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n  while (!INTERNAL_$isBlock(node)) {\n    [node, offset] = splitNodeAtPoint(node, offset);\n  }\n  return offset;\n}\nfunction splitNodeAtPoint(node, offset) {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n    return [parent, index];\n  }\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\n    const newElement = node.insertNewAfter(insertPoint);\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\nfunction $wrapInlineNodes(nodes) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = $isLineBreakNode(node);\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n  return virtualRoot;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  // JSON serialization\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  canReplaceWith(replacement) {\n    return true;\n  }\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__textFormat = 0;\n  }\n  static getType() {\n    return 'paragraph';\n  }\n  getTextFormat() {\n    const self = this.getLatest();\n    return self.__textFormat;\n  }\n  setTextFormat(type) {\n    const self = this.getWritable();\n    self.__textFormat = type;\n    return self;\n  }\n  hasTextFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getTextFormat() & formatFlag) !== 0;\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    node.setTextFormat(serializedNode.textFormat);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      textFormat: this.getTextFormat(),\n      type: 'paragraph',\n      version: 1\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(rangeSelection, restoreSelection) {\n    const newElement = $createParagraphNode();\n    newElement.setTextFormat(rangeSelection.format);\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    newElement.setFormat(this.getFormatType());\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes, additionalConversions) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = map => {\n    Object.keys(map).forEach(key => {\n      let currentCache = conversionCache.get(key);\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ...(config.nodes || [])];\n  const {\n    onError,\n    html\n  } = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace = null;\n      let replaceWithKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      // Ensure custom nodes implement required methods.\n      {\n        const name = klass.name;\n        if (name !== 'RootNode') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\n   * commands and prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  /** @internal */\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n    const registeredNode = this._nodes.get(type);\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload.\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators() {\n    return this._decorators;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        // If content editable is unmounted we'll reset editor state back to original\n        // (or pending) editor state since there will be no reconciliation\n        this._editorState = pendingEditorState;\n        this._pendingEditorState = null;\n        this._window = null;\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState() {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      commitPendingUpdates(this);\n    }\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n    commitPendingUpdates(this);\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserliazation from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\n\nexport { $addUpdateTag, $applyNodeReplacement, $copyNode, $createLineBreakNode, $createNodeSelection, $createParagraphNode, $createPoint, $createRangeSelection, $createRangeSelectionFromDom, $createTabNode, $createTextNode, $getAdjacentNode, $getCharacterOffsets, $getEditor, $getNearestNodeFromDOMNode, $getNearestRootOrShadowRoot, $getNodeByKey, $getPreviousSelection, $getRoot, $getSelection, $getTextContent, $hasAncestor, $hasUpdateTag, $insertNodes, $isBlockElementNode, $isDecoratorNode, $isElementNode, $isInlineElementOrDecoratorNode, $isLeafNode, $isLineBreakNode, $isNodeSelection, $isParagraphNode, $isRangeSelection, $isRootNode, $isRootOrShadowRoot, $isTabNode, $isTextNode, $nodesOfType, $normalizeSelection as $normalizeSelection__EXPERIMENTAL, $parseSerializedNode, $selectAll, $setCompositionKey, $setSelection, $splitNode, BLUR_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CLICK_COMMAND, COMMAND_PRIORITY_CRITICAL, COMMAND_PRIORITY_EDITOR, COMMAND_PRIORITY_HIGH, COMMAND_PRIORITY_LOW, COMMAND_PRIORITY_NORMAL, CONTROLLED_TEXT_INSERTION_COMMAND, COPY_COMMAND, CUT_COMMAND, DELETE_CHARACTER_COMMAND, DELETE_LINE_COMMAND, DELETE_WORD_COMMAND, DRAGEND_COMMAND, DRAGOVER_COMMAND, DRAGSTART_COMMAND, DROP_COMMAND, DecoratorNode, ElementNode, FOCUS_COMMAND, FORMAT_ELEMENT_COMMAND, FORMAT_TEXT_COMMAND, INDENT_CONTENT_COMMAND, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ARROW_UP_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_DOWN_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, KEY_MODIFIER_COMMAND, KEY_SPACE_COMMAND, KEY_TAB_COMMAND, LineBreakNode, MOVE_TO_END, MOVE_TO_START, OUTDENT_CONTENT_COMMAND, PASTE_COMMAND, ParagraphNode, REDO_COMMAND, REMOVE_TEXT_COMMAND, RootNode, SELECTION_CHANGE_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, SELECT_ALL_COMMAND, TabNode, TextNode, UNDO_COMMAND, createCommand, createEditor, getNearestEditorFromDOMNode, isCurrentlyReadOnlyMode, isHTMLAnchorElement, isHTMLElement, isSelectionCapturedInDecoratorInput, isSelectionWithinEditor };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nfunction t(t){return{}}const e={},n={},r={},i={},s={},o={},l={},c={},u={},a={},f={},d={},h={},g={},_={},p={},y={},m={},x={},v={},T={},S={},k={},C={},b={},N={},w={},E={},P={},D={},F={},I={},O={},L={},A={},M={},W={},z={},B={},R={},K={},J={},U={},V={},$={};var H=function(t){const e=new URLSearchParams;e.append(\"code\",t);for(let t=1;t<arguments.length;t++)e.append(\"v\",arguments[t]);throw Error(`Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)};const j=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,q=j&&\"documentMode\"in document?document.documentMode:null,Q=j&&/Mac|iPod|iPhone|iPad/.test(navigator.platform),X=j&&/^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent),Y=!(!j||!(\"InputEvent\"in window)||q)&&\"getTargetRanges\"in new window.InputEvent(\"input\"),Z=j&&/Version\\/[\\d.]+.*Safari/.test(navigator.userAgent),G=j&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream,tt=j&&/Android/.test(navigator.userAgent),et=j&&/^(?=.*Chrome).*/i.test(navigator.userAgent),nt=j&&tt&&et,rt=j&&/AppleWebKit\\/[\\d.]+/.test(navigator.userAgent)&&!et,it=1,st=3,ot=0,lt=1,ct=2,ut=0,at=1,ft=2,dt=4,ht=8,gt=240|(3|dt|ht),_t=1,pt=2,yt=3,mt=4,xt=5,vt=6,Tt=Z||G||rt?\"\":\"\",St=\"\\n\\n\",kt=X?\"\":Tt,Ct=\"---\",bt=\"A-Za-z--------\",Nt=new RegExp(\"^[^\"+bt+\"]*[\"+Ct+\"]\"),wt=new RegExp(\"^[^\"+Ct+\"]*[\"+bt+\"]\"),Et={bold:1,code:16,highlight:128,italic:2,strikethrough:dt,subscript:32,superscript:64,underline:ht},Pt={directionless:1,unmergeable:2},Dt={center:pt,end:vt,justify:mt,left:_t,right:yt,start:xt},Ft={[pt]:\"center\",[vt]:\"end\",[mt]:\"justify\",[_t]:\"left\",[yt]:\"right\",[xt]:\"start\"},It={normal:0,segmented:2,token:1},Ot={[ut]:\"normal\",[ft]:\"segmented\",[at]:\"token\"};function Lt(...t){const e=[];for(const n of t)if(n&&\"string\"==typeof n)for(const[t]of n.matchAll(/\\S+/g))e.push(t);return e}const At=100;let Mt=!1,Wt=0;function zt(t){Wt=t.timeStamp}function Bt(t,e,n){return e.__lexicalLineBreak===t||void 0!==t[`__lexicalKey_${n._key}`]}function Rt(t,e,n){const r=on(n._window);let i=null,s=null;null!==r&&r.anchorNode===t&&(i=r.anchorOffset,s=r.focusOffset);const o=t.nodeValue;null!==o&&Ne(e,o,i,s,!1)}function Kt(t,e,n){if(ti(t)){const e=t.anchor.getNode();if(e.is(n)&&t.format!==e.getFormat())return!1}return e.nodeType===st&&n.isAttached()}function Jt(t,e,n){Mt=!0;const r=performance.now()-Wt>At;try{Qi(t,(()=>{const i=pi()||function(t){return t.getEditorState().read((()=>{const t=pi();return null!==t?t.clone():null}))}(t),s=new Map,o=t.getRootElement(),l=t._editorState,c=t._blockCursorElement;let u=!1,a=\"\";for(let n=0;n<e.length;n++){const f=e[n],d=f.type,h=f.target;let g=he(h,l);if(!(null===g&&h!==o||Yi(g)))if(\"characterData\"===d)r&&Ur(g)&&Kt(i,h,g)&&Rt(h,g,t);else if(\"childList\"===d){u=!0;const e=f.addedNodes;for(let n=0;n<e.length;n++){const r=e[n],i=de(r),s=r.parentNode;if(null!=s&&r!==c&&null===i&&(\"BR\"!==r.nodeName||!Bt(r,s,t))){if(X){const t=r.innerText||r.nodeValue;t&&(a+=t)}s.removeChild(r)}}const n=f.removedNodes,r=n.length;if(r>0){let e=0;for(let i=0;i<r;i++){const r=n[i];(\"BR\"===r.nodeName&&Bt(r,h,t)||c===r)&&(h.appendChild(r),e++)}r!==e&&(h===o&&(g=ye(l)),s.set(h,g))}}}if(s.size>0)for(const[e,n]of s)if(Gi(n)){const r=n.getChildrenKeys();let i=e.firstChild;for(let n=0;n<r.length;n++){const s=r[n],o=t.getElementByKey(s);null!==o&&(null==i?(e.appendChild(o),i=o):i!==o&&e.replaceChild(o,i),i=i.nextSibling)}}else Ur(n)&&n.markDirty();const f=n.takeRecords();if(f.length>0){for(let e=0;e<f.length;e++){const n=f[e],r=n.addedNodes,i=n.target;for(let e=0;e<r.length;e++){const n=r[e],s=n.parentNode;null==s||\"BR\"!==n.nodeName||Bt(n,i,t)||s.removeChild(n)}}n.takeRecords()}null!==i&&(u&&(i.dirty=!0,me(i)),X&&Ke(t)&&i.insertRawText(a))}))}finally{Mt=!1}}function Ut(t){const e=t._observer;if(null!==e){Jt(t,e.takeRecords(),e)}}function Vt(t){!function(t){0===Wt&&Qe(t).addEventListener(\"textInput\",zt,!0)}(t),t._observer=new MutationObserver(((e,n)=>{Jt(t,e,n)}))}function $t(t,e){const n=t.__mode,r=t.__format,i=t.__style,s=e.__mode,o=e.__format,l=e.__style;return!(null!==n&&n!==s||null!==r&&r!==o||null!==i&&i!==l)}function Ht(t,e){const n=t.mergeWithSibling(e),r=Wi()._normalizedNodes;return r.add(t.__key),r.add(e.__key),n}function jt(t){let e,n,r=t;if(\"\"!==r.__text||!r.isSimpleText()||r.isUnmergeable()){for(;null!==(e=r.getPreviousSibling())&&Ur(e)&&e.isSimpleText()&&!e.isUnmergeable();){if(\"\"!==e.__text){if($t(e,r)){r=Ht(e,r);break}break}e.remove()}for(;null!==(n=r.getNextSibling())&&Ur(n)&&n.isSimpleText()&&!n.isUnmergeable();){if(\"\"!==n.__text){if($t(r,n)){r=Ht(r,n);break}break}n.remove()}}else r.remove()}function qt(t){return Qt(t.anchor),Qt(t.focus),t}function Qt(t){for(;\"element\"===t.type;){const e=t.getNode(),n=t.offset;let r,i;if(n===e.getChildrenSize()?(r=e.getChildAtIndex(n-1),i=!0):(r=e.getChildAtIndex(n),i=!1),Ur(r)){t.set(r.__key,i?r.getTextContentSize():0,\"text\");break}if(!Gi(r))break;t.set(r.__key,i?r.getChildrenSize():0,\"element\")}}let Xt=1;const Yt=\"function\"==typeof queueMicrotask?queueMicrotask:t=>{Promise.resolve().then(t)};function Zt(t){const e=document.activeElement;if(null===e)return!1;const n=e.nodeName;return Yi(he(t))&&(\"INPUT\"===n||\"TEXTAREA\"===n||\"true\"===e.contentEditable&&null==e.__lexicalEditor)}function Gt(t,e,n){const r=t.getRootElement();try{return null!==r&&r.contains(e)&&r.contains(n)&&null!==e&&!Zt(e)&&te(e)===t}catch(t){return!1}}function te(t){let e=t;for(;null!=e;){const t=e.__lexicalEditor;if(null!=t)return t;e=$e(e)}return null}function ee(t){return t.isToken()||t.isSegmented()}function ne(t){return t.nodeType===st}function re(t){let e=t;for(;null!=e;){if(ne(e))return e;e=e.firstChild}return null}function ie(t,e,n){const r=Et[e];if(null!==n&&(t&r)==(n&r))return t;let i=t^r;return\"subscript\"===e?i&=~Et.superscript:\"superscript\"===e&&(i&=~Et.subscript),i}function se(t){return Ur(t)||Cr(t)||Yi(t)}function oe(t,e){if(null!=e)return void(t.__key=e);Li(),Ai();const n=Wi(),r=Mi(),i=\"\"+Xt++;r._nodeMap.set(i,t),Gi(t)?n._dirtyElements.set(i,!0):n._dirtyLeaves.add(i),n._cloneNotNeeded.add(i),n._dirtyType=lt,t.__key=i}function le(t){const e=t.getParent();if(null!==e){const n=t.getWritable(),r=e.getWritable(),i=t.getPreviousSibling(),s=t.getNextSibling();if(null===i)if(null!==s){const t=s.getWritable();r.__first=s.__key,t.__prev=null}else r.__first=null;else{const t=i.getWritable();if(null!==s){const e=s.getWritable();e.__prev=t.__key,t.__next=e.__key}else t.__next=null;n.__prev=null}if(null===s)if(null!==i){const t=i.getWritable();r.__last=i.__key,t.__next=null}else r.__last=null;else{const t=s.getWritable();if(null!==i){const e=i.getWritable();e.__next=t.__key,t.__prev=e.__key}else t.__prev=null;n.__next=null}r.__size--,n.__parent=null}}function ce(t){Ai();const e=t.getLatest(),n=e.__parent,r=Mi(),i=Wi(),s=r._nodeMap,o=i._dirtyElements;null!==n&&function(t,e,n){let r=t;for(;null!==r;){if(n.has(r))return;const t=e.get(r);if(void 0===t)break;n.set(r,!1),r=t.__parent}}(n,s,o);const l=e.__key;i._dirtyType=lt,Gi(t)?o.set(l,!0):i._dirtyLeaves.add(l)}function ue(t){Li();const e=Wi(),n=e._compositionKey;if(t!==n){if(e._compositionKey=t,null!==n){const t=fe(n);null!==t&&t.getWritable()}if(null!==t){const e=fe(t);null!==e&&e.getWritable()}}}function ae(){if(Oi())return null;return Wi()._compositionKey}function fe(t,e){const n=(e||Mi())._nodeMap.get(t);return void 0===n?null:n}function de(t,e){const n=t[`__lexicalKey_${Wi()._key}`];return void 0!==n?fe(n,e):null}function he(t,e){let n=t;for(;null!=n;){const t=de(n,e);if(null!==t)return t;n=$e(n)}return null}function ge(t){const e=t._decorators,n=Object.assign({},e);return t._pendingDecorators=n,n}function _e(t){return t.read((()=>pe().getTextContent()))}function pe(){return ye(Mi())}function ye(t){return t._nodeMap.get(\"root\")}function me(t){Li();const e=Mi();null!==t&&(t.dirty=!0,t.setCachedNodes(null)),e._selection=t}function xe(t){const e=Wi(),n=function(t,e){let n=t;for(;null!=n;){const t=n[`__lexicalKey_${e._key}`];if(void 0!==t)return t;n=$e(n)}return null}(t,e);if(null===n){return t===e.getRootElement()?fe(\"root\"):null}return fe(n)}function ve(t,e){return e?t.getTextContentSize():0}function Te(t){return/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(t)}function Se(t){const e=[];let n=t;for(;null!==n;)e.push(n),n=n._parentEditor;return e}function ke(){return Math.random().toString(36).replace(/[^a-z]+/g,\"\").substr(0,5)}function Ce(t){return t.nodeType===st?t.nodeValue:null}function be(t,e,n){const r=on(e._window);if(null===r)return;const i=r.anchorNode;let{anchorOffset:s,focusOffset:o}=r;if(null!==i){let e=Ce(i);const r=he(i);if(null!==e&&Ur(r)){if(e===Tt&&n){const t=n.length;e=n,s=t,o=t}null!==e&&Ne(r,e,s,o,t)}}}function Ne(t,e,n,r,i){let s=t;if(s.isAttached()&&(i||!s.isDirty())){const o=s.isComposing();let l=e;(o||i)&&e[e.length-1]===Tt&&(l=e.slice(0,-1));const c=s.getTextContent();if(i||l!==c){if(\"\"===l){if(ue(null),Z||G||rt)s.remove();else{const t=Wi();setTimeout((()=>{t.update((()=>{s.isAttached()&&s.remove()}))}),20)}return}const e=s.getParent(),i=yi(),c=s.getTextContentSize(),u=ae(),a=s.getKey();if(s.isToken()||null!==u&&a===u&&!o||ti(i)&&(null!==e&&!e.canInsertTextBefore()&&0===i.anchor.offset||i.anchor.key===t.__key&&0===i.anchor.offset&&!s.canInsertTextBefore()&&!o||i.focus.key===t.__key&&i.focus.offset===c&&!s.canInsertTextAfter()&&!o))return void s.markDirty();const f=pi();if(!ti(f)||null===n||null===r)return void s.setTextContent(l);if(f.setTextNodeRange(s,n,s,r),s.isSegmented()){const t=Jr(s.getTextContent());s.replace(t),s=t}s.setTextContent(l)}}}function we(t,e){if(e.isSegmented())return!0;if(!t.isCollapsed())return!1;const n=t.anchor.offset,r=e.getParentOrThrow(),i=e.isToken();return 0===n?!e.canInsertTextBefore()||!r.canInsertTextBefore()&&!e.isComposing()||i||function(t){const e=t.getPreviousSibling();return(Ur(e)||Gi(e)&&e.isInline())&&!e.canInsertTextAfter()}(e):n===e.getTextContentSize()&&(!e.canInsertTextAfter()||!r.canInsertTextAfter()&&!e.isComposing()||i)}function Ee(t){return 37===t}function Pe(t){return 39===t}function De(t,e){return Q?t:e}function Fe(t){return 13===t}function Ie(t){return 8===t}function Oe(t){return 46===t}function Le(t,e,n){return 65===t&&De(e,n)}function Ae(){const t=pe();me(qt(t.select(0,t.getChildrenSize())))}function Me(t,e){void 0===t.__lexicalClassNameCache&&(t.__lexicalClassNameCache={});const n=t.__lexicalClassNameCache,r=n[e];if(void 0!==r)return r;const i=t[e];if(\"string\"==typeof i){const t=Lt(i);return n[e]=t,t}return i}function We(t,e,n,r,i){if(0===n.size)return;const s=r.__type,o=r.__key,l=e.get(s);void 0===l&&H(33,s);const c=l.klass;let u=t.get(c);void 0===u&&(u=new Map,t.set(c,u));const a=u.get(o),f=\"destroyed\"===a&&\"created\"===i;(void 0===a||f)&&u.set(o,f?\"updated\":i)}function ze(t){const e=Mi(),n=e._readOnly,r=t.getType(),i=e._nodeMap,s=[];for(const[,e]of i)e instanceof t&&e.__type===r&&(n||e.isAttached())&&s.push(e);return s}function Be(t,e,n){const r=t.getParent();let i=n,s=t;return null!==r&&(e&&0===n?(i=s.getIndexWithinParent(),s=r):e||n!==s.getChildrenSize()||(i=s.getIndexWithinParent()+1,s=r)),s.getChildAtIndex(e?i-1:i)}function Re(t,e){const n=t.offset;if(\"element\"===t.type){return Be(t.getNode(),e,n)}{const r=t.getNode();if(e&&0===n||!e&&n===r.getTextContentSize()){const t=e?r.getPreviousSibling():r.getNextSibling();return null===t?Be(r.getParentOrThrow(),e,r.getIndexWithinParent()+(e?0:1)):t}}return null}function Ke(t){const e=Qe(t).event,n=e&&e.inputType;return\"insertFromPaste\"===n||\"insertFromPasteAsQuotation\"===n}function Je(t,e,n){return Hi(t,e,n)}function Ue(t){return!ns(t)&&!t.isLastChild()&&!t.isInline()}function Ve(t,e){const n=t._keyToDOMMap.get(e);return void 0===n&&H(75,e),n}function $e(t){const e=t.assignedSlot||t.parentElement;return null!==e&&11===e.nodeType?e.host:e}function He(t){return Wi()._updateTags.has(t)}function je(t){Li();Wi()._updateTags.add(t)}function qe(t,e){let n=t.getParent();for(;null!==n;){if(n.is(e))return!0;n=n.getParent()}return!1}function Qe(t){const e=t._window;return null===e&&H(78),e}function Xe(t){return Gi(t)&&t.isInline()||Yi(t)&&t.isInline()}function Ye(t){let e=t.getParentOrThrow();for(;null!==e;){if(Ze(e))return e;e=e.getParentOrThrow()}return e}function Ze(t){return ns(t)||Gi(t)&&t.isShadowRoot()}function Ge(t){const e=t.constructor.clone(t);return oe(e,null),e}function tn(t){const e=Wi(),n=t.constructor.getType(),r=e._nodes.get(n);void 0===r&&H(97);const i=r.replace;if(null!==i){const e=i(t);return e instanceof t.constructor||H(98),e}return t}function en(t,e){!ns(t.getParent())||Gi(e)||Yi(e)||H(99)}function nn(t){return(Yi(t)||Gi(t)&&!t.canBeEmpty())&&!t.isInline()}function rn(t,e,n){n.style.removeProperty(\"caret-color\"),e._blockCursorElement=null;const r=t.parentElement;null!==r&&r.removeChild(t)}function sn(t,e,n){let r=t._blockCursorElement;if(ti(n)&&n.isCollapsed()&&\"element\"===n.anchor.type&&e.contains(document.activeElement)){const i=n.anchor,s=i.getNode(),o=i.offset;let l=!1,c=null;if(o===s.getChildrenSize()){nn(s.getChildAtIndex(o-1))&&(l=!0)}else{const e=s.getChildAtIndex(o);if(nn(e)){const n=e.getPreviousSibling();(null===n||nn(n))&&(l=!0,c=t.getElementByKey(e.__key))}}if(l){const n=t.getElementByKey(s.__key);return null===r&&(t._blockCursorElement=r=function(t){const e=t.theme,n=document.createElement(\"div\");n.contentEditable=\"false\",n.setAttribute(\"data-lexical-cursor\",\"true\");let r=e.blockCursor;if(void 0!==r){if(\"string\"==typeof r){const t=Lt(r);r=e.blockCursor=t}void 0!==r&&n.classList.add(...r)}return n}(t._config)),e.style.caretColor=\"transparent\",void(null===c?n.appendChild(r):n.insertBefore(r,c))}}null!==r&&rn(r,t,e)}function on(t){return j?(t||window).getSelection():null}function ln(t,e){let n=t.getChildAtIndex(e);null==n&&(n=t),Ze(t)&&H(102);const r=t=>{const e=t.getParentOrThrow(),i=Ze(e),s=t!==n||i?Ge(t):t;if(i)return Gi(t)&&Gi(s)||H(133),t.insertAfter(s),[t,s,s];{const[n,i,o]=r(e),l=t.getNextSiblings();return o.append(s,...l),[n,i,s]}},[i,s]=r(n);return[i,s]}function cn(t){return un(t)&&\"A\"===t.tagName}function un(t){return 1===t.nodeType}function an(t){if(Yi(t)&&!t.isInline())return!0;if(!Gi(t)||Ze(t))return!1;const e=t.getFirstChild(),n=null===e||Cr(e)||Ur(e)||e.isInline();return!t.isInline()&&!1!==t.canBeEmpty()&&n}function fn(t,e){let n=t;for(;null!==n&&null!==n.getParent()&&!e(n);)n=n.getParentOrThrow();return e(n)?n:null}function dn(){return Wi()}function hn(t,e,n,r,i,s){let o=t.getFirstChild();for(;null!==o;){const t=o.__key;o.__parent===e&&(Gi(o)&&hn(o,t,n,r,i,s),n.has(t)||s.delete(t),i.push(t)),o=o.getNextSibling()}}let gn,_n,pn,yn,mn,xn,vn,Tn,Sn,kn,Cn=\"\",bn=\"\",Nn=null,wn=\"\",En=!1,Pn=!1,Dn=null;function Fn(t,e){const n=vn.get(t);if(null!==e){const n=qn(t);n.parentNode===e&&e.removeChild(n)}if(Tn.has(t)||_n._keyToDOMMap.delete(t),Gi(n)){const t=Un(n,vn);In(t,0,t.length-1,null)}void 0!==n&&We(kn,pn,yn,n,\"destroyed\")}function In(t,e,n,r){let i=e;for(;i<=n;++i){const e=t[i];void 0!==e&&Fn(e,r)}}function On(t,e){t.setProperty(\"text-align\",e)}const Ln=\"40px\";function An(t,e){const n=gn.theme.indent;if(\"string\"==typeof n){const r=t.classList.contains(n);e>0&&!r?t.classList.add(n):e<1&&r&&t.classList.remove(n)}const r=getComputedStyle(t).getPropertyValue(\"--lexical-indent-base-value\")||Ln;t.style.setProperty(\"padding-inline-start\",0===e?\"\":`calc(${e} * ${r})`)}function Mn(t,e){const n=t.style;0===e?On(n,\"\"):e===_t?On(n,\"left\"):e===pt?On(n,\"center\"):e===yt?On(n,\"right\"):e===mt?On(n,\"justify\"):e===xt?On(n,\"start\"):e===vt&&On(n,\"end\")}function Wn(t,e,n){const r=Tn.get(t);void 0===r&&H(60);const i=r.createDOM(gn,_n);if(function(t,e,n){const r=n._keyToDOMMap;e[\"__lexicalKey_\"+n._key]=t,r.set(t,e)}(t,i,_n),Ur(r)?i.setAttribute(\"data-lexical-text\",\"true\"):Yi(r)&&i.setAttribute(\"data-lexical-decorator\",\"true\"),Gi(r)){const t=r.__indent,e=r.__size;if(0!==t&&An(i,t),0!==e){const t=e-1;!function(t,e,n,r){const i=bn;bn=\"\",zn(t,n,0,e,r,null),Kn(n,r),bn=i}(Un(r,Tn),t,r,i)}const n=r.__format;0!==n&&Mn(i,n),r.isInline()||Rn(null,r,i),Ue(r)&&(Cn+=St,wn+=St)}else{const e=r.getTextContent();if(Yi(r)){const e=r.decorate(_n,gn);null!==e&&$n(t,e),i.contentEditable=\"false\"}else Ur(r)&&(r.isDirectionless()||(bn+=e));Cn+=e,wn+=e}if(null!==e)if(null!=n)e.insertBefore(i,n);else{const t=e.__lexicalLineBreak;null!=t?e.insertBefore(i,t):e.appendChild(i)}return We(kn,pn,yn,r,\"created\"),i}function zn(t,e,n,r,i,s){const o=Cn;Cn=\"\";let l=n;for(;l<=r;++l){Wn(t[l],i,s);const e=Tn.get(t[l]);null!==e&&null===Nn&&Ur(e)&&(Nn=e.getFormat())}Ue(e)&&(Cn+=St),i.__lexicalTextContent=Cn,Cn=o+Cn}function Bn(t,e){const n=e.get(t);return Cr(n)||Yi(n)&&n.isInline()}function Rn(t,e,n){const r=null!==t&&(0===t.__size||Bn(t.__last,vn)),i=0===e.__size||Bn(e.__last,Tn);if(r){if(!i){const t=n.__lexicalLineBreak;null!=t&&n.removeChild(t),n.__lexicalLineBreak=null}}else if(i){const t=document.createElement(\"br\");n.__lexicalLineBreak=t,n.appendChild(t)}}function Kn(t,e){const n=e.__lexicalDirTextContent,r=e.__lexicalDir;if(n!==bn||r!==Dn){const n=\"\"===bn,s=n?Dn:(i=bn,Nt.test(i)?\"rtl\":wt.test(i)?\"ltr\":null);if(s!==r){const i=e.classList,o=gn.theme;let l=null!==r?o[r]:void 0,c=null!==s?o[s]:void 0;if(void 0!==l){if(\"string\"==typeof l){const t=Lt(l);l=o[r]=t}i.remove(...l)}if(null===s||n&&\"ltr\"===s)e.removeAttribute(\"dir\");else{if(void 0!==c){if(\"string\"==typeof c){const t=Lt(c);c=o[s]=t}void 0!==c&&i.add(...c)}e.dir=s}if(!Pn){t.getWritable().__dir=s}}Dn=s,e.__lexicalDirTextContent=bn,e.__lexicalDir=s}var i}function Jn(t,e,n){const r=bn;var i;bn=\"\",Nn=null,function(t,e,n){const r=Cn,i=t.__size,s=e.__size;if(Cn=\"\",1===i&&1===s){const r=t.__first,i=e.__first;if(r===i)Vn(r,n);else{const t=qn(r),e=Wn(i,null,null);n.replaceChild(e,t),Fn(r,null)}const s=Tn.get(i);null===Nn&&Ur(s)&&(Nn=s.getFormat())}else{const r=Un(t,vn),o=Un(e,Tn);if(0===i)0!==s&&zn(o,e,0,s-1,n,null);else if(0===s){if(0!==i){const t=null==n.__lexicalLineBreak;In(r,0,i-1,t?null:n),t&&(n.textContent=\"\")}}else!function(t,e,n,r,i,s){const o=r-1,l=i-1;let c,u,a=(h=s,h.firstChild),f=0,d=0;var h;for(;f<=o&&d<=l;){const t=e[f],r=n[d];if(t===r)a=Hn(Vn(r,s)),f++,d++;else{void 0===c&&(c=new Set(e)),void 0===u&&(u=new Set(n));const i=u.has(t),o=c.has(r);if(i)if(o){const t=Ve(_n,r);t===a?a=Hn(Vn(r,s)):(null!=a?s.insertBefore(t,a):s.appendChild(t),Vn(r,s)),f++,d++}else Wn(r,s,a),d++;else a=Hn(qn(t)),Fn(t,s),f++}const i=Tn.get(r);null!==i&&null===Nn&&Ur(i)&&(Nn=i.getFormat())}const g=f>o,_=d>l;if(g&&!_){const e=n[l+1];zn(n,t,d,l,s,void 0===e?null:_n.getElementByKey(e))}else _&&!g&&In(e,f,o,s)}(e,r,o,i,s,n)}Ue(e)&&(Cn+=St);n.__lexicalTextContent=Cn,Cn=r+Cn}(t,e,n),Kn(e,n),us(i=e)&&null!=Nn&&Nn!==i.__textFormat&&i.setTextFormat(Nn),bn=r,Nn=null}function Un(t,e){const n=[];let r=t.__first;for(;null!==r;){const t=e.get(r);void 0===t&&H(101),n.push(r),r=t.__next}return n}function Vn(t,e){const n=vn.get(t);let r=Tn.get(t);void 0!==n&&void 0!==r||H(61);const i=En||xn.has(t)||mn.has(t),s=Ve(_n,t);if(n===r&&!i){if(Gi(n)){const t=s.__lexicalTextContent;void 0!==t&&(Cn+=t,wn+=t);const e=s.__lexicalDirTextContent;void 0!==e&&(bn+=e)}else{const t=n.getTextContent();Ur(n)&&!n.isDirectionless()&&(bn+=t),wn+=t,Cn+=t}return s}if(n!==r&&i&&We(kn,pn,yn,r,\"updated\"),r.updateDOM(n,s,gn)){const n=Wn(t,null,null);return null===e&&H(62),e.replaceChild(n,s),Fn(t,null),n}if(Gi(n)&&Gi(r)){const t=r.__indent;t!==n.__indent&&An(s,t);const e=r.__format;e!==n.__format&&Mn(s,e),i&&(Jn(n,r,s),ns(r)||r.isInline()||Rn(n,r,s)),Ue(r)&&(Cn+=St,wn+=St)}else{const e=r.getTextContent();if(Yi(r)){const e=r.decorate(_n,gn);null!==e&&$n(t,e)}else Ur(r)&&!r.isDirectionless()&&(bn+=e);Cn+=e,wn+=e}if(!Pn&&ns(r)&&r.__cachedText!==wn){const t=r.getWritable();t.__cachedText=wn,r=t}return s}function $n(t,e){let n=_n._pendingDecorators;const r=_n._decorators;if(null===n){if(r[t]===e)return;n=ge(_n)}n[t]=e}function Hn(t){let e=t.nextSibling;return null!==e&&e===_n._blockCursorElement&&(e=e.nextSibling),e}function jn(t,e,n,r,i,s){Cn=\"\",wn=\"\",bn=\"\",En=r===ct,Dn=null,_n=n,gn=n._config,pn=n._nodes,yn=_n._listeners.mutation,mn=i,xn=s,vn=t._nodeMap,Tn=e._nodeMap,Pn=e._readOnly,Sn=new Map(n._keyToDOMMap);const o=new Map;return kn=o,Vn(\"root\",null),_n=void 0,pn=void 0,mn=void 0,xn=void 0,vn=void 0,Tn=void 0,gn=void 0,Sn=void 0,kn=void 0,o}function qn(t){const e=Sn.get(t);return void 0===e&&H(75,t),e}const Qn=Object.freeze({}),Xn=30,Yn=[[\"keydown\",function(t,e){if(Zn=t.timeStamp,Gn=t.keyCode,e.isComposing())return;const{keyCode:n,shiftKey:r,ctrlKey:o,metaKey:l,altKey:c}=t;if(Je(e,_,t))return;if(function(t,e,n,r){return Pe(t)&&!e&&!r&&!n}(n,o,c,l))Je(e,p,t);else if(function(t,e,n,r,i){return Pe(t)&&!r&&!n&&(e||i)}(n,o,r,c,l))Je(e,y,t);else if(function(t,e,n,r){return Ee(t)&&!e&&!r&&!n}(n,o,c,l))Je(e,m,t);else if(function(t,e,n,r,i){return Ee(t)&&!r&&!n&&(e||i)}(n,o,r,c,l))Je(e,x,t);else if(function(t,e,n){return function(t){return 38===t}(t)&&!e&&!n}(n,o,l))Je(e,v,t);else if(function(t,e,n){return function(t){return 40===t}(t)&&!e&&!n}(n,o,l))Je(e,T,t);else if(function(t,e){return Fe(t)&&e}(n,r))sr=!0,Je(e,S,t);else if(function(t){return 32===t}(n))Je(e,k,t);else if(function(t,e){return Q&&e&&79===t}(n,o))t.preventDefault(),sr=!0,Je(e,s,!0);else if(function(t,e){return Fe(t)&&!e}(n,r))sr=!1,Je(e,S,t);else if(function(t,e,n,r){return Q?!e&&!n&&(Ie(t)||72===t&&r):!(r||e||n)&&Ie(t)}(n,c,l,o))Ie(n)?Je(e,C,t):(t.preventDefault(),Je(e,i,!0));else if(function(t){return 27===t}(n))Je(e,b,t);else if(function(t,e,n,r,i){return Q?!(n||r||i)&&(Oe(t)||68===t&&e):!(e||r||i)&&Oe(t)}(n,o,r,c,l))Oe(n)?Je(e,N,t):(t.preventDefault(),Je(e,i,!1));else if(function(t,e,n){return Ie(t)&&(Q?e:n)}(n,c,o))t.preventDefault(),Je(e,a,!0);else if(function(t,e,n){return Oe(t)&&(Q?e:n)}(n,c,o))t.preventDefault(),Je(e,a,!1);else if(function(t,e){return Q&&e&&Ie(t)}(n,l))t.preventDefault(),Je(e,f,!0);else if(function(t,e){return Q&&e&&Oe(t)}(n,l))t.preventDefault(),Je(e,f,!1);else if(function(t,e,n,r){return 66===t&&!e&&De(n,r)}(n,c,l,o))t.preventDefault(),Je(e,d,\"bold\");else if(function(t,e,n,r){return 85===t&&!e&&De(n,r)}(n,c,l,o))t.preventDefault(),Je(e,d,\"underline\");else if(function(t,e,n,r){return 73===t&&!e&&De(n,r)}(n,c,l,o))t.preventDefault(),Je(e,d,\"italic\");else if(function(t,e,n,r){return 9===t&&!e&&!n&&!r}(n,c,o,l))Je(e,w,t);else if(function(t,e,n,r){return 90===t&&!e&&De(n,r)}(n,r,l,o))t.preventDefault(),Je(e,h,void 0);else if(function(t,e,n,r){return Q?90===t&&n&&e:89===t&&r||90===t&&r&&e}(n,r,l,o))t.preventDefault(),Je(e,g,void 0);else{ni(e._editorState._selection)?!function(t,e,n,r){return!e&&67===t&&(Q?n:r)}(n,r,l,o)?!function(t,e,n,r){return!e&&88===t&&(Q?n:r)}(n,r,l,o)?Le(n,l,o)&&(t.preventDefault(),Je(e,z,t)):(t.preventDefault(),Je(e,W,t)):(t.preventDefault(),Je(e,M,t)):!X&&Le(n,l,o)&&(t.preventDefault(),Je(e,z,t))}(function(t,e,n,r){return t||e||n||r})(o,r,c,l)&&Je(e,$,t)}],[\"pointerdown\",function(t,e){const n=t.target,r=t.pointerType;n instanceof Node&&\"touch\"!==r&&Qi(e,(()=>{Yi(he(n))||(ir=!0)}))}],[\"compositionstart\",function(t,e){Qi(e,(()=>{const n=pi();if(ti(n)&&!e.isComposing()){const r=n.anchor,i=n.anchor.getNode();ue(r.key),(t.timeStamp<Zn+Xn||\"element\"===r.type||!n.isCollapsed()||i.getFormat()!==n.format||Ur(i)&&i.getStyle()!==n.style)&&Je(e,l,kt)}}))}],[\"compositionend\",function(t,e){X?or=!0:Qi(e,(()=>{dr(e,t.data)}))}],[\"input\",function(t,e){t.stopPropagation(),Qi(e,(()=>{const n=pi(),r=t.data,i=fr(t);if(null!=r&&ti(n)&&cr(n,i,r,t.timeStamp,!1)){or&&(dr(e,r),or=!1);const i=n.anchor,s=i.getNode(),o=on(e._window);if(null===o)return;const c=i.offset;Y&&!n.isCollapsed()&&Ur(s)&&null!==o.anchorNode&&s.getTextContent().slice(0,c)+r+s.getTextContent().slice(c+n.focus.offset)===Ce(o.anchorNode)||Je(e,l,r);const u=r.length;X&&u>1&&\"insertCompositionText\"===t.inputType&&!e.isComposing()&&(n.anchor.offset-=u),Z||G||rt||!e.isComposing()||(Zn=0,ue(null))}else{be(!1,e,null!==r?r:void 0),or&&(dr(e,r||void 0),or=!1)}Li(),Ut(Wi())})),er=null}],[\"click\",function(t,e){Qi(e,(()=>{const n=pi(),i=on(e._window),s=yi();if(i)if(ti(n)){const e=n.anchor,r=e.getNode();if(\"element\"===e.type&&0===e.offset&&n.isCollapsed()&&!ns(r)&&1===pe().getChildrenSize()&&r.getTopLevelElementOrThrow().isEmpty()&&null!==s&&n.is(s))i.removeAllRanges(),n.dirty=!0;else if(3===t.detail&&!n.isCollapsed()){r!==n.focus.getNode()&&(Gi(r)?r.select(0):r.getParentOrThrow().select(0))}}else if(\"touch\"===t.pointerType){const n=i.anchorNode;if(null!==n){const r=n.nodeType;if(r===it||r===st){me(_i(s,i,e,t))}}}Je(e,r,t)}))}],[\"cut\",Qn],[\"copy\",Qn],[\"dragstart\",Qn],[\"dragover\",Qn],[\"dragend\",Qn],[\"paste\",Qn],[\"focus\",Qn],[\"blur\",Qn],[\"drop\",Qn]];Y&&Yn.push([\"beforeinput\",(t,e)=>function(t,e){const n=t.inputType,r=fr(t);if(\"deleteCompositionText\"===n||X&&Ke(e))return;if(\"insertCompositionText\"===n)return;Qi(e,(()=>{const _=pi();if(\"deleteContentBackward\"===n){if(null===_){const t=yi();if(!ti(t))return;me(t.clone())}if(ti(_)){const n=_.anchor.key===_.focus.key;if(p=t.timeStamp,229===Gn&&p<Zn+Xn&&e.isComposing()&&n){if(ue(null),Zn=0,setTimeout((()=>{Qi(e,(()=>{ue(null)}))}),Xn),ti(_)){const t=_.anchor.getNode();t.markDirty(),_.format=t.getFormat(),Ur(t)||H(142),_.style=t.getStyle()}}else{ue(null),t.preventDefault();const r=_.anchor.getNode().getTextContent(),s=0===_.anchor.offset&&_.focus.offset===r.length;nt&&n&&!s||Je(e,i,!0)}return}}var p;if(!ti(_))return;const y=t.data;null!==er&&be(!1,e,er),_.dirty&&null===er||!_.isCollapsed()||ns(_.anchor.getNode())||null===r||_.applyDOMRange(r),er=null;const m=_.anchor,x=_.focus,v=m.getNode(),T=x.getNode();if(\"insertText\"!==n&&\"insertTranspose\"!==n)switch(t.preventDefault(),n){case\"insertFromYank\":case\"insertFromDrop\":case\"insertReplacementText\":Je(e,l,t);break;case\"insertFromComposition\":ue(null),Je(e,l,t);break;case\"insertLineBreak\":ue(null),Je(e,s,!1);break;case\"insertParagraph\":ue(null),sr&&!G?(sr=!1,Je(e,s,!1)):Je(e,o,void 0);break;case\"insertFromPaste\":case\"insertFromPasteAsQuotation\":Je(e,c,t);break;case\"deleteByComposition\":(function(t,e){return t!==e||Gi(t)||Gi(e)||!t.isToken()||!e.isToken()})(v,T)&&Je(e,u,t);break;case\"deleteByDrag\":case\"deleteByCut\":Je(e,u,t);break;case\"deleteContent\":Je(e,i,!1);break;case\"deleteWordBackward\":Je(e,a,!0);break;case\"deleteWordForward\":Je(e,a,!1);break;case\"deleteHardLineBackward\":case\"deleteSoftLineBackward\":Je(e,f,!0);break;case\"deleteContentForward\":case\"deleteHardLineForward\":case\"deleteSoftLineForward\":Je(e,f,!1);break;case\"formatStrikeThrough\":Je(e,d,\"strikethrough\");break;case\"formatBold\":Je(e,d,\"bold\");break;case\"formatItalic\":Je(e,d,\"italic\");break;case\"formatUnderline\":Je(e,d,\"underline\");break;case\"historyUndo\":Je(e,h,void 0);break;case\"historyRedo\":Je(e,g,void 0)}else{if(\"\\n\"===y)t.preventDefault(),Je(e,s,!1);else if(y===St)t.preventDefault(),Je(e,o,void 0);else if(null==y&&t.dataTransfer){const e=t.dataTransfer.getData(\"text/plain\");t.preventDefault(),_.insertRawText(e)}else null!=y&&cr(_,r,y,t.timeStamp,!0)?(t.preventDefault(),Je(e,l,y)):er=y;tr=t.timeStamp}}))}(t,e)]);let Zn=0,Gn=0,tr=0,er=null;const nr=new WeakMap;let rr=!1,ir=!1,sr=!1,or=!1,lr=[0,\"\",0,\"root\",0];function cr(t,e,n,r,i){const s=t.anchor,o=t.focus,l=s.getNode(),c=Wi(),u=on(c._window),a=null!==u?u.anchorNode:null,f=s.key,d=c.getElementByKey(f),h=n.length;return f!==o.key||!Ur(l)||(!i&&(!Y||tr<r+50)||l.isDirty()&&h<2||Te(n))&&s.offset!==o.offset&&!l.isComposing()||ee(l)||l.isDirty()&&h>1||(i||!Y)&&null!==d&&!l.isComposing()&&a!==re(d)||null!==u&&null!==e&&(!e.collapsed||e.startContainer!==u.anchorNode||e.startOffset!==u.anchorOffset)||l.getFormat()!==t.format||l.getStyle()!==t.style||we(t,l)}function ur(t,e){return null!==t&&null!==t.nodeValue&&t.nodeType===st&&0!==e&&e!==t.nodeValue.length}function ar(t,n,r){const{anchorNode:i,anchorOffset:s,focusNode:o,focusOffset:l}=t;rr&&(rr=!1,ur(i,s)&&ur(o,l))||Qi(n,(()=>{if(!r)return void me(null);if(!Gt(n,i,o))return;const c=pi();if(ti(c)){const e=c.anchor,r=e.getNode();if(c.isCollapsed()){\"Range\"===t.type&&t.anchorNode===t.focusNode&&(c.dirty=!0);const i=Qe(n).event,s=i?i.timeStamp:performance.now(),[o,l,u,a,f]=lr,d=pe(),h=!1===n.isComposing()&&\"\"===d.getTextContent();if(s<f+200&&e.offset===u&&e.key===a)c.format=o,c.style=l;else if(\"text\"===e.type)Ur(r)||H(141),c.format=r.getFormat(),c.style=r.getStyle();else if(\"element\"===e.type&&!h){const t=e.getNode();t instanceof os&&0===t.getChildrenSize()?c.format=t.getTextFormat():c.format=0,c.style=\"\"}}else{const t=e.key,n=c.focus.key,r=c.getNodes(),i=r.length,o=c.isBackward(),u=o?l:s,a=o?s:l,f=o?n:t,d=o?t:n;let h=gt,g=!1;for(let t=0;t<i;t++){const e=r[t],n=e.getTextContentSize();if(Ur(e)&&0!==n&&!(0===t&&e.__key===f&&u===n||t===i-1&&e.__key===d&&0===a)&&(g=!0,h&=e.getFormat(),0===h))break}c.format=g?h:0}}Je(n,e,void 0)}))}function fr(t){if(!t.getTargetRanges)return null;const e=t.getTargetRanges();return 0===e.length?null:e[0]}function dr(t,e){const n=t._compositionKey;if(ue(null),null!==n&&null!=e){if(\"\"===e){const e=fe(n),r=re(t.getElementByKey(n));return void(null!==r&&null!==r.nodeValue&&Ur(e)&&Ne(e,r.nodeValue,null,null,!0))}if(\"\\n\"===e[e.length-1]){const e=pi();if(ti(e)){const n=e.focus;return e.anchor.set(n.key,n.offset,n.type),void Je(t,S,null)}}}be(!0,t,e)}function hr(t){let e=t.__lexicalEventHandles;return void 0===e&&(e=[],t.__lexicalEventHandles=e),e}const gr=new Map;function _r(t){const e=t.target,n=on(null==e?null:9===e.nodeType?e.defaultView:e.ownerDocument.defaultView);if(null===n)return;const r=te(n.anchorNode);if(null===r)return;ir&&(ir=!1,Qi(r,(()=>{const e=yi(),i=n.anchorNode;if(null===i)return;const s=i.nodeType;if(s!==it&&s!==st)return;me(_i(e,n,r,t))})));const i=Se(r),s=i[i.length-1],o=s._key,l=gr.get(o),c=l||s;c!==r&&ar(n,c,!1),ar(n,r,!0),r!==s?gr.set(o,r):l&&gr.delete(o)}function pr(t){t._lexicalHandled=!0}function yr(t){return!0===t._lexicalHandled}function mr(t){const e=t.ownerDocument,n=nr.get(e);if(void 0===n)throw Error(\"Root element not registered\");nr.set(e,n-1),0===nr.get(e)&&e.removeEventListener(\"selectionchange\",_r);const r=t.__lexicalEditor;null!=r&&(!function(t){if(null!==t._parentEditor){const e=Se(t),n=e[e.length-1]._key;gr.get(n)===t&&gr.delete(n)}else gr.delete(t._key)}(r),t.__lexicalEditor=null);const i=hr(t);for(let t=0;t<i.length;t++)i[t]();t.__lexicalEventHandles=[]}function xr(t,e,n){Li();const r=t.__key,i=t.getParent();if(null===i)return;const s=function(t){const e=pi();if(!ti(e)||!Gi(t))return e;const{anchor:n,focus:r}=e,i=n.getNode(),s=r.getNode();return qe(i,t)&&n.set(t.__key,0,\"element\"),qe(s,t)&&r.set(t.__key,0,\"element\"),e}(t);let o=!1;if(ti(s)&&e){const e=s.anchor,n=s.focus;e.key===r&&(vi(e,t,i,t.getPreviousSibling(),t.getNextSibling()),o=!0),n.key===r&&(vi(n,t,i,t.getPreviousSibling(),t.getNextSibling()),o=!0)}else ni(s)&&e&&t.isSelected()&&t.selectPrevious();if(ti(s)&&e&&!o){const e=t.getIndexWithinParent();le(t),mi(s,i,e,-1)}else le(t);n||Ze(i)||i.canBeEmpty()||!i.isEmpty()||xr(i,e),e&&ns(i)&&i.isEmpty()&&i.selectEnd()}class vr{static getType(){H(64,this.name)}static clone(t){H(65,this.name)}constructor(t){this.__type=this.constructor.getType(),this.__parent=null,this.__prev=null,this.__next=null,oe(this,t)}getType(){return this.__type}isInline(){H(137,this.constructor.name)}isAttached(){let t=this.__key;for(;null!==t;){if(\"root\"===t)return!0;const e=fe(t);if(null===e)break;t=e.__parent}return!1}isSelected(t){const e=t||pi();if(null==e)return!1;const n=e.getNodes().some((t=>t.__key===this.__key));return(Ur(this)||!ti(e)||\"element\"!==e.anchor.type||\"element\"!==e.focus.type||e.anchor.key!==e.focus.key||e.anchor.offset!==e.focus.offset)&&n}getKey(){return this.__key}getIndexWithinParent(){const t=this.getParent();if(null===t)return-1;let e=t.getFirstChild(),n=0;for(;null!==e;){if(this.is(e))return n;n++,e=e.getNextSibling()}return-1}getParent(){const t=this.getLatest().__parent;return null===t?null:fe(t)}getParentOrThrow(){const t=this.getParent();return null===t&&H(66,this.__key),t}getTopLevelElement(){let t=this;for(;null!==t;){const e=t.getParent();if(Ze(e))return Gi(t)||H(138),t;t=e}return null}getTopLevelElementOrThrow(){const t=this.getTopLevelElement();return null===t&&H(67,this.__key),t}getParents(){const t=[];let e=this.getParent();for(;null!==e;)t.push(e),e=e.getParent();return t}getParentKeys(){const t=[];let e=this.getParent();for(;null!==e;)t.push(e.__key),e=e.getParent();return t}getPreviousSibling(){const t=this.getLatest().__prev;return null===t?null:fe(t)}getPreviousSiblings(){const t=[],e=this.getParent();if(null===e)return t;let n=e.getFirstChild();for(;null!==n&&!n.is(this);)t.push(n),n=n.getNextSibling();return t}getNextSibling(){const t=this.getLatest().__next;return null===t?null:fe(t)}getNextSiblings(){const t=[];let e=this.getNextSibling();for(;null!==e;)t.push(e),e=e.getNextSibling();return t}getCommonAncestor(t){const e=this.getParents(),n=t.getParents();Gi(this)&&e.unshift(this),Gi(t)&&n.unshift(t);const r=e.length,i=n.length;if(0===r||0===i||e[r-1]!==n[i-1])return null;const s=new Set(n);for(let t=0;t<r;t++){const n=e[t];if(s.has(n))return n}return null}is(t){return null!=t&&this.__key===t.__key}isBefore(t){if(this===t)return!1;if(t.isParentOf(this))return!0;if(this.isParentOf(t))return!1;const e=this.getCommonAncestor(t);let n=0,r=0,i=this;for(;;){const t=i.getParentOrThrow();if(t===e){n=i.getIndexWithinParent();break}i=t}for(i=t;;){const t=i.getParentOrThrow();if(t===e){r=i.getIndexWithinParent();break}i=t}return n<r}isParentOf(t){const e=this.__key;if(e===t.__key)return!1;let n=t;for(;null!==n;){if(n.__key===e)return!0;n=n.getParent()}return!1}getNodesBetween(t){const e=this.isBefore(t),n=[],r=new Set;let i=this;for(;null!==i;){const s=i.__key;if(r.has(s)||(r.add(s),n.push(i)),i===t)break;const o=Gi(i)?e?i.getFirstChild():i.getLastChild():null;if(null!==o){i=o;continue}const l=e?i.getNextSibling():i.getPreviousSibling();if(null!==l){i=l;continue}const c=i.getParentOrThrow();if(r.has(c.__key)||n.push(c),c===t)break;let u=null,a=c;do{if(null===a&&H(68),u=e?a.getNextSibling():a.getPreviousSibling(),a=a.getParent(),null===a)break;null!==u||r.has(a.__key)||n.push(a)}while(null===u);i=u}return e||n.reverse(),n}isDirty(){const t=Wi()._dirtyLeaves;return null!==t&&t.has(this.__key)}getLatest(){const t=fe(this.__key);return null===t&&H(113),t}getWritable(){Li();const t=Mi(),e=Wi(),n=t._nodeMap,r=this.__key,i=this.getLatest(),s=i.__parent,o=e._cloneNotNeeded,l=pi();if(null!==l&&l.setCachedNodes(null),o.has(r))return ce(i),i;const c=i.constructor.clone(i);return c.__parent=s,c.__next=i.__next,c.__prev=i.__prev,Gi(i)&&Gi(c)?(us(i)&&us(c)&&(c.__textFormat=i.__textFormat),c.__first=i.__first,c.__last=i.__last,c.__size=i.__size,c.__indent=i.__indent,c.__format=i.__format,c.__dir=i.__dir):Ur(i)&&Ur(c)&&(c.__format=i.__format,c.__style=i.__style,c.__mode=i.__mode,c.__detail=i.__detail),o.add(r),c.__key=r,ce(c),n.set(r,c),c}getTextContent(){return\"\"}getTextContentSize(){return this.getTextContent().length}createDOM(t,e){H(70)}updateDOM(t,e,n){H(71)}exportDOM(t){return{element:this.createDOM(t._config,t)}}exportJSON(){H(72)}static importJSON(t){H(18,this.name)}static transform(){return null}remove(t){xr(this,!0,t)}replace(t,e){Li();let n=pi();null!==n&&(n=n.clone()),en(this,t);const r=this.getLatest(),i=this.__key,s=t.__key,o=t.getWritable(),l=this.getParentOrThrow().getWritable(),c=l.__size;le(o);const u=r.getPreviousSibling(),a=r.getNextSibling(),f=r.__prev,d=r.__next,h=r.__parent;if(xr(r,!1,!0),null===u)l.__first=s;else{u.getWritable().__next=s}if(o.__prev=f,null===a)l.__last=s;else{a.getWritable().__prev=s}if(o.__next=d,o.__parent=h,l.__size=c,e&&(Gi(this)&&Gi(o)||H(139),this.getChildren().forEach((t=>{o.append(t)}))),ti(n)){me(n);const t=n.anchor,e=n.focus;t.key===i&&Xr(t,o),e.key===i&&Xr(e,o)}return ae()===i&&ue(s),o}insertAfter(t,e=!0){Li(),en(this,t);const n=this.getWritable(),r=t.getWritable(),i=r.getParent(),s=pi();let o=!1,l=!1;if(null!==i){const e=t.getIndexWithinParent();if(le(r),ti(s)){const t=i.__key,n=s.anchor,r=s.focus;o=\"element\"===n.type&&n.key===t&&n.offset===e+1,l=\"element\"===r.type&&r.key===t&&r.offset===e+1}}const c=this.getNextSibling(),u=this.getParentOrThrow().getWritable(),a=r.__key,f=n.__next;if(null===c)u.__last=a;else{c.getWritable().__prev=a}if(u.__size++,n.__next=a,r.__next=f,r.__prev=n.__key,r.__parent=n.__parent,e&&ti(s)){const t=this.getIndexWithinParent();mi(s,u,t+1);const e=u.__key;o&&s.anchor.set(e,t+2,\"element\"),l&&s.focus.set(e,t+2,\"element\")}return t}insertBefore(t,e=!0){Li(),en(this,t);const n=this.getWritable(),r=t.getWritable(),i=r.__key;le(r);const s=this.getPreviousSibling(),o=this.getParentOrThrow().getWritable(),l=n.__prev,c=this.getIndexWithinParent();if(null===s)o.__first=i;else{s.getWritable().__next=i}o.__size++,n.__prev=i,r.__prev=l,r.__next=n.__key,r.__parent=n.__parent;const u=pi();if(e&&ti(u)){mi(u,this.getParentOrThrow(),c)}return t}isParentRequired(){return!1}createParentElementNode(){return cs()}selectStart(){return this.selectPrevious()}selectEnd(){return this.selectNext(0,0)}selectPrevious(t,e){Li();const n=this.getPreviousSibling(),r=this.getParentOrThrow();if(null===n)return r.select(0,0);if(Gi(n))return n.select();if(!Ur(n)){const t=n.getIndexWithinParent()+1;return r.select(t,t)}return n.select(t,e)}selectNext(t,e){Li();const n=this.getNextSibling(),r=this.getParentOrThrow();if(null===n)return r.select();if(Gi(n))return n.select(0,0);if(!Ur(n)){const t=n.getIndexWithinParent();return r.select(t,t)}return n.select(t,e)}markDirty(){this.getWritable()}}class Tr extends vr{static getType(){return\"linebreak\"}static clone(t){return new Tr(t.__key)}constructor(t){super(t)}getTextContent(){return\"\\n\"}createDOM(){return document.createElement(\"br\")}updateDOM(){return!1}static importDOM(){return{br:t=>function(t){const e=t.parentElement;if(null!==e){const n=e.firstChild;if(n===t||n.nextSibling===t&&br(n)){const n=e.lastChild;if(n===t||n.previousSibling===t&&br(n))return!0}}return!1}(t)?null:{conversion:Sr,priority:0}}}static importJSON(t){return kr()}exportJSON(){return{type:\"linebreak\",version:1}}}function Sr(t){return{node:kr()}}function kr(){return tn(new Tr)}function Cr(t){return t instanceof Tr}function br(t){return t.nodeType===st&&/^( |\\t|\\r?\\n)+$/.test(t.textContent||\"\")}function Nr(t,e){return 16&e?\"code\":128&e?\"mark\":32&e?\"sub\":64&e?\"sup\":null}function wr(t,e){return 1&e?\"strong\":2&e?\"em\":\"span\"}function Er(t,e,n,r,i){const s=r.classList;let o=Me(i,\"base\");void 0!==o&&s.add(...o),o=Me(i,\"underlineStrikethrough\");let l=!1;const c=e&ht&&e&dt;void 0!==o&&(n&ht&&n&dt?(l=!0,c||s.add(...o)):c&&s.remove(...o));for(const t in Et){const r=Et[t];if(o=Me(i,t),void 0!==o)if(n&r){if(l&&(\"underline\"===t||\"strikethrough\"===t)){e&r&&s.remove(...o);continue}e&r&&(!c||\"underline\"!==t)&&\"strikethrough\"!==t||s.add(...o)}else e&r&&s.remove(...o)}}function Pr(t,e,n){const r=e.firstChild,i=n.isComposing(),s=t+(i?Tt:\"\");if(null==r)e.textContent=s;else{const t=r.nodeValue;if(t!==s)if(i||X){const[e,n,i]=function(t,e){const n=t.length,r=e.length;let i=0,s=0;for(;i<n&&i<r&&t[i]===e[i];)i++;for(;s+i<n&&s+i<r&&t[n-s-1]===e[r-s-1];)s++;return[i,n-i-s,e.slice(i,r-s)]}(t,s);0!==n&&r.deleteData(e,n),r.insertData(e,i)}else r.nodeValue=s}}function Dr(t,e,n,r,i,s){Pr(i,t,e);const o=s.theme.text;void 0!==o&&Er(0,0,r,t,o)}function Fr(t,e){const n=document.createElement(e);return n.appendChild(t),n}class Ir extends vr{static getType(){return\"text\"}static clone(t){return new Ir(t.__text,t.__key)}constructor(t,e){super(e),this.__text=t,this.__format=0,this.__style=\"\",this.__mode=0,this.__detail=0}getFormat(){return this.getLatest().__format}getDetail(){return this.getLatest().__detail}getMode(){const t=this.getLatest();return Ot[t.__mode]}getStyle(){return this.getLatest().__style}isToken(){return 1===this.getLatest().__mode}isComposing(){return this.__key===ae()}isSegmented(){return 2===this.getLatest().__mode}isDirectionless(){return!!(1&this.getLatest().__detail)}isUnmergeable(){return!!(2&this.getLatest().__detail)}hasFormat(t){const e=Et[t];return!!(this.getFormat()&e)}isSimpleText(){return\"text\"===this.__type&&0===this.__mode}getTextContent(){return this.getLatest().__text}getFormatFlags(t,e){return ie(this.getLatest().__format,t,e)}canHaveFormat(){return!0}createDOM(t,e){const n=this.__format,r=Nr(0,n),i=wr(0,n),s=null===r?i:r,o=document.createElement(s);let l=o;this.hasFormat(\"code\")&&o.setAttribute(\"spellcheck\",\"false\"),null!==r&&(l=document.createElement(i),o.appendChild(l));Dr(l,this,0,n,this.__text,t);const c=this.__style;return\"\"!==c&&(o.style.cssText=c),o}updateDOM(t,e,n){const r=this.__text,i=t.__format,s=this.__format,o=Nr(0,i),l=Nr(0,s),c=wr(0,i),u=wr(0,s);if((null===o?c:o)!==(null===l?u:l))return!0;if(o===l&&c!==u){const t=e.firstChild;null==t&&H(48);const i=document.createElement(u);return Dr(i,this,0,s,r,n),e.replaceChild(i,t),!1}let a=e;null!==l&&null!==o&&(a=e.firstChild,null==a&&H(49)),Pr(r,a,this);const f=n.theme.text;void 0!==f&&i!==s&&Er(0,i,s,a,f);const d=t.__style,h=this.__style;return d!==h&&(e.style.cssText=h),!1}static importDOM(){return{\"#text\":()=>({conversion:Wr,priority:0}),b:()=>({conversion:Lr,priority:0}),code:()=>({conversion:Kr,priority:0}),em:()=>({conversion:Kr,priority:0}),i:()=>({conversion:Kr,priority:0}),s:()=>({conversion:Kr,priority:0}),span:()=>({conversion:Or,priority:0}),strong:()=>({conversion:Kr,priority:0}),sub:()=>({conversion:Kr,priority:0}),sup:()=>({conversion:Kr,priority:0}),u:()=>({conversion:Kr,priority:0})}}static importJSON(t){const e=Jr(t.text);return e.setFormat(t.format),e.setDetail(t.detail),e.setMode(t.mode),e.setStyle(t.style),e}exportDOM(t){let{element:e}=super.exportDOM(t);return null!==e&&un(e)||H(132),e.style.whiteSpace=\"pre-wrap\",this.hasFormat(\"bold\")&&(e=Fr(e,\"b\")),this.hasFormat(\"italic\")&&(e=Fr(e,\"i\")),this.hasFormat(\"strikethrough\")&&(e=Fr(e,\"s\")),this.hasFormat(\"underline\")&&(e=Fr(e,\"u\")),{element:e}}exportJSON(){return{detail:this.getDetail(),format:this.getFormat(),mode:this.getMode(),style:this.getStyle(),text:this.getTextContent(),type:\"text\",version:1}}selectionTransform(t,e){}setFormat(t){const e=this.getWritable();return e.__format=\"string\"==typeof t?Et[t]:t,e}setDetail(t){const e=this.getWritable();return e.__detail=\"string\"==typeof t?Pt[t]:t,e}setStyle(t){const e=this.getWritable();return e.__style=t,e}toggleFormat(t){const e=ie(this.getFormat(),t,null);return this.setFormat(e)}toggleDirectionless(){const t=this.getWritable();return t.__detail^=1,t}toggleUnmergeable(){const t=this.getWritable();return t.__detail^=2,t}setMode(t){const e=It[t];if(this.__mode===e)return this;const n=this.getWritable();return n.__mode=e,n}setTextContent(t){if(this.__text===t)return this;const e=this.getWritable();return e.__text=t,e}select(t,e){Li();let n=t,r=e;const i=pi(),s=this.getTextContent(),o=this.__key;if(\"string\"==typeof s){const t=s.length;void 0===n&&(n=t),void 0===r&&(r=t)}else n=0,r=0;if(!ti(i))return fi(o,n,o,r,\"text\",\"text\");{const t=ae();t!==i.anchor.key&&t!==i.focus.key||ue(o),i.setTextNodeRange(this,n,this,r)}return i}selectStart(){return this.select(0,0)}selectEnd(){const t=this.getTextContentSize();return this.select(t,t)}spliceText(t,e,n,r){const i=this.getWritable(),s=i.__text,o=n.length;let l=t;l<0&&(l=o+l,l<0&&(l=0));const c=pi();if(r&&ti(c)){const e=t+o;c.setTextNodeRange(i,e,i,e)}const u=s.slice(0,l)+n+s.slice(l+e);return i.__text=u,i}canInsertTextBefore(){return!0}canInsertTextAfter(){return!0}splitText(...t){Li();const e=this.getLatest(),n=e.getTextContent(),r=e.__key,i=ae(),s=new Set(t),o=[],l=n.length;let c=\"\";for(let t=0;t<l;t++)\"\"!==c&&s.has(t)&&(o.push(c),c=\"\"),c+=n[t];\"\"!==c&&o.push(c);const u=o.length;if(0===u)return[];if(o[0]===n)return[e];const a=o[0],f=e.getParentOrThrow();let d;const h=e.getFormat(),g=e.getStyle(),_=e.__detail;let p=!1;e.isSegmented()?(d=Jr(a),d.__format=h,d.__style=g,d.__detail=_,p=!0):(d=e.getWritable(),d.__text=a);const y=pi(),m=[d];let x=a.length;for(let t=1;t<u;t++){const e=o[t],n=e.length,s=Jr(e).getWritable();s.__format=h,s.__style=g,s.__detail=_;const l=s.__key,c=x+n;if(ti(y)){const t=y.anchor,e=y.focus;t.key===r&&\"text\"===t.type&&t.offset>x&&t.offset<=c&&(t.key=l,t.offset-=x,y.dirty=!0),e.key===r&&\"text\"===e.type&&e.offset>x&&e.offset<=c&&(e.key=l,e.offset-=x,y.dirty=!0)}i===r&&ue(l),x=c,m.push(s)}!function(t){const e=t.getPreviousSibling(),n=t.getNextSibling();null!==e&&ce(e),null!==n&&ce(n)}(this);const v=f.getWritable(),T=this.getIndexWithinParent();return p?(v.splice(T,0,m),this.remove()):v.splice(T,1,m),ti(y)&&mi(y,f,T,u-1),m}mergeWithSibling(t){const e=t===this.getPreviousSibling();e||t===this.getNextSibling()||H(50);const n=this.__key,r=t.__key,i=this.__text,s=i.length;ae()===r&&ue(n);const o=pi();if(ti(o)){const i=o.anchor,l=o.focus;null!==i&&i.key===r&&(Ti(i,e,n,t,s),o.dirty=!0),null!==l&&l.key===r&&(Ti(l,e,n,t,s),o.dirty=!0)}const l=t.__text,c=e?l+i:i+l;this.setTextContent(c);const u=this.getWritable();return t.remove(),u}isTextEntity(){return!1}}function Or(t){const e=t.style,n=e.fontWeight,r=\"700\"===n||\"bold\"===n,i=\"line-through\"===e.textDecoration,s=\"italic\"===e.fontStyle,o=\"underline\"===e.textDecoration,l=e.verticalAlign;return{forChild:t=>Ur(t)?(r&&t.toggleFormat(\"bold\"),i&&t.toggleFormat(\"strikethrough\"),s&&t.toggleFormat(\"italic\"),o&&t.toggleFormat(\"underline\"),\"sub\"===l&&t.toggleFormat(\"subscript\"),\"super\"===l&&t.toggleFormat(\"superscript\"),t):t,node:null}}function Lr(t){const e=\"normal\"===t.style.fontWeight;return{forChild:t=>(Ur(t)&&!e&&t.toggleFormat(\"bold\"),t),node:null}}const Ar=new WeakMap;function Mr(t){return\"PRE\"===t.nodeName||t.nodeType===it&&void 0!==t.style&&void 0!==t.style.whiteSpace&&t.style.whiteSpace.startsWith(\"pre\")}function Wr(t){const e=t;null===t.parentElement&&H(129);let n=e.textContent||\"\";if(null!==function(t){let e,n=t.parentNode;const r=[t];for(;null!==n&&void 0===(e=Ar.get(n))&&!Mr(n);)r.push(n),n=n.parentNode;const i=void 0===e?n:e;for(let t=0;t<r.length;t++)Ar.set(r[t],i);return i}(e)){const t=n.split(/(\\r?\\n|\\t)/),e=[],r=t.length;for(let n=0;n<r;n++){const r=t[n];\"\\n\"===r||\"\\r\\n\"===r?e.push(kr()):\"\\t\"===r?e.push($r()):\"\"!==r&&e.push(Jr(r))}return{node:e}}if(n=n.replace(/\\r/g,\"\").replace(/[ \\t\\n]+/g,\" \"),\"\"===n)return{node:null};if(\" \"===n[0]){let t=e,r=!0;for(;null!==t&&null!==(t=Br(t,!1));){const e=t.textContent||\"\";if(e.length>0){/[ \\t\\n]$/.test(e)&&(n=n.slice(1)),r=!1;break}}r&&(n=n.slice(1))}if(\" \"===n[n.length-1]){let t=e,r=!0;for(;null!==t&&null!==(t=Br(t,!0));){if((t.textContent||\"\").replace(/^( |\\t|\\r?\\n)+/,\"\").length>0){r=!1;break}}r&&(n=n.slice(0,n.length-1))}return\"\"===n?{node:null}:{node:Jr(n)}}const zr=new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/,\"i\");function Br(t,e){let n=t;for(;;){let t;for(;null===(t=e?n.nextSibling:n.previousSibling);){const t=n.parentElement;if(null===t)return null;n=t}if(n=t,n.nodeType===it){const t=n.style.display;if(\"\"===t&&null===n.nodeName.match(zr)||\"\"!==t&&!t.startsWith(\"inline\"))return null}let r=n;for(;null!==(r=e?n.firstChild:n.lastChild);)n=r;if(n.nodeType===st)return n;if(\"BR\"===n.nodeName)return null}}const Rr={code:\"code\",em:\"italic\",i:\"italic\",s:\"strikethrough\",strong:\"bold\",sub:\"subscript\",sup:\"superscript\",u:\"underline\"};function Kr(t){const e=Rr[t.nodeName.toLowerCase()];return void 0===e?{node:null}:{forChild:t=>(Ur(t)&&!t.hasFormat(e)&&t.toggleFormat(e),t),node:null}}function Jr(t=\"\"){return tn(new Ir(t))}function Ur(t){return t instanceof Ir}class Vr extends Ir{static getType(){return\"tab\"}static clone(t){const e=new Vr(t.__key);return e.__text=t.__text,e.__format=t.__format,e.__style=t.__style,e}constructor(t){super(\"\\t\",t),this.__detail=2}static importDOM(){return null}static importJSON(t){const e=$r();return e.setFormat(t.format),e.setStyle(t.style),e}exportJSON(){return{...super.exportJSON(),type:\"tab\",version:1}}setTextContent(t){H(126)}setDetail(t){H(127)}setMode(t){H(128)}canInsertTextBefore(){return!1}canInsertTextAfter(){return!1}}function $r(){return tn(new Vr)}function Hr(t){return t instanceof Vr}class jr{constructor(t,e,n){this._selection=null,this.key=t,this.offset=e,this.type=n}is(t){return this.key===t.key&&this.offset===t.offset&&this.type===t.type}isBefore(t){let e=this.getNode(),n=t.getNode();const r=this.offset,i=t.offset;if(Gi(e)){const t=e.getDescendantByIndex(r);e=null!=t?t:e}if(Gi(n)){const t=n.getDescendantByIndex(i);n=null!=t?t:n}return e===n?r<i:e.isBefore(n)}getNode(){const t=fe(this.key);return null===t&&H(20),t}set(t,e,n){const r=this._selection,i=this.key;this.key=t,this.offset=e,this.type=n,Oi()||(ae()===i&&ue(t),null!==r&&(r.setCachedNodes(null),r.dirty=!0))}}function qr(t,e,n){return new jr(t,e,n)}function Qr(t,e){let n=e.__key,r=t.offset,i=\"element\";if(Ur(e)){i=\"text\";const t=e.getTextContentSize();r>t&&(r=t)}else if(!Gi(e)){const t=e.getNextSibling();if(Ur(t))n=t.__key,r=0,i=\"text\";else{const t=e.getParent();t&&(n=t.__key,r=e.getIndexWithinParent()+1)}}t.set(n,r,i)}function Xr(t,e){if(Gi(e)){const n=e.getLastDescendant();Gi(n)||Ur(n)?Qr(t,n):Qr(t,e)}else Qr(t,e)}function Yr(t,e,n,r){const i=t.getNode(),s=i.getChildAtIndex(t.offset),o=Jr(),l=ns(i)?cs().append(o):o;o.setFormat(n),o.setStyle(r),null===s?i.append(l):s.insertBefore(l),t.is(e)&&e.set(o.__key,0,\"text\"),t.set(o.__key,0,\"text\")}function Zr(t,e,n,r){t.key=e,t.offset=n,t.type=r}class Gr{constructor(t){this._cachedNodes=null,this._nodes=t,this.dirty=!1}getCachedNodes(){return this._cachedNodes}setCachedNodes(t){this._cachedNodes=t}is(t){if(!ni(t))return!1;const e=this._nodes,n=t._nodes;return e.size===n.size&&Array.from(e).every((t=>n.has(t)))}isCollapsed(){return!1}isBackward(){return!1}getStartEndPoints(){return null}add(t){this.dirty=!0,this._nodes.add(t),this._cachedNodes=null}delete(t){this.dirty=!0,this._nodes.delete(t),this._cachedNodes=null}clear(){this.dirty=!0,this._nodes.clear(),this._cachedNodes=null}has(t){return this._nodes.has(t)}clone(){return new Gr(new Set(this._nodes))}extract(){return this.getNodes()}insertRawText(t){}insertText(){}insertNodes(t){const e=this.getNodes(),n=e.length,r=e[n-1];let i;if(Ur(r))i=r.select();else{const t=r.getIndexWithinParent()+1;i=r.getParentOrThrow().select(t,t)}i.insertNodes(t);for(let t=0;t<n;t++)e[t].remove()}getNodes(){const t=this._cachedNodes;if(null!==t)return t;const e=this._nodes,n=[];for(const t of e){const e=fe(t);null!==e&&n.push(e)}return Oi()||(this._cachedNodes=n),n}getTextContent(){const t=this.getNodes();let e=\"\";for(let n=0;n<t.length;n++)e+=t[n].getTextContent();return e}}function ti(t){return t instanceof ei}class ei{constructor(t,e,n,r){this.anchor=t,this.focus=e,t._selection=this,e._selection=this,this._cachedNodes=null,this.format=n,this.style=r,this.dirty=!1}getCachedNodes(){return this._cachedNodes}setCachedNodes(t){this._cachedNodes=t}is(t){return!!ti(t)&&(this.anchor.is(t.anchor)&&this.focus.is(t.focus)&&this.format===t.format&&this.style===t.style)}isCollapsed(){return this.anchor.is(this.focus)}getNodes(){const t=this._cachedNodes;if(null!==t)return t;const e=this.anchor,n=this.focus,r=e.isBefore(n),i=r?e:n,s=r?n:e;let o=i.getNode(),l=s.getNode();const c=i.offset,u=s.offset;if(Gi(o)){const t=o.getDescendantByIndex(c);o=null!=t?t:o}if(Gi(l)){let t=l.getDescendantByIndex(u);null!==t&&t!==o&&l.getChildAtIndex(u)===t&&(t=t.getPreviousSibling()),l=null!=t?t:l}let a;return a=o.is(l)?Gi(o)&&o.getChildrenSize()>0?[]:[o]:o.getNodesBetween(l),Oi()||(this._cachedNodes=a),a}setTextNodeRange(t,e,n,r){Zr(this.anchor,t.__key,e,\"text\"),Zr(this.focus,n.__key,r,\"text\"),this._cachedNodes=null,this.dirty=!0}getTextContent(){const t=this.getNodes();if(0===t.length)return\"\";const e=t[0],n=t[t.length-1],r=this.anchor,i=this.focus,s=r.isBefore(i),[o,l]=ii(this);let c=\"\",u=!0;for(let a=0;a<t.length;a++){const f=t[a];if(Gi(f)&&!f.isInline())u||(c+=\"\\n\"),u=!f.isEmpty();else if(u=!1,Ur(f)){let t=f.getTextContent();f===e?f===n?\"element\"===r.type&&\"element\"===i.type&&i.offset!==r.offset||(t=o<l?t.slice(o,l):t.slice(l,o)):t=s?t.slice(o):t.slice(l):f===n&&(t=s?t.slice(0,l):t.slice(0,o)),c+=t}else!Yi(f)&&!Cr(f)||f===n&&this.isCollapsed()||(c+=f.getTextContent())}return c}applyDOMRange(t){const e=Wi(),n=e.getEditorState()._selection,r=ui(t.startContainer,t.startOffset,t.endContainer,t.endOffset,e,n);if(null===r)return;const[i,s]=r;Zr(this.anchor,i.key,i.offset,i.type),Zr(this.focus,s.key,s.offset,s.type),this._cachedNodes=null}clone(){const t=this.anchor,e=this.focus;return new ei(qr(t.key,t.offset,t.type),qr(e.key,e.offset,e.type),this.format,this.style)}toggleFormat(t){this.format=ie(this.format,t,null),this.dirty=!0}setStyle(t){this.style=t,this.dirty=!0}hasFormat(t){const e=Et[t];return!!(this.format&e)}insertRawText(t){const e=t.split(/(\\r?\\n|\\t)/),n=[],r=e.length;for(let t=0;t<r;t++){const r=e[t];\"\\n\"===r||\"\\r\\n\"===r?n.push(kr()):\"\\t\"===r?n.push($r()):n.push(Jr(r))}this.insertNodes(n)}insertText(t){const e=this.anchor,n=this.focus,r=this.isCollapsed()||e.isBefore(n),i=this.format,s=this.style;r&&\"element\"===e.type?Yr(e,n,i,s):r||\"element\"!==n.type||Yr(n,e,i,s);const o=this.getNodes(),l=o.length,c=r?n:e,u=(r?e:n).offset,a=c.offset;let f=o[0];Ur(f)||H(26);const d=f.getTextContent().length,h=f.getParentOrThrow();let g=o[l-1];if(this.isCollapsed()&&u===d&&(f.isSegmented()||f.isToken()||!f.canInsertTextAfter()||!h.canInsertTextAfter()&&null===f.getNextSibling())){let e=f.getNextSibling();if(Ur(e)&&e.canInsertTextBefore()&&!ee(e)||(e=Jr(),e.setFormat(i),h.canInsertTextAfter()?f.insertAfter(e):h.insertAfter(e)),e.select(0,0),f=e,\"\"!==t)return void this.insertText(t)}else if(this.isCollapsed()&&0===u&&(f.isSegmented()||f.isToken()||!f.canInsertTextBefore()||!h.canInsertTextBefore()&&null===f.getPreviousSibling())){let e=f.getPreviousSibling();if(Ur(e)&&!ee(e)||(e=Jr(),e.setFormat(i),h.canInsertTextBefore()?f.insertBefore(e):h.insertBefore(e)),e.select(),f=e,\"\"!==t)return void this.insertText(t)}else if(f.isSegmented()&&u!==d){const t=Jr(f.getTextContent());t.setFormat(i),f.replace(t),f=t}else if(!this.isCollapsed()&&\"\"!==t){const e=g.getParent();if(!h.canInsertTextBefore()||!h.canInsertTextAfter()||Gi(e)&&(!e.canInsertTextBefore()||!e.canInsertTextAfter()))return this.insertText(\"\"),ci(this.anchor,this.focus,null),void this.insertText(t)}if(1===l){if(f.isToken()){const e=Jr(t);return e.select(),void f.replace(e)}const e=f.getFormat(),n=f.getStyle();if(u!==a||e===i&&n===s){if(Hr(f)){const e=Jr(t);return e.setFormat(i),e.setStyle(s),e.select(),void f.replace(e)}}else{if(\"\"!==f.getTextContent()){const e=Jr(t);if(e.setFormat(i),e.setStyle(s),e.select(),0===u)f.insertBefore(e,!1);else{const[t]=f.splitText(u);t.insertAfter(e,!1)}return void(e.isComposing()&&\"text\"===this.anchor.type&&(this.anchor.offset-=t.length))}f.setFormat(i),f.setStyle(s)}const r=a-u;f=f.spliceText(u,r,t,!0),\"\"===f.getTextContent()?f.remove():\"text\"===this.anchor.type&&(f.isComposing()?this.anchor.offset-=t.length:(this.format=e,this.style=n))}else{const e=new Set([...f.getParentKeys(),...g.getParentKeys()]),n=Gi(f)?f:f.getParentOrThrow();let r=Gi(g)?g:g.getParentOrThrow(),i=g;if(!n.is(r)&&r.isInline())do{i=r,r=r.getParentOrThrow()}while(r.isInline());if(\"text\"===c.type&&(0!==a||\"\"===g.getTextContent())||\"element\"===c.type&&g.getIndexWithinParent()<a)if(Ur(g)&&!g.isToken()&&a!==g.getTextContentSize()){if(g.isSegmented()){const t=Jr(g.getTextContent());g.replace(t),g=t}ns(c.getNode())||\"text\"!==c.type||(g=g.spliceText(0,a,\"\")),e.add(g.__key)}else{const t=g.getParentOrThrow();t.canBeEmpty()||1!==t.getChildrenSize()?g.remove():t.remove()}else e.add(g.__key);const s=r.getChildren(),h=new Set(o),_=n.is(r),p=n.isInline()&&null===f.getNextSibling()?n:f;for(let t=s.length-1;t>=0;t--){const e=s[t];if(e.is(f)||Gi(e)&&e.isParentOf(f))break;e.isAttached()&&(!h.has(e)||e.is(i)?_||p.insertAfter(e,!1):e.remove())}if(!_){let t=r,n=null;for(;null!==t;){const r=t.getChildren(),i=r.length;(0===i||r[i-1].is(n))&&(e.delete(t.__key),n=t),t=t.getParent()}}if(f.isToken())if(u===d)f.select();else{const e=Jr(t);e.select(),f.replace(e)}else f=f.spliceText(u,d-u,t,!0),\"\"===f.getTextContent()?f.remove():f.isComposing()&&\"text\"===this.anchor.type&&(this.anchor.offset-=t.length);for(let t=1;t<l;t++){const n=o[t],r=n.__key;e.has(r)||n.remove()}}}removeText(){this.insertText(\"\")}formatText(t){if(this.isCollapsed())return this.toggleFormat(t),void ue(null);const e=this.getNodes(),n=[];for(const t of e)Ur(t)&&n.push(t);const r=n.length;if(0===r)return this.toggleFormat(t),void ue(null);const i=this.anchor,s=this.focus,o=this.isBackward(),l=o?s:i,c=o?i:s;let u=0,a=n[0],f=\"element\"===l.type?0:l.offset;if(\"text\"===l.type&&f===a.getTextContentSize()&&(u=1,a=n[1],f=0),null==a)return;const d=a.getFormatFlags(t,null),h=r-1;let g=n[h];const _=\"text\"===c.type?c.offset:g.getTextContentSize();if(a.is(g)){if(f===_)return;if(0===f&&_===a.getTextContentSize())a.setFormat(d);else{const t=a.splitText(f,_),e=0===f?t[0]:t[1];e.setFormat(d),\"text\"===l.type&&l.set(e.__key,0,\"text\"),\"text\"===c.type&&c.set(e.__key,_-f,\"text\")}return void(this.format=d)}0!==f&&([,a]=a.splitText(f),f=0),a.setFormat(d);const p=g.getFormatFlags(t,d);_>0&&(_!==g.getTextContentSize()&&([g]=g.splitText(_)),g.setFormat(p));for(let e=u+1;e<h;e++){const r=n[e];if(!r.isToken()){const e=r.getFormatFlags(t,p);r.setFormat(e)}}\"text\"===l.type&&l.set(a.__key,f,\"text\"),\"text\"===c.type&&c.set(g.__key,_,\"text\"),this.format=d|p}insertNodes(t){if(0===t.length)return;if(\"root\"===this.anchor.key){this.insertParagraph();const e=pi();return ti(e)||H(134),e.insertNodes(t)}const e=fn((this.isBackward()?this.focus:this.anchor).getNode(),an),n=t[t.length-1];if(\"__language\"in e&&Gi(e)){if(\"__language\"in t[0])this.insertText(t[0].getTextContent());else{const r=bi(this);e.splice(r,0,t),n.selectEnd()}return}if(!t.some((t=>(Gi(t)||Yi(t))&&!t.isInline()))){Gi(e)||H(135);const r=bi(this);return e.splice(r,0,t),void n.selectEnd()}const r=function(t){const e=cs();let n=null;for(let r=0;r<t.length;r++){const i=t[r],s=Cr(i);if(s||Yi(i)&&i.isInline()||Gi(i)&&i.isInline()||Ur(i)||i.isParentRequired()){if(null===n&&(n=i.createParentElementNode(),e.append(n),s))continue;null!==n&&n.append(i)}else e.append(i),n=null}return e}(t),i=r.getLastDescendant(),s=r.getChildren(),o=t=>\"__value\"in t&&\"__checked\"in t,l=!Gi(e)||!e.isEmpty()?this.insertParagraph():null,c=s[s.length-1];let u=s[0];var a;Gi(a=u)&&an(a)&&!a.isEmpty()&&Gi(e)&&(!e.isEmpty()||o(e))&&(Gi(e)||H(135),e.append(...u.getChildren()),u=s[1]),u&&function(t,e,n){const r=n||e.getParentOrThrow().getLastChild();let i=e;const s=[e];for(;i!==r;)i.getNextSibling()||H(140),i=i.getNextSibling(),s.push(i);let o=t;for(const t of s)o=o.insertAfter(t)}(e,u);const f=fn(i,an);l&&Gi(f)&&(o(l)||an(c))&&(f.append(...l.getChildren()),l.remove()),Gi(e)&&e.isEmpty()&&e.remove(),i.selectEnd();const d=Gi(e)?e.getLastChild():null;Cr(d)&&f!==e&&d.remove()}insertParagraph(){if(\"root\"===this.anchor.key){const t=cs();return pe().splice(this.anchor.offset,0,[t]),t.select(),t}const t=bi(this),e=fn(this.anchor.getNode(),an);Gi(e)||H(136);const n=e.getChildAtIndex(t),r=n?[n,...n.getNextSiblings()]:[],i=e.insertNewAfter(this,!1);return i?(i.append(...r),i.selectStart(),i):null}insertLineBreak(t){const e=kr();if(this.insertNodes([e]),t){const t=e.getParentOrThrow(),n=e.getIndexWithinParent();t.select(n,n)}}extract(){const t=this.getNodes(),e=t.length,n=e-1,r=this.anchor,i=this.focus;let s=t[0],o=t[n];const[l,c]=ii(this);if(0===e)return[];if(1===e){if(Ur(s)&&!this.isCollapsed()){const t=l>c?c:l,e=l>c?l:c,n=s.splitText(t,e),r=0===t?n[0]:n[1];return null!=r?[r]:[]}return[s]}const u=r.isBefore(i);if(Ur(s)){const e=u?l:c;e===s.getTextContentSize()?t.shift():0!==e&&([,s]=s.splitText(e),t[0]=s)}if(Ur(o)){const e=o.getTextContent().length,r=u?c:l;0===r?t.pop():r!==e&&([o]=o.splitText(r),t[n]=o)}return t}modify(t,e,n){const r=this.focus,i=this.anchor,s=\"move\"===t,o=Re(r,e);if(Yi(o)&&!o.isIsolated()){if(s&&o.isKeyboardSelectable()){const t=hi();return t.add(o.__key),void me(t)}const t=e?o.getPreviousSibling():o.getNextSibling();if(Ur(t)){const n=t.__key,o=e?t.getTextContent().length:0;return r.set(n,o,\"text\"),void(s&&i.set(n,o,\"text\"))}{const n=o.getParentOrThrow();let l,c;return Gi(t)?(c=t.__key,l=e?t.getChildrenSize():0):(l=o.getIndexWithinParent(),c=n.__key,e||l++),r.set(c,l,\"element\"),void(s&&i.set(c,l,\"element\"))}}const l=Wi(),c=on(l._window);if(!c)return;const u=l._blockCursorElement,a=l._rootElement;if(null===a||null===u||!Gi(o)||o.isInline()||o.canBeEmpty()||rn(u,l,a),function(t,e,n,r){t.modify(e,n,r)}(c,t,e?\"backward\":\"forward\",n),c.rangeCount>0){const t=c.getRangeAt(0),n=this.anchor.getNode(),r=ns(n)?n:Ye(n);if(this.applyDOMRange(t),this.dirty=!0,!s){const n=this.getNodes(),i=[];let s=!1;for(let t=0;t<n.length;t++){const e=n[t];qe(e,r)?i.push(e):s=!0}if(s&&i.length>0)if(e){const t=i[0];Gi(t)?t.selectStart():t.getParentOrThrow().selectStart()}else{const t=i[i.length-1];Gi(t)?t.selectEnd():t.getParentOrThrow().selectEnd()}c.anchorNode===t.startContainer&&c.anchorOffset===t.startOffset||function(t){const e=t.focus,n=t.anchor,r=n.key,i=n.offset,s=n.type;Zr(n,e.key,e.offset,e.type),Zr(e,r,i,s),t._cachedNodes=null}(this)}}}forwardDeletion(t,e,n){if(!n&&(\"element\"===t.type&&Gi(e)&&t.offset===e.getChildrenSize()||\"text\"===t.type&&t.offset===e.getTextContentSize())){const t=e.getParent(),n=e.getNextSibling()||(null===t?null:t.getNextSibling());if(Gi(n)&&n.isShadowRoot())return!0}return!1}deleteCharacter(t){const n=this.isCollapsed();if(this.isCollapsed()){const n=this.anchor;let r=n.getNode();if(this.forwardDeletion(n,r,t))return;const i=this.focus,s=Re(i,t);if(Yi(s)&&!s.isIsolated()){if(s.isKeyboardSelectable()&&Gi(r)&&0===r.getChildrenSize()){r.remove();const t=hi();t.add(s.__key),me(t)}else{s.remove();Wi().dispatchCommand(e,void 0)}return}if(!t&&Gi(s)&&Gi(r)&&r.isEmpty())return r.remove(),void s.selectStart();if(this.modify(\"extend\",t,\"character\"),this.isCollapsed()){if(t&&0===n.offset){if((\"element\"===n.type?n.getNode():n.getNode().getParentOrThrow()).collapseAtStart(this))return}}else{const e=\"text\"===i.type?i.getNode():null;if(r=\"text\"===n.type?n.getNode():null,null!==e&&e.isSegmented()){const n=i.offset,s=e.getTextContentSize();if(e.is(r)||t&&n!==s||!t&&0!==n)return void si(e,t,n)}else if(null!==r&&r.isSegmented()){const i=n.offset,s=r.getTextContentSize();if(r.is(e)||t&&0!==i||!t&&i!==s)return void si(r,t,i)}!function(t,e){const n=t.anchor,r=t.focus,i=n.getNode(),s=r.getNode();if(i===s&&\"text\"===n.type&&\"text\"===r.type){const t=n.offset,s=r.offset,o=t<s,l=o?t:s,c=o?s:t,u=c-1;if(l!==u){Te(i.getTextContent().slice(l,c))||(e?r.offset=u:n.offset=u)}}}(this,t)}}if(this.removeText(),t&&!n&&this.isCollapsed()&&\"element\"===this.anchor.type&&0===this.anchor.offset){const t=this.anchor.getNode();t.isEmpty()&&ns(t.getParent())&&0===t.getIndexWithinParent()&&t.collapseAtStart(this)}}deleteLine(t){if(this.isCollapsed()){\"text\"===this.anchor.type&&this.modify(\"extend\",t,\"lineboundary\");0===(t?this.focus:this.anchor).offset&&this.modify(\"extend\",t,\"character\")}this.removeText()}deleteWord(t){if(this.isCollapsed()){const e=this.anchor,n=e.getNode();if(this.forwardDeletion(e,n,t))return;this.modify(\"extend\",t,\"word\")}this.removeText()}isBackward(){return this.focus.isBefore(this.anchor)}getStartEndPoints(){return[this.anchor,this.focus]}}function ni(t){return t instanceof Gr}function ri(t){const e=t.offset;if(\"text\"===t.type)return e;const n=t.getNode();return e===n.getChildrenSize()?n.getTextContent().length:0}function ii(t){const e=t.getStartEndPoints();if(null===e)return[0,0];const[n,r]=e;return\"element\"===n.type&&\"element\"===r.type&&n.key===r.key&&n.offset===r.offset?[0,0]:[ri(n),ri(r)]}function si(t,e,n){const r=t,i=r.getTextContent().split(/(?=\\s)/g),s=i.length;let o=0,l=0;for(let t=0;t<s;t++){const r=t===s-1;if(l=o,o+=i[t].length,e&&o===n||o>n||r){i.splice(t,1),r&&(l=void 0);break}}const c=i.join(\"\").trim();\"\"===c?r.remove():(r.setTextContent(c),r.select(l,l))}function oi(t,e,n,r){let i,s=e;if(t.nodeType===it){let o=!1;const l=t.childNodes,c=l.length;s===c&&(o=!0,s=c-1);let u=l[s],a=!1;if(u===r._blockCursorElement?(u=l[s+1],a=!0):null!==r._blockCursorElement&&s--,i=xe(u),Ur(i))s=ve(i,o);else{let r=xe(t);if(null===r)return null;if(Gi(r)){s=Math.min(r.getChildrenSize(),s);let t=r.getChildAtIndex(s);if(Gi(t)&&function(t,e,n){const r=t.getParent();return null===n||null===r||!r.canBeEmpty()||r!==n.getNode()}(t,0,n)){const e=o?t.getLastDescendant():t.getFirstDescendant();null===e?(r=t,s=0):(t=e,r=Gi(t)?t:t.getParentOrThrow())}Ur(t)?(i=t,r=null,s=ve(t,o)):t!==r&&o&&!a&&s++}else{const n=r.getIndexWithinParent();s=0===e&&Yi(r)&&xe(t)===r?n:n+1,r=r.getParentOrThrow()}if(Gi(r))return qr(r.__key,s,\"element\")}}else i=xe(t);return Ur(i)?qr(i.__key,s,\"text\"):null}function li(t,e,n){const r=t.offset,i=t.getNode();if(0===r){const r=i.getPreviousSibling(),s=i.getParent();if(e){if((n||!e)&&null===r&&Gi(s)&&s.isInline()){const e=s.getPreviousSibling();Ur(e)&&(t.key=e.__key,t.offset=e.getTextContent().length)}}else Gi(r)&&!n&&r.isInline()?(t.key=r.__key,t.offset=r.getChildrenSize(),t.type=\"element\"):Ur(r)&&(t.key=r.__key,t.offset=r.getTextContent().length)}else if(r===i.getTextContent().length){const r=i.getNextSibling(),s=i.getParent();if(e&&Gi(r)&&r.isInline())t.key=r.__key,t.offset=0,t.type=\"element\";else if((n||e)&&null===r&&Gi(s)&&s.isInline()&&!s.canInsertTextAfter()){const e=s.getNextSibling();Ur(e)&&(t.key=e.__key,t.offset=0)}}}function ci(t,e,n){if(\"text\"===t.type&&\"text\"===e.type){const r=t.isBefore(e),i=t.is(e);li(t,r,i),li(e,!r,i),i&&(e.key=t.key,e.offset=t.offset,e.type=t.type);const s=Wi();if(s.isComposing()&&s._compositionKey!==t.key&&ti(n)){const r=n.anchor,i=n.focus;Zr(t,r.key,r.offset,r.type),Zr(e,i.key,i.offset,i.type)}}}function ui(t,e,n,r,i,s){if(null===t||null===n||!Gt(i,t,n))return null;const o=oi(t,e,ti(s)?s.anchor:null,i);if(null===o)return null;const l=oi(n,r,ti(s)?s.focus:null,i);if(null===l)return null;if(\"element\"===o.type&&\"element\"===l.type){const e=xe(t),r=xe(n);if(Yi(e)&&Yi(r))return null}return ci(o,l,s),[o,l]}function ai(t){return Gi(t)&&!t.isInline()}function fi(t,e,n,r,i,s){const o=Mi(),l=new ei(qr(t,e,i),qr(n,r,s),0,\"\");return l.dirty=!0,o._selection=l,l}function di(){const t=qr(\"root\",0,\"element\"),e=qr(\"root\",0,\"element\");return new ei(t,e,0,\"\")}function hi(){return new Gr(new Set)}function gi(t,e){return _i(null,t,e,null)}function _i(t,e,n,r){const i=n._window;if(null===i)return null;const s=r||i.event,o=s?s.type:void 0,l=\"selectionchange\"===o,c=!Mt&&(l||\"beforeinput\"===o||\"compositionstart\"===o||\"compositionend\"===o||\"click\"===o&&s&&3===s.detail||\"drop\"===o||void 0===o);let u,a,f,d;if(ti(t)&&!c)return t.clone();if(null===e)return null;if(u=e.anchorNode,a=e.focusNode,f=e.anchorOffset,d=e.focusOffset,l&&ti(t)&&!Gt(n,u,a))return t.clone();const h=ui(u,f,a,d,n,t);if(null===h)return null;const[g,_]=h;return new ei(g,_,ti(t)?t.format:0,ti(t)?t.style:\"\")}function pi(){return Mi()._selection}function yi(){return Wi()._editorState._selection}function mi(t,e,n,r=1){const i=t.anchor,s=t.focus,o=i.getNode(),l=s.getNode();if(!e.is(o)&&!e.is(l))return;const c=e.__key;if(t.isCollapsed()){const e=i.offset;if(n<=e&&r>0||n<e&&r<0){const n=Math.max(0,e+r);i.set(c,n,\"element\"),s.set(c,n,\"element\"),xi(t)}}else{const o=t.isBackward(),l=o?s:i,u=l.getNode(),a=o?i:s,f=a.getNode();if(e.is(u)){const t=l.offset;(n<=t&&r>0||n<t&&r<0)&&l.set(c,Math.max(0,t+r),\"element\")}if(e.is(f)){const t=a.offset;(n<=t&&r>0||n<t&&r<0)&&a.set(c,Math.max(0,t+r),\"element\")}}xi(t)}function xi(t){const e=t.anchor,n=e.offset,r=t.focus,i=r.offset,s=e.getNode(),o=r.getNode();if(t.isCollapsed()){if(!Gi(s))return;const t=s.getChildrenSize(),i=n>=t,o=i?s.getChildAtIndex(t-1):s.getChildAtIndex(n);if(Ur(o)){let t=0;i&&(t=o.getTextContentSize()),e.set(o.__key,t,\"text\"),r.set(o.__key,t,\"text\")}}else{if(Gi(s)){const t=s.getChildrenSize(),r=n>=t,i=r?s.getChildAtIndex(t-1):s.getChildAtIndex(n);if(Ur(i)){let t=0;r&&(t=i.getTextContentSize()),e.set(i.__key,t,\"text\")}}if(Gi(o)){const t=o.getChildrenSize(),e=i>=t,n=e?o.getChildAtIndex(t-1):o.getChildAtIndex(i);if(Ur(n)){let t=0;e&&(t=n.getTextContentSize()),r.set(n.__key,t,\"text\")}}}}function vi(t,e,n,r,i){let s=null,o=0,l=null;null!==r?(s=r.__key,Ur(r)?(o=r.getTextContentSize(),l=\"text\"):Gi(r)&&(o=r.getChildrenSize(),l=\"element\")):null!==i&&(s=i.__key,Ur(i)?l=\"text\":Gi(i)&&(l=\"element\")),null!==s&&null!==l?t.set(s,o,l):(o=e.getIndexWithinParent(),-1===o&&(o=n.getChildrenSize()),t.set(n.__key,o,\"element\"))}function Ti(t,e,n,r,i){\"text\"===t.type?(t.key=n,e||(t.offset+=i)):t.offset>r.getIndexWithinParent()&&(t.offset-=1)}function Si(t,e,n,r,i,s,o){const l=r.anchorNode,c=r.focusNode,u=r.anchorOffset,a=r.focusOffset,f=document.activeElement;if(i.has(\"collaboration\")&&f!==s||null!==f&&Zt(f))return;if(!ti(e))return void(null!==t&&Gt(n,l,c)&&r.removeAllRanges());const d=e.anchor,h=e.focus,g=d.key,_=h.key,p=Ve(n,g),y=Ve(n,_),m=d.offset,x=h.offset,v=e.format,T=e.style,S=e.isCollapsed();let k=p,C=y,b=!1;if(\"text\"===d.type){k=re(p);const t=d.getNode();b=t.getFormat()!==v||t.getStyle()!==T}else ti(t)&&\"text\"===t.anchor.type&&(b=!0);var N,w,E,P,D;if((\"text\"===h.type&&(C=re(y)),null!==k&&null!==C)&&(S&&(null===t||b||ti(t)&&(t.format!==v||t.style!==T))&&(N=v,w=T,E=m,P=g,D=performance.now(),lr=[N,w,E,P,D]),u!==m||a!==x||l!==k||c!==C||\"Range\"===r.type&&S||(null!==f&&s.contains(f)||s.focus({preventScroll:!0}),\"element\"===d.type))){try{r.setBaseAndExtent(k,m,C,x)}catch(t){}if(!i.has(\"skip-scroll-into-view\")&&e.isCollapsed()&&null!==s&&s===document.activeElement){const t=e instanceof ei&&\"element\"===e.anchor.type?k.childNodes[m]||null:r.rangeCount>0?r.getRangeAt(0):null;if(null!==t){let e;if(t instanceof Text){const n=document.createRange();n.selectNode(t),e=n.getBoundingClientRect()}else e=t.getBoundingClientRect();!function(t,e,n){const r=n.ownerDocument,i=r.defaultView;if(null===i)return;let{top:s,bottom:o}=e,l=0,c=0,u=n;for(;null!==u;){const e=u===r.body;if(e)l=0,c=Qe(t).innerHeight;else{const t=u.getBoundingClientRect();l=t.top,c=t.bottom}let n=0;if(s<l?n=-(l-s):o>c&&(n=o-c),0!==n)if(e)i.scrollBy(0,n);else{const t=u.scrollTop;u.scrollTop+=n;const e=u.scrollTop-t;s-=e,o-=e}if(e)break;u=$e(u)}}(n,e,s)}}rr=!0}}function ki(t){let e=pi()||yi();null===e&&(e=pe().selectEnd()),e.insertNodes(t)}function Ci(){const t=pi();return null===t?\"\":t.getTextContent()}function bi(t){t.isCollapsed()||t.removeText();const e=t.anchor;let n=e.getNode(),r=e.offset;for(;!an(n);)[n,r]=Ni(n,r);return r}function Ni(t,e){const n=t.getParent();if(!n){const t=cs();return pe().append(t),t.select(),[pe(),0]}if(Ur(t)){const r=t.splitText(e);if(0===r.length)return[n,t.getIndexWithinParent()];const i=0===e?0:1;return[n,r[0].getIndexWithinParent()+i]}if(!Gi(t)||0===e)return[n,t.getIndexWithinParent()];const r=t.getChildAtIndex(e);if(r){const n=new ei(qr(t.__key,e,\"element\"),qr(t.__key,e,\"element\"),0,\"\"),i=t.insertNewAfter(n);i&&i.append(r,...r.getNextSiblings())}return[n,t.getIndexWithinParent()+1]}let wi=null,Ei=null,Pi=!1,Di=!1,Fi=0;const Ii={characterData:!0,childList:!0,subtree:!0};function Oi(){return Pi||null!==wi&&wi._readOnly}function Li(){Pi&&H(13)}function Ai(){Fi>99&&H(14)}function Mi(){return null===wi&&H(15),wi}function Wi(){return null===Ei&&H(16),Ei}function zi(){return Ei}function Bi(t,e,n){const r=e.__type,i=function(t,e){const n=t._nodes.get(e);return void 0===n&&H(30,e),n}(t,r);let s=n.get(r);void 0===s&&(s=Array.from(i.transforms),n.set(r,s));const o=s.length;for(let t=0;t<o&&(s[t](e),e.isAttached());t++);}function Ri(t,e){return void 0!==t&&t.__key!==e&&t.isAttached()}function Ki(t){return Ji(t,Wi()._nodes)}function Ji(t,e){const n=t.type,r=e.get(n);void 0===r&&H(17,n);const i=r.klass;t.type!==i.getType()&&H(18,i.name);const s=i.importJSON(t),o=t.children;if(Gi(s)&&Array.isArray(o))for(let t=0;t<o.length;t++){const n=Ji(o[t],e);s.append(n)}return s}function Ui(t,e){const n=wi,r=Pi,i=Ei;wi=t,Pi=!0,Ei=null;try{return e()}finally{wi=n,Pi=r,Ei=i}}function Vi(t,n){const r=t._pendingEditorState,i=t._rootElement,s=t._headless||null===i;if(null===r)return;const o=t._editorState,l=o._selection,c=r._selection,u=t._dirtyType!==ot,a=wi,f=Pi,d=Ei,h=t._updating,g=t._observer;let _=null;if(t._pendingEditorState=null,t._editorState=r,!s&&u&&null!==g){Ei=t,wi=r,Pi=!1,t._updating=!0;try{const e=t._dirtyType,n=t._dirtyElements,i=t._dirtyLeaves;g.disconnect(),_=jn(o,r,t,e,n,i)}catch(e){if(e instanceof Error&&t._onError(e),Di)throw e;return _s(t,null,i,r),Vt(t),t._dirtyType=ct,Di=!0,Vi(t,o),void(Di=!1)}finally{g.observe(i,Ii),t._updating=h,wi=a,Pi=f,Ei=d}}r._readOnly||(r._readOnly=!0);const p=t._dirtyLeaves,y=t._dirtyElements,m=t._normalizedNodes,x=t._updateTags,v=t._deferred;u&&(t._dirtyType=ot,t._cloneNotNeeded.clear(),t._dirtyLeaves=new Set,t._dirtyElements=new Map,t._normalizedNodes=new Set,t._updateTags=new Set),function(t,e){const n=t._decorators;let r=t._pendingDecorators||n;const i=e._nodeMap;let s;for(s in r)i.has(s)||(r===n&&(r=ge(t)),delete r[s])}(t,r);const T=s?null:on(t._window);if(t._editable&&null!==T&&(u||null===c||c.dirty)){Ei=t,wi=r;try{if(null!==g&&g.disconnect(),u||null===c||c.dirty){const e=t._blockCursorElement;null!==e&&rn(e,t,i),Si(l,c,t,T,x,i)}sn(t,i,c),null!==g&&g.observe(i,Ii)}finally{Ei=d,wi=a}}null!==_&&function(t,e,n,r,i){const s=Array.from(t._listeners.mutation),o=s.length;for(let t=0;t<o;t++){const[o,l]=s[t],c=e.get(l);void 0!==c&&o(c,{dirtyLeaves:r,prevEditorState:i,updateTags:n})}}(t,_,x,p,o),ti(c)||null===c||null!==l&&l.is(c)||t.dispatchCommand(e,void 0);const S=t._pendingDecorators;null!==S&&(t._decorators=S,t._pendingDecorators=null,$i(\"decorator\",t,!0,S)),function(t,e,n){const r=_e(e),i=_e(n);r!==i&&$i(\"textcontent\",t,!0,i)}(t,n||o,r),$i(\"update\",t,!0,{dirtyElements:y,dirtyLeaves:p,editorState:r,normalizedNodes:m,prevEditorState:n||o,tags:x}),function(t,e){if(t._deferred=[],0!==e.length){const n=t._updating;t._updating=!0;try{for(let t=0;t<e.length;t++)e[t]()}finally{t._updating=n}}}(t,v),function(t){const e=t._updates;if(0!==e.length){const n=e.shift();if(n){const[e,r]=n;qi(t,e,r)}}}(t)}function $i(t,e,n,...r){const i=e._updating;e._updating=n;try{const n=Array.from(e._listeners[t]);for(let t=0;t<n.length;t++)n[t].apply(null,r)}finally{e._updating=i}}function Hi(t,e,n){if(!1===t._updating||Ei!==t){let r=!1;return t.update((()=>{r=Hi(t,e,n)})),r}const r=Se(t);for(let i=4;i>=0;i--)for(let s=0;s<r.length;s++){const o=r[s]._commands.get(e);if(void 0!==o){const e=o[i];if(void 0!==e){const r=Array.from(e),i=r.length;for(let e=0;e<i;e++)if(!0===r[e](n,t))return!0}}}return!1}function ji(t,e){const n=t._updates;let r=e||!1;for(;0!==n.length;){const e=n.shift();if(e){const[n,i]=e;let s,o;void 0!==i&&(s=i.onUpdate,o=i.tag,i.skipTransforms&&(r=!0),s&&t._deferred.push(s),o&&t._updateTags.add(o)),n()}}return r}function qi(t,e,n){const r=t._updateTags;let i,s,o=!1,l=!1;void 0!==n&&(i=n.onUpdate,s=n.tag,null!=s&&r.add(s),o=n.skipTransforms||!1,l=n.discrete||!1),i&&t._deferred.push(i);const c=t._editorState;let u=t._pendingEditorState,a=!1;(null===u||u._readOnly)&&(u=t._pendingEditorState=new ss(new Map((u||c)._nodeMap)),a=!0),u._flushSync=l;const f=wi,d=Pi,h=Ei,g=t._updating;wi=u,Pi=!1,t._updating=!0,Ei=t;try{a&&(t._headless?null!==c._selection&&(u._selection=c._selection.clone()):u._selection=function(t){const e=t.getEditorState()._selection,n=on(t._window);return ti(e)||null==e?_i(e,n,t,null):e.clone()}(t));const n=t._compositionKey;e(),o=ji(t,o),function(t,e){const n=e.getEditorState()._selection,r=t._selection;if(ti(r)){const t=r.anchor,e=r.focus;let i;if(\"text\"===t.type&&(i=t.getNode(),i.selectionTransform(n,r)),\"text\"===e.type){const t=e.getNode();i!==t&&t.selectionTransform(n,r)}}}(u,t),t._dirtyType!==ot&&(o?function(t,e){const n=e._dirtyLeaves,r=t._nodeMap;for(const t of n){const e=r.get(t);Ur(e)&&e.isAttached()&&e.isSimpleText()&&!e.isUnmergeable()&&jt(e)}}(u,t):function(t,e){const n=e._dirtyLeaves,r=e._dirtyElements,i=t._nodeMap,s=ae(),o=new Map;let l=n,c=l.size,u=r,a=u.size;for(;c>0||a>0;){if(c>0){e._dirtyLeaves=new Set;for(const t of l){const r=i.get(t);Ur(r)&&r.isAttached()&&r.isSimpleText()&&!r.isUnmergeable()&&jt(r),void 0!==r&&Ri(r,s)&&Bi(e,r,o),n.add(t)}if(l=e._dirtyLeaves,c=l.size,c>0){Fi++;continue}}e._dirtyLeaves=new Set,e._dirtyElements=new Map;for(const t of u){const n=t[0],l=t[1];if(\"root\"!==n&&!l)continue;const c=i.get(n);void 0!==c&&Ri(c,s)&&Bi(e,c,o),r.set(n,l)}l=e._dirtyLeaves,c=l.size,u=e._dirtyElements,a=u.size,Fi++}e._dirtyLeaves=n,e._dirtyElements=r}(u,t),ji(t),function(t,e,n,r){const i=t._nodeMap,s=e._nodeMap,o=[];for(const[t]of r){const e=s.get(t);void 0!==e&&(e.isAttached()||(Gi(e)&&hn(e,t,i,s,o,r),i.has(t)||r.delete(t),o.push(t)))}for(const t of o)s.delete(t);for(const t of n){const e=s.get(t);void 0===e||e.isAttached()||(i.has(t)||n.delete(t),s.delete(t))}}(c,u,t._dirtyLeaves,t._dirtyElements));n!==t._compositionKey&&(u._flushSync=!0);const r=u._selection;if(ti(r)){const t=u._nodeMap,e=r.anchor.key,n=r.focus.key;void 0!==t.get(e)&&void 0!==t.get(n)||H(19)}else ni(r)&&0===r._nodes.size&&(u._selection=null)}catch(e){return e instanceof Error&&t._onError(e),t._pendingEditorState=c,t._dirtyType=ct,t._cloneNotNeeded.clear(),t._dirtyLeaves=new Set,t._dirtyElements.clear(),void Vi(t)}finally{wi=f,Pi=d,Ei=h,t._updating=g,Fi=0}const _=t._dirtyType!==ot||function(t,e){const n=e.getEditorState()._selection,r=t._selection;if(null!==r){if(r.dirty||!r.is(n))return!0}else if(null!==n)return!0;return!1}(u,t);_?u._flushSync?(u._flushSync=!1,Vi(t)):a&&Yt((()=>{Vi(t)})):(u._flushSync=!1,a&&(r.clear(),t._deferred=[],t._pendingEditorState=null))}function Qi(t,e,n){t._updating?t._updates.push([e,n]):qi(t,e,n)}class Xi extends vr{constructor(t){super(t)}decorate(t,e){H(47)}isIsolated(){return!1}isInline(){return!0}isKeyboardSelectable(){return!0}}function Yi(t){return t instanceof Xi}class Zi extends vr{constructor(t){super(t),this.__first=null,this.__last=null,this.__size=0,this.__format=0,this.__indent=0,this.__dir=null}getFormat(){return this.getLatest().__format}getFormatType(){const t=this.getFormat();return Ft[t]||\"\"}getIndent(){return this.getLatest().__indent}getChildren(){const t=[];let e=this.getFirstChild();for(;null!==e;)t.push(e),e=e.getNextSibling();return t}getChildrenKeys(){const t=[];let e=this.getFirstChild();for(;null!==e;)t.push(e.__key),e=e.getNextSibling();return t}getChildrenSize(){return this.getLatest().__size}isEmpty(){return 0===this.getChildrenSize()}isDirty(){const t=Wi()._dirtyElements;return null!==t&&t.has(this.__key)}isLastChild(){const t=this.getLatest(),e=this.getParentOrThrow().getLastChild();return null!==e&&e.is(t)}getAllTextNodes(){const t=[];let e=this.getFirstChild();for(;null!==e;){if(Ur(e)&&t.push(e),Gi(e)){const n=e.getAllTextNodes();t.push(...n)}e=e.getNextSibling()}return t}getFirstDescendant(){let t=this.getFirstChild();for(;Gi(t);){const e=t.getFirstChild();if(null===e)break;t=e}return t}getLastDescendant(){let t=this.getLastChild();for(;Gi(t);){const e=t.getLastChild();if(null===e)break;t=e}return t}getDescendantByIndex(t){const e=this.getChildren(),n=e.length;if(t>=n){const t=e[n-1];return Gi(t)&&t.getLastDescendant()||t||null}const r=e[t];return Gi(r)&&r.getFirstDescendant()||r||null}getFirstChild(){const t=this.getLatest().__first;return null===t?null:fe(t)}getFirstChildOrThrow(){const t=this.getFirstChild();return null===t&&H(45,this.__key),t}getLastChild(){const t=this.getLatest().__last;return null===t?null:fe(t)}getLastChildOrThrow(){const t=this.getLastChild();return null===t&&H(96,this.__key),t}getChildAtIndex(t){const e=this.getChildrenSize();let n,r;if(t<e/2){for(n=this.getFirstChild(),r=0;null!==n&&r<=t;){if(r===t)return n;n=n.getNextSibling(),r++}return null}for(n=this.getLastChild(),r=e-1;null!==n&&r>=t;){if(r===t)return n;n=n.getPreviousSibling(),r--}return null}getTextContent(){let t=\"\";const e=this.getChildren(),n=e.length;for(let r=0;r<n;r++){const i=e[r];t+=i.getTextContent(),Gi(i)&&r!==n-1&&!i.isInline()&&(t+=St)}return t}getTextContentSize(){let t=0;const e=this.getChildren(),n=e.length;for(let r=0;r<n;r++){const i=e[r];t+=i.getTextContentSize(),Gi(i)&&r!==n-1&&!i.isInline()&&(t+=St.length)}return t}getDirection(){return this.getLatest().__dir}hasFormat(t){if(\"\"!==t){const e=Dt[t];return!!(this.getFormat()&e)}return!1}select(t,e){Li();const n=pi();let r=t,i=e;const s=this.getChildrenSize();if(!this.canBeEmpty())if(0===t&&0===e){const t=this.getFirstChild();if(Ur(t)||Gi(t))return t.select(0,0)}else if(!(void 0!==t&&t!==s||void 0!==e&&e!==s)){const t=this.getLastChild();if(Ur(t)||Gi(t))return t.select()}void 0===r&&(r=s),void 0===i&&(i=s);const o=this.__key;return ti(n)?(n.anchor.set(o,r,\"element\"),n.focus.set(o,i,\"element\"),n.dirty=!0,n):fi(o,r,o,i,\"element\",\"element\")}selectStart(){const t=this.getFirstDescendant();return t?t.selectStart():this.select()}selectEnd(){const t=this.getLastDescendant();return t?t.selectEnd():this.select()}clear(){const t=this.getWritable();return this.getChildren().forEach((t=>t.remove())),t}append(...t){return this.splice(this.getChildrenSize(),0,t)}setDirection(t){const e=this.getWritable();return e.__dir=t,e}setFormat(t){return this.getWritable().__format=\"\"!==t?Dt[t]:0,this}setIndent(t){return this.getWritable().__indent=t,this}splice(t,e,n){const r=n.length,i=this.getChildrenSize(),s=this.getWritable(),o=s.__key,l=[],c=[],u=this.getChildAtIndex(t+e);let a=null,f=i-e+r;if(0!==t)if(t===i)a=this.getLastChild();else{const e=this.getChildAtIndex(t);null!==e&&(a=e.getPreviousSibling())}if(e>0){let t=null===a?this.getFirstChild():a.getNextSibling();for(let n=0;n<e;n++){null===t&&H(100);const e=t.getNextSibling(),n=t.__key;le(t.getWritable()),c.push(n),t=e}}let d=a;for(let t=0;t<r;t++){const e=n[t];null!==d&&e.is(d)&&(a=d=d.getPreviousSibling());const r=e.getWritable();r.__parent===o&&f--,le(r);const i=e.__key;if(null===d)s.__first=i,r.__prev=null;else{const t=d.getWritable();t.__next=i,r.__prev=t.__key}e.__key===o&&H(76),r.__parent=o,l.push(i),d=e}if(t+e===i){if(null!==d){d.getWritable().__next=null,s.__last=d.__key}}else if(null!==u){const t=u.getWritable();if(null!==d){const e=d.getWritable();t.__prev=d.__key,e.__next=u.__key}else t.__prev=null}if(s.__size=f,c.length){const t=pi();if(ti(t)){const e=new Set(c),n=new Set(l),{anchor:r,focus:i}=t;ts(r,e,n)&&vi(r,r.getNode(),this,a,u),ts(i,e,n)&&vi(i,i.getNode(),this,a,u),0!==f||this.canBeEmpty()||Ze(this)||this.remove()}}return s}exportJSON(){return{children:[],direction:this.getDirection(),format:this.getFormatType(),indent:this.getIndent(),type:\"element\",version:1}}insertNewAfter(t,e){return null}canIndent(){return!0}collapseAtStart(t){return!1}excludeFromCopy(t){return!1}canReplaceWith(t){return!0}canInsertAfter(t){return!0}canBeEmpty(){return!0}canInsertTextBefore(){return!0}canInsertTextAfter(){return!0}isInline(){return!1}isShadowRoot(){return!1}canMergeWith(t){return!1}extractWithChild(t,e,n){return!1}}function Gi(t){return t instanceof Zi}function ts(t,e,n){let r=t.getNode();for(;r;){const t=r.__key;if(e.has(t)&&!n.has(t))return!0;r=r.getParent()}return!1}class es extends Zi{static getType(){return\"root\"}static clone(){return new es}constructor(){super(\"root\"),this.__cachedText=null}getTopLevelElementOrThrow(){H(51)}getTextContent(){const t=this.__cachedText;return!Oi()&&Wi()._dirtyType!==ot||null===t?super.getTextContent():t}remove(){H(52)}replace(t){H(53)}insertBefore(t){H(54)}insertAfter(t){H(55)}updateDOM(t,e){return!1}append(...t){for(let e=0;e<t.length;e++){const n=t[e];Gi(n)||Yi(n)||H(56)}return super.append(...t)}static importJSON(t){const e=pe();return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e}exportJSON(){return{children:[],direction:this.getDirection(),format:this.getFormatType(),indent:this.getIndent(),type:\"root\",version:1}}collapseAtStart(){return!0}}function ns(t){return t instanceof es}function rs(){return new ss(new Map([[\"root\",new es]]))}function is(t){const e=t.exportJSON(),n=t.constructor;if(e.type!==n.getType()&&H(130,n.name),Gi(t)){const r=e.children;Array.isArray(r)||H(59,n.name);const i=t.getChildren();for(let t=0;t<i.length;t++){const e=is(i[t]);r.push(e)}}return e}class ss{constructor(t,e){this._nodeMap=t,this._selection=e||null,this._flushSync=!1,this._readOnly=!1}isEmpty(){return 1===this._nodeMap.size&&null===this._selection}read(t){return Ui(this,t)}clone(t){const e=new ss(this._nodeMap,void 0===t?this._selection:t);return e._readOnly=!0,e}toJSON(){return Ui(this,(()=>({root:is(pe())})))}}class os extends Zi{constructor(t){super(t),this.__textFormat=0}static getType(){return\"paragraph\"}getTextFormat(){return this.getLatest().__textFormat}setTextFormat(t){const e=this.getWritable();return e.__textFormat=t,e}hasTextFormat(t){const e=Et[t];return!!(this.getTextFormat()&e)}static clone(t){return new os(t.__key)}createDOM(t){const e=document.createElement(\"p\"),n=Me(t.theme,\"paragraph\");if(void 0!==n){e.classList.add(...n)}return e}updateDOM(t,e,n){return!1}static importDOM(){return{p:t=>({conversion:ls,priority:0})}}exportDOM(t){const{element:e}=super.exportDOM(t);if(e&&un(e)){this.isEmpty()&&e.append(document.createElement(\"br\"));const t=this.getFormatType();e.style.textAlign=t;const n=this.getDirection();n&&(e.dir=n);const r=this.getIndent();r>0&&(e.style.textIndent=20*r+\"px\")}return{element:e}}static importJSON(t){const e=cs();return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e.setTextFormat(t.textFormat),e}exportJSON(){return{...super.exportJSON(),textFormat:this.getTextFormat(),type:\"paragraph\",version:1}}insertNewAfter(t,e){const n=cs();n.setTextFormat(t.format);const r=this.getDirection();return n.setDirection(r),n.setFormat(this.getFormatType()),this.insertAfter(n,e),n}collapseAtStart(){const t=this.getChildren();if(0===t.length||Ur(t[0])&&\"\"===t[0].getTextContent().trim()){if(null!==this.getNextSibling())return this.selectNext(),this.remove(),!0;if(null!==this.getPreviousSibling())return this.selectPrevious(),this.remove(),!0}return!1}}function ls(t){const e=cs();if(t.style){e.setFormat(t.style.textAlign);const n=parseInt(t.style.textIndent,10)/20;n>0&&e.setIndent(n)}return{node:e}}function cs(){return tn(new os)}function us(t){return t instanceof os}const as=0,fs=1,ds=2,hs=3,gs=4;function _s(t,e,n,r){const i=t._keyToDOMMap;i.clear(),t._editorState=rs(),t._pendingEditorState=r,t._compositionKey=null,t._dirtyType=ot,t._cloneNotNeeded.clear(),t._dirtyLeaves=new Set,t._dirtyElements.clear(),t._normalizedNodes=new Set,t._updateTags=new Set,t._updates=[],t._blockCursorElement=null;const s=t._observer;null!==s&&(s.disconnect(),t._observer=null),null!==e&&(e.textContent=\"\"),null!==n&&(n.textContent=\"\",i.set(\"root\",n))}function ps(t){const e=t||{},n=zi(),r=e.theme||{},i=void 0===t?n:e.parentEditor||null,s=e.disableEvents||!1,o=rs(),l=e.namespace||(null!==i?i._config.namespace:ke()),c=e.editorState,u=[es,Ir,Tr,Vr,os,...e.nodes||[]],{onError:a,html:f}=e,d=void 0===e.editable||e.editable;let h;if(void 0===t&&null!==n)h=n._nodes;else{h=new Map;for(let t=0;t<u.length;t++){let e=u[t],n=null,r=null;if(\"function\"!=typeof e){const t=e;e=t.replace,n=t.with,r=t.withKlass||null}const i=e.getType(),s=e.transform(),o=new Set;null!==s&&o.add(s),h.set(i,{exportDOM:f&&f.export?f.export.get(e):void 0,klass:e,replace:n,replaceWithKlass:r,transforms:o})}}const g=new ys(o,i,h,{disableEvents:s,namespace:l,theme:r},a||console.error,function(t,e){const n=new Map,r=new Set,i=t=>{Object.keys(t).forEach((e=>{let r=n.get(e);void 0===r&&(r=[],n.set(e,r)),r.push(t[e])}))};return t.forEach((t=>{const e=t.klass.importDOM;if(null==e||r.has(e))return;r.add(e);const n=e.call(t.klass);null!==n&&i(n)})),e&&i(e),n}(h,f?f.import:void 0),d);return void 0!==c&&(g._pendingEditorState=c,g._dirtyType=ct),g}class ys{constructor(t,e,n,r,i,s,o){this._parentEditor=e,this._rootElement=null,this._editorState=t,this._pendingEditorState=null,this._compositionKey=null,this._deferred=[],this._keyToDOMMap=new Map,this._updates=[],this._updating=!1,this._listeners={decorator:new Set,editable:new Set,mutation:new Map,root:new Set,textcontent:new Set,update:new Set},this._commands=new Map,this._config=r,this._nodes=n,this._decorators={},this._pendingDecorators=null,this._dirtyType=ot,this._cloneNotNeeded=new Set,this._dirtyLeaves=new Set,this._dirtyElements=new Map,this._normalizedNodes=new Set,this._updateTags=new Set,this._observer=null,this._key=ke(),this._onError=i,this._htmlConversions=s,this._editable=o,this._headless=null!==e&&e._headless,this._window=null,this._blockCursorElement=null}isComposing(){return null!=this._compositionKey}registerUpdateListener(t){const e=this._listeners.update;return e.add(t),()=>{e.delete(t)}}registerEditableListener(t){const e=this._listeners.editable;return e.add(t),()=>{e.delete(t)}}registerDecoratorListener(t){const e=this._listeners.decorator;return e.add(t),()=>{e.delete(t)}}registerTextContentListener(t){const e=this._listeners.textcontent;return e.add(t),()=>{e.delete(t)}}registerRootListener(t){const e=this._listeners.root;return t(this._rootElement,null),e.add(t),()=>{t(null,this._rootElement),e.delete(t)}}registerCommand(t,e,n){void 0===n&&H(35);const r=this._commands;r.has(t)||r.set(t,[new Set,new Set,new Set,new Set,new Set]);const i=r.get(t);void 0===i&&H(36,String(t));const s=i[n];return s.add(e),()=>{s.delete(e),i.every((t=>0===t.size))&&r.delete(t)}}registerMutationListener(t,e){void 0===this._nodes.get(t.getType())&&H(37,t.name);const n=this._listeners.mutation;return n.set(e,t),()=>{n.delete(e)}}registerNodeTransformToKlass(t,e){const n=t.getType(),r=this._nodes.get(n);void 0===r&&H(37,t.name);return r.transforms.add(e),r}registerNodeTransform(t,e){const n=this.registerNodeTransformToKlass(t,e),r=[n],i=n.replaceWithKlass;if(null!=i){const t=this.registerNodeTransformToKlass(i,e);r.push(t)}var s,o;return s=this,o=t.getType(),Qi(s,(()=>{const t=Mi();if(t.isEmpty())return;if(\"root\"===o)return void pe().markDirty();const e=t._nodeMap;for(const[,t]of e)t.markDirty()}),null===s._pendingEditorState?{tag:\"history-merge\"}:void 0),()=>{r.forEach((t=>t.transforms.delete(e)))}}hasNode(t){return this._nodes.has(t.getType())}hasNodes(t){return t.every(this.hasNode.bind(this))}dispatchCommand(t,e){return Je(this,t,e)}getDecorators(){return this._decorators}getRootElement(){return this._rootElement}getKey(){return this._key}setRootElement(t){const e=this._rootElement;if(t!==e){const n=Me(this._config.theme,\"root\"),r=this._pendingEditorState||this._editorState;if(this._rootElement=t,_s(this,e,t,r),null!==e&&(this._config.disableEvents||mr(e),null!=n&&e.classList.remove(...n)),null!==t){const e=function(t){const e=t.ownerDocument;return e&&e.defaultView||null}(t),r=t.style;r.userSelect=\"text\",r.whiteSpace=\"pre-wrap\",r.wordBreak=\"break-word\",t.setAttribute(\"data-lexical-editor\",\"true\"),this._window=e,this._dirtyType=ct,Vt(this),this._updateTags.add(\"history-merge\"),Vi(this),this._config.disableEvents||function(t,e){const n=t.ownerDocument,r=nr.get(n);(void 0===r||r<1)&&n.addEventListener(\"selectionchange\",_r),nr.set(n,r||1),t.__lexicalEditor=e;const i=hr(t);for(let n=0;n<Yn.length;n++){const[r,s]=Yn[n],o=\"function\"==typeof s?t=>{yr(t)||(pr(t),(e.isEditable()||\"click\"===r)&&s(t,e))}:t=>{if(!yr(t)&&(pr(t),e.isEditable()))switch(r){case\"cut\":return Je(e,W,t);case\"copy\":return Je(e,M,t);case\"paste\":return Je(e,c,t);case\"dragstart\":return Je(e,O,t);case\"dragover\":return Je(e,L,t);case\"dragend\":return Je(e,A,t);case\"focus\":return Je(e,U,t);case\"blur\":return Je(e,V,t);case\"drop\":return Je(e,F,t)}};t.addEventListener(r,o),i.push((()=>{t.removeEventListener(r,o)}))}}(t,this),null!=n&&t.classList.add(...n)}else this._editorState=r,this._pendingEditorState=null,this._window=null;$i(\"root\",this,!1,t,e)}}getElementByKey(t){return this._keyToDOMMap.get(t)||null}getEditorState(){return this._editorState}setEditorState(t,e){t.isEmpty()&&H(38),Ut(this);const n=this._pendingEditorState,r=this._updateTags,i=void 0!==e?e.tag:null;null===n||n.isEmpty()||(null!=i&&r.add(i),Vi(this)),this._pendingEditorState=t,this._dirtyType=ct,this._dirtyElements.set(\"root\",!1),this._compositionKey=null,null!=i&&r.add(i),Vi(this)}parseEditorState(t,e){return function(t,e,n){const r=rs(),i=wi,s=Pi,o=Ei,l=e._dirtyElements,c=e._dirtyLeaves,u=e._cloneNotNeeded,a=e._dirtyType;e._dirtyElements=new Map,e._dirtyLeaves=new Set,e._cloneNotNeeded=new Set,e._dirtyType=0,wi=r,Pi=!1,Ei=e;try{const i=e._nodes;Ji(t.root,i),n&&n(),r._readOnly=!0}catch(t){t instanceof Error&&e._onError(t)}finally{e._dirtyElements=l,e._dirtyLeaves=c,e._cloneNotNeeded=u,e._dirtyType=a,wi=i,Pi=s,Ei=o}return r}(\"string\"==typeof t?JSON.parse(t):t,this,e)}update(t,e){Qi(this,t,e)}focus(t,e={}){const n=this._rootElement;null!==n&&(n.setAttribute(\"autocapitalize\",\"off\"),Qi(this,(()=>{const t=pi(),n=pe();null!==t?t.dirty=!0:0!==n.getChildrenSize()&&(\"rootStart\"===e.defaultSelection?n.selectStart():n.selectEnd())}),{onUpdate:()=>{n.removeAttribute(\"autocapitalize\"),t&&t()},tag:\"focus\"}),null===this._pendingEditorState&&n.removeAttribute(\"autocapitalize\"))}blur(){const t=this._rootElement;null!==t&&t.blur();const e=on(this._window);null!==e&&e.removeAllRanges()}isEditable(){return this._editable}setEditable(t){this._editable!==t&&(this._editable=t,$i(\"editable\",this,!0,t))}toJSON(){return{editorState:this._editorState.toJSON()}}}export{je as $addUpdateTag,tn as $applyNodeReplacement,Ge as $copyNode,kr as $createLineBreakNode,hi as $createNodeSelection,cs as $createParagraphNode,qr as $createPoint,di as $createRangeSelection,gi as $createRangeSelectionFromDom,$r as $createTabNode,Jr as $createTextNode,Re as $getAdjacentNode,ii as $getCharacterOffsets,dn as $getEditor,he as $getNearestNodeFromDOMNode,Ye as $getNearestRootOrShadowRoot,fe as $getNodeByKey,yi as $getPreviousSelection,pe as $getRoot,pi as $getSelection,Ci as $getTextContent,qe as $hasAncestor,He as $hasUpdateTag,ki as $insertNodes,ai as $isBlockElementNode,Yi as $isDecoratorNode,Gi as $isElementNode,Xe as $isInlineElementOrDecoratorNode,se as $isLeafNode,Cr as $isLineBreakNode,ni as $isNodeSelection,us as $isParagraphNode,ti as $isRangeSelection,ns as $isRootNode,Ze as $isRootOrShadowRoot,Hr as $isTabNode,Ur as $isTextNode,ze as $nodesOfType,qt as $normalizeSelection__EXPERIMENTAL,Ki as $parseSerializedNode,Ae as $selectAll,ue as $setCompositionKey,me as $setSelection,ln as $splitNode,V as BLUR_COMMAND,K as CAN_REDO_COMMAND,J as CAN_UNDO_COMMAND,B as CLEAR_EDITOR_COMMAND,R as CLEAR_HISTORY_COMMAND,r as CLICK_COMMAND,gs as COMMAND_PRIORITY_CRITICAL,as as COMMAND_PRIORITY_EDITOR,hs as COMMAND_PRIORITY_HIGH,fs as COMMAND_PRIORITY_LOW,ds as COMMAND_PRIORITY_NORMAL,l as CONTROLLED_TEXT_INSERTION_COMMAND,M as COPY_COMMAND,W as CUT_COMMAND,i as DELETE_CHARACTER_COMMAND,f as DELETE_LINE_COMMAND,a as DELETE_WORD_COMMAND,A as DRAGEND_COMMAND,L as DRAGOVER_COMMAND,O as DRAGSTART_COMMAND,F as DROP_COMMAND,Xi as DecoratorNode,Zi as ElementNode,U as FOCUS_COMMAND,I as FORMAT_ELEMENT_COMMAND,d as FORMAT_TEXT_COMMAND,P as INDENT_CONTENT_COMMAND,s as INSERT_LINE_BREAK_COMMAND,o as INSERT_PARAGRAPH_COMMAND,E as INSERT_TAB_COMMAND,T as KEY_ARROW_DOWN_COMMAND,m as KEY_ARROW_LEFT_COMMAND,p as KEY_ARROW_RIGHT_COMMAND,v as KEY_ARROW_UP_COMMAND,C as KEY_BACKSPACE_COMMAND,N as KEY_DELETE_COMMAND,_ as KEY_DOWN_COMMAND,S as KEY_ENTER_COMMAND,b as KEY_ESCAPE_COMMAND,$ as KEY_MODIFIER_COMMAND,k as KEY_SPACE_COMMAND,w as KEY_TAB_COMMAND,Tr as LineBreakNode,y as MOVE_TO_END,x as MOVE_TO_START,D as OUTDENT_CONTENT_COMMAND,c as PASTE_COMMAND,os as ParagraphNode,g as REDO_COMMAND,u as REMOVE_TEXT_COMMAND,es as RootNode,e as SELECTION_CHANGE_COMMAND,n as SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,z as SELECT_ALL_COMMAND,Vr as TabNode,Ir as TextNode,h as UNDO_COMMAND,t as createCommand,ps as createEditor,te as getNearestEditorFromDOMNode,Oi as isCurrentlyReadOnlyMode,cn as isHTMLAnchorElement,un as isHTMLElement,Zt as isSelectionCapturedInDecoratorInput,Gt as isSelectionWithinEditor};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './Lexical.dev.mjs';\nimport * as modProd from './Lexical.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $addUpdateTag = mod.$addUpdateTag;\nexport const $applyNodeReplacement = mod.$applyNodeReplacement;\nexport const $copyNode = mod.$copyNode;\nexport const $createLineBreakNode = mod.$createLineBreakNode;\nexport const $createNodeSelection = mod.$createNodeSelection;\nexport const $createParagraphNode = mod.$createParagraphNode;\nexport const $createPoint = mod.$createPoint;\nexport const $createRangeSelection = mod.$createRangeSelection;\nexport const $createRangeSelectionFromDom = mod.$createRangeSelectionFromDom;\nexport const $createTabNode = mod.$createTabNode;\nexport const $createTextNode = mod.$createTextNode;\nexport const $getAdjacentNode = mod.$getAdjacentNode;\nexport const $getCharacterOffsets = mod.$getCharacterOffsets;\nexport const $getEditor = mod.$getEditor;\nexport const $getNearestNodeFromDOMNode = mod.$getNearestNodeFromDOMNode;\nexport const $getNearestRootOrShadowRoot = mod.$getNearestRootOrShadowRoot;\nexport const $getNodeByKey = mod.$getNodeByKey;\nexport const $getPreviousSelection = mod.$getPreviousSelection;\nexport const $getRoot = mod.$getRoot;\nexport const $getSelection = mod.$getSelection;\nexport const $getTextContent = mod.$getTextContent;\nexport const $hasAncestor = mod.$hasAncestor;\nexport const $hasUpdateTag = mod.$hasUpdateTag;\nexport const $insertNodes = mod.$insertNodes;\nexport const $isBlockElementNode = mod.$isBlockElementNode;\nexport const $isDecoratorNode = mod.$isDecoratorNode;\nexport const $isElementNode = mod.$isElementNode;\nexport const $isInlineElementOrDecoratorNode = mod.$isInlineElementOrDecoratorNode;\nexport const $isLeafNode = mod.$isLeafNode;\nexport const $isLineBreakNode = mod.$isLineBreakNode;\nexport const $isNodeSelection = mod.$isNodeSelection;\nexport const $isParagraphNode = mod.$isParagraphNode;\nexport const $isRangeSelection = mod.$isRangeSelection;\nexport const $isRootNode = mod.$isRootNode;\nexport const $isRootOrShadowRoot = mod.$isRootOrShadowRoot;\nexport const $isTabNode = mod.$isTabNode;\nexport const $isTextNode = mod.$isTextNode;\nexport const $nodesOfType = mod.$nodesOfType;\nexport const $normalizeSelection__EXPERIMENTAL = mod.$normalizeSelection__EXPERIMENTAL;\nexport const $parseSerializedNode = mod.$parseSerializedNode;\nexport const $selectAll = mod.$selectAll;\nexport const $setCompositionKey = mod.$setCompositionKey;\nexport const $setSelection = mod.$setSelection;\nexport const $splitNode = mod.$splitNode;\nexport const BLUR_COMMAND = mod.BLUR_COMMAND;\nexport const CAN_REDO_COMMAND = mod.CAN_REDO_COMMAND;\nexport const CAN_UNDO_COMMAND = mod.CAN_UNDO_COMMAND;\nexport const CLEAR_EDITOR_COMMAND = mod.CLEAR_EDITOR_COMMAND;\nexport const CLEAR_HISTORY_COMMAND = mod.CLEAR_HISTORY_COMMAND;\nexport const CLICK_COMMAND = mod.CLICK_COMMAND;\nexport const COMMAND_PRIORITY_CRITICAL = mod.COMMAND_PRIORITY_CRITICAL;\nexport const COMMAND_PRIORITY_EDITOR = mod.COMMAND_PRIORITY_EDITOR;\nexport const COMMAND_PRIORITY_HIGH = mod.COMMAND_PRIORITY_HIGH;\nexport const COMMAND_PRIORITY_LOW = mod.COMMAND_PRIORITY_LOW;\nexport const COMMAND_PRIORITY_NORMAL = mod.COMMAND_PRIORITY_NORMAL;\nexport const CONTROLLED_TEXT_INSERTION_COMMAND = mod.CONTROLLED_TEXT_INSERTION_COMMAND;\nexport const COPY_COMMAND = mod.COPY_COMMAND;\nexport const CUT_COMMAND = mod.CUT_COMMAND;\nexport const DELETE_CHARACTER_COMMAND = mod.DELETE_CHARACTER_COMMAND;\nexport const DELETE_LINE_COMMAND = mod.DELETE_LINE_COMMAND;\nexport const DELETE_WORD_COMMAND = mod.DELETE_WORD_COMMAND;\nexport const DRAGEND_COMMAND = mod.DRAGEND_COMMAND;\nexport const DRAGOVER_COMMAND = mod.DRAGOVER_COMMAND;\nexport const DRAGSTART_COMMAND = mod.DRAGSTART_COMMAND;\nexport const DROP_COMMAND = mod.DROP_COMMAND;\nexport const DecoratorNode = mod.DecoratorNode;\nexport const ElementNode = mod.ElementNode;\nexport const FOCUS_COMMAND = mod.FOCUS_COMMAND;\nexport const FORMAT_ELEMENT_COMMAND = mod.FORMAT_ELEMENT_COMMAND;\nexport const FORMAT_TEXT_COMMAND = mod.FORMAT_TEXT_COMMAND;\nexport const INDENT_CONTENT_COMMAND = mod.INDENT_CONTENT_COMMAND;\nexport const INSERT_LINE_BREAK_COMMAND = mod.INSERT_LINE_BREAK_COMMAND;\nexport const INSERT_PARAGRAPH_COMMAND = mod.INSERT_PARAGRAPH_COMMAND;\nexport const INSERT_TAB_COMMAND = mod.INSERT_TAB_COMMAND;\nexport const KEY_ARROW_DOWN_COMMAND = mod.KEY_ARROW_DOWN_COMMAND;\nexport const KEY_ARROW_LEFT_COMMAND = mod.KEY_ARROW_LEFT_COMMAND;\nexport const KEY_ARROW_RIGHT_COMMAND = mod.KEY_ARROW_RIGHT_COMMAND;\nexport const KEY_ARROW_UP_COMMAND = mod.KEY_ARROW_UP_COMMAND;\nexport const KEY_BACKSPACE_COMMAND = mod.KEY_BACKSPACE_COMMAND;\nexport const KEY_DELETE_COMMAND = mod.KEY_DELETE_COMMAND;\nexport const KEY_DOWN_COMMAND = mod.KEY_DOWN_COMMAND;\nexport const KEY_ENTER_COMMAND = mod.KEY_ENTER_COMMAND;\nexport const KEY_ESCAPE_COMMAND = mod.KEY_ESCAPE_COMMAND;\nexport const KEY_MODIFIER_COMMAND = mod.KEY_MODIFIER_COMMAND;\nexport const KEY_SPACE_COMMAND = mod.KEY_SPACE_COMMAND;\nexport const KEY_TAB_COMMAND = mod.KEY_TAB_COMMAND;\nexport const LineBreakNode = mod.LineBreakNode;\nexport const MOVE_TO_END = mod.MOVE_TO_END;\nexport const MOVE_TO_START = mod.MOVE_TO_START;\nexport const OUTDENT_CONTENT_COMMAND = mod.OUTDENT_CONTENT_COMMAND;\nexport const PASTE_COMMAND = mod.PASTE_COMMAND;\nexport const ParagraphNode = mod.ParagraphNode;\nexport const REDO_COMMAND = mod.REDO_COMMAND;\nexport const REMOVE_TEXT_COMMAND = mod.REMOVE_TEXT_COMMAND;\nexport const RootNode = mod.RootNode;\nexport const SELECTION_CHANGE_COMMAND = mod.SELECTION_CHANGE_COMMAND;\nexport const SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = mod.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND;\nexport const SELECT_ALL_COMMAND = mod.SELECT_ALL_COMMAND;\nexport const TabNode = mod.TabNode;\nexport const TextNode = mod.TextNode;\nexport const UNDO_COMMAND = mod.UNDO_COMMAND;\nexport const createCommand = mod.createCommand;\nexport const createEditor = mod.createEditor;\nexport const getNearestEditorFromDOMNode = mod.getNearestEditorFromDOMNode;\nexport const isCurrentlyReadOnlyMode = mod.isCurrentlyReadOnlyMode;\nexport const isHTMLAnchorElement = mod.isHTMLAnchorElement;\nexport const isHTMLElement = mod.isHTMLElement;\nexport const isSelectionCapturedInDecoratorInput = mod.isSelectionCapturedInDecoratorInput;\nexport const isSelectionWithinEditor = mod.isSelectionWithinEditor;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $isTextNode, $isElementNode, $isParagraphNode, $getCharacterOffsets, $isRootNode, $getNodeByKey, $getPreviousSelection, $createTextNode, $isRangeSelection, $getRoot, $isRootOrShadowRoot, $hasAncestor, $isLeafNode, $setSelection, $getAdjacentNode, $isDecoratorNode, $isLineBreakNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ($isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ($isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\nfunction $updateParagraphNodeProperties(target, source) {\n  target.__textFormat = source.__textFormat;\n  return target;\n}\n\n/**\n * Returns a copy of a node, but generates a new key for the copy.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(node) {\n  const constructor = node.constructor;\n  // @ts-expect-error\n  const clone = constructor.clone(node);\n  clone.__parent = node.__parent;\n  clone.__next = node.__next;\n  clone.__prev = node.__prev;\n  if ($isElementNode(node) && $isElementNode(clone)) {\n    return $updateElementNodeProperties(clone, node);\n  }\n  if ($isTextNode(node) && $isTextNode(clone)) {\n    return $updateTextNodeProperties(clone, node);\n  }\n  if ($isParagraphNode(node) && $isParagraphNode(clone)) {\n    return $updateParagraphNodeProperties(clone, node);\n  }\n  return clone;\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!$isElementNode(node)) {\n    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ($isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ($isElementNode(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && $isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = $getNodeByKey(key);\n        if ($isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = $getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = $createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ($isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = $createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value instanceof Function) {\n      styles[key] = value(prevStyles[key]);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. { CSSProperty: value }. Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return;\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed() && $isRangeSelection(selection)) {\n    $patchStyle(selection, patch);\n    return;\n  }\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if ($isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (selectedNodes.length === 1) {\n    if ($isTextNode(firstNode) && firstNode.canHaveFormat()) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if ($isTextNode(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n        anchor.set(firstNode.getKey(), startOffset, 'text');\n      }\n      $patchStyle(firstNode, patch);\n    }\n    if ($isTextNode(lastNode) && lastNode.canHaveFormat()) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected, split it\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0 || endType === 'element') {\n        $patchStyle(lastNode, patch);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if ($isTextNode(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\nfunction $setBlocksType(selection, createElement) {\n  if (selection === null) {\n    return;\n  }\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  if (anchor !== null && anchor.key === 'root') {\n    const element = createElement();\n    const root = $getRoot();\n    const firstChild = root.getFirstChild();\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n    return;\n  }\n  const nodes = selection.getNodes();\n  const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\n    nodes.push(firstSelectedBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!INTERNAL_$isBlock(node)) {\n      continue;\n    }\n    if (!$isElementNode(node)) {\n      throw Error(`Expected block node to be an ElementNode`);\n    }\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ($isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ($isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && $isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ($isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!$isElementNode(node)) {\n        throw Error(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ($isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ($isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = $getPreviousSelection();\n  if ($isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    $setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = $getAdjacentNode(selection.focus, isBackward);\n  return $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if ($isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if ($isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if (selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ($isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node)) {\n    return false;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\nexport { $addNodeStyle, $cloneWithProperties, $getSelectionStyleValueForProperty, $isAtNodeEnd, $isParentElementRTL, $moveCaretSelection, $moveCharacter, $patchStyleText, $selectAll, $setBlocksType, $shouldOverrideDefaultCharacterSelection, $sliceSelectedTextNodeContent, $wrapNodes, createDOMRange, createRectsFromDOMRange, getStyleObjectFromCSS, trimTextContentFromAnchor };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{$isTextNode as e,$isElementNode as t,$isParagraphNode as n,$getCharacterOffsets as o,$isRootNode as l,$getNodeByKey as r,$getPreviousSelection as s,$createTextNode as i,$isRangeSelection as c,$getRoot as f,$isRootOrShadowRoot as u,$hasAncestor as g,$isLeafNode as a,$setSelection as d,$getAdjacentNode as p,$isDecoratorNode as h,$isLineBreakNode as _}from\"lexical\";const m=new Map;function y(e){let t=e;for(;null!=t;){if(t.nodeType===Node.TEXT_NODE)return t;t=t.firstChild}return null}function T(e){const t=e.parentNode;if(null==t)throw new Error(\"Should never happen\");return[t,Array.from(t.childNodes).indexOf(e)]}function x(t,n,o,l,r){const s=n.getKey(),i=l.getKey(),c=document.createRange();let f=t.getElementByKey(s),u=t.getElementByKey(i),g=o,a=r;if(e(n)&&(f=y(f)),e(l)&&(u=y(u)),void 0===n||void 0===l||null===f||null===u)return null;\"BR\"===f.nodeName&&([f,g]=T(f)),\"BR\"===u.nodeName&&([u,a]=T(u));const d=f.firstChild;f===u&&null!=d&&\"BR\"===d.nodeName&&0===g&&0===a&&(a=1);try{c.setStart(f,g),c.setEnd(u,a)}catch(e){return null}return!c.collapsed||g===a&&s===i||(c.setStart(u,a),c.setEnd(f,g)),c}function S(e,t){const n=e.getRootElement();if(null===n)return[];const o=n.getBoundingClientRect(),l=getComputedStyle(n),r=parseFloat(l.paddingLeft)+parseFloat(l.paddingRight),s=Array.from(t.getClientRects());let i,c=s.length;s.sort(((e,t)=>{const n=e.top-t.top;return Math.abs(n)<=3?e.left-t.left:n}));for(let e=0;e<c;e++){const t=s[e],n=i&&i.top<=t.top&&i.top+i.height>t.top&&i.left+i.width>t.left,l=t.width+r===o.width;n||l?(s.splice(e--,1),c--):i=t}return s}function N(e){const t={},n=e.split(\";\");for(const e of n)if(\"\"!==e){const[n,o]=e.split(/:([^]+)/);n&&o&&(t[n.trim()]=o.trim())}return t}function E(e){let t=m.get(e);return void 0===t&&(t=N(e),m.set(e,t)),t}function v(o){const l=o.constructor.clone(o);return l.__parent=o.__parent,l.__next=o.__next,l.__prev=o.__prev,t(o)&&t(l)?(s=o,(r=l).__first=s.__first,r.__last=s.__last,r.__size=s.__size,r.__format=s.__format,r.__indent=s.__indent,r.__dir=s.__dir,r):e(o)&&e(l)?function(e,t){return e.__format=t.__format,e.__style=t.__style,e.__mode=t.__mode,e.__detail=t.__detail,e}(l,o):n(o)&&n(l)?function(e,t){return e.__textFormat=t.__textFormat,e}(l,o):l;var r,s}function C(e,t){const n=e.getStartEndPoints();if(t.isSelected(e)&&!t.isSegmented()&&!t.isToken()&&null!==n){const[l,r]=n,s=e.isBackward(),i=l.getNode(),c=r.getNode(),f=t.is(i),u=t.is(c);if(f||u){const[n,l]=o(e),r=i.is(c),f=t.is(s?c:i),u=t.is(s?i:c);let g,a=0;if(r)a=n>l?l:n,g=n>l?n:l;else if(f){a=s?l:n,g=void 0}else if(u){a=0,g=s?n:l}return t.__text=t.__text.slice(a,g),t}}return t}function w(e){if(\"text\"===e.type)return e.offset===e.getNode().getTextContentSize();const n=e.getNode();if(!t(n))throw Error(\"isAtNodeEnd: node must be a TextNode or ElementNode\");return e.offset===n.getChildrenSize()}function P(n,o,f){let u=o.getNode(),g=f;if(t(u)){const e=u.getDescendantByIndex(o.offset);null!==e&&(u=e)}for(;g>0&&null!==u;){if(t(u)){const e=u.getLastDescendant();null!==e&&(u=e)}let f=u.getPreviousSibling(),a=0;if(null===f){let e=u.getParentOrThrow(),t=e.getPreviousSibling();for(;null===t;){if(e=e.getParent(),null===e){f=null;break}t=e.getPreviousSibling()}null!==e&&(a=e.isInline()?0:2,f=t)}let d=u.getTextContent();\"\"===d&&t(u)&&!u.isInline()&&(d=\"\\n\\n\");const p=d.length;if(!e(u)||g>=p){const e=u.getParent();u.remove(),null==e||0!==e.getChildrenSize()||l(e)||e.remove(),g-=p+a,u=f}else{const t=u.getKey(),l=n.getEditorState().read((()=>{const n=r(t);return e(n)&&n.isSimpleText()?n.getTextContent():null})),f=p-g,a=d.slice(0,f);if(null!==l&&l!==d){const e=s();let t=u;if(u.isSimpleText())u.setTextContent(l);else{const e=i(l);u.replace(e),t=e}if(c(e)&&e.isCollapsed()){const n=e.anchor.offset;t.select(n,n)}}else if(u.isSimpleText()){const e=o.key===t;let n=o.offset;n<g&&(n=p);const l=e?n-g:0,r=e?n:f;if(e&&0===l){const[e]=u.splitText(l,r);e.remove()}else{const[,e]=u.splitText(l,r);e.remove()}}else{const e=i(a);u.replace(e)}g=0}}}function F(e){const t=e.getStyle(),n=N(t);m.set(t,n)}function I(e,t){const n=E(\"getStyle\"in e?e.getStyle():e.style),o=Object.entries(t).reduce(((e,[t,o])=>(o instanceof Function?e[t]=o(n[t]):null===o?delete e[t]:e[t]=o,e)),{...n}||{}),l=function(e){let t=\"\";for(const n in e)n&&(t+=`${n}: ${e[n]};`);return t}(o);e.setStyle(l),m.set(l,o)}function K(t,n){const o=t.getNodes(),l=o.length,r=t.getStartEndPoints();if(null===r)return;const[s,i]=r,f=l-1;let u=o[0],g=o[f];if(t.isCollapsed()&&c(t))return void I(t,n);const a=u.getTextContent().length,d=i.offset;let p=s.offset;const h=s.isBefore(i);let _=h?p:d,m=h?d:p;const y=h?s.type:i.type,T=h?i.type:s.type,x=h?i.key:s.key;if(e(u)&&_===a){const t=u.getNextSibling();e(t)&&(p=0,_=0,u=t)}if(1===o.length){if(e(u)&&u.canHaveFormat()){if(_=\"element\"===y?0:p>d?d:p,m=\"element\"===T?a:p>d?p:d,_===m)return;if(0===_&&m===a)I(u,n),u.select(_,m);else{const e=u.splitText(_,m),t=0===_?e[0]:e[1];I(t,n),t.select(0,m-_)}}}else{if(e(u)&&_<u.getTextContentSize()&&u.canHaveFormat()&&(0!==_&&(u=u.splitText(_)[1],_=0,s.set(u.getKey(),_,\"text\")),I(u,n)),e(g)&&g.canHaveFormat()){const e=g.getTextContent().length;g.__key!==x&&0!==m&&(m=e),m!==e&&([g]=g.splitText(m)),0===m&&\"element\"!==T||I(g,n)}for(let t=1;t<f;t++){const l=o[t],r=l.getKey();e(l)&&l.canHaveFormat()&&r!==u.getKey()&&r!==g.getKey()&&!l.isToken()&&I(l,n)}}}function b(e,n){if(null===e)return;const o=e.getStartEndPoints(),l=o?o[0]:null;if(null!==l&&\"root\"===l.key){const e=n(),t=f(),o=t.getFirstChild();return void(o?o.replace(e,!0):t.append(e))}const r=e.getNodes(),s=null!==l&&function(e,t){let n=e;for(;null!==n&&null!==n.getParent()&&!t(n);)n=n.getParentOrThrow();return t(n)?n:null}(l.getNode(),j);s&&-1===r.indexOf(s)&&r.push(s);for(let e=0;e<r.length;e++){const o=r[e];if(!j(o))continue;if(!t(o))throw Error(\"Expected block node to be an ElementNode\");const l=n();l.setFormat(o.getFormatType()),l.setIndent(o.getIndent()),o.replace(l,!0)}}function O(e){return e.getNode().isAttached()}function k(e){let t=e;for(;null!==t&&!u(t);){const e=t.getLatest(),n=t.getParent();0===e.getChildrenSize()&&t.remove(!0),t=n}}function B(e,t,n=null){const o=e.getStartEndPoints(),l=o?o[0]:null,r=e.getNodes(),s=r.length;if(null!==l&&(0===s||1===s&&\"element\"===l.type&&0===l.getNode().getChildrenSize())){const e=\"text\"===l.type?l.getNode().getParentOrThrow():l.getNode(),o=e.getChildren();let r=t();return r.setFormat(e.getFormatType()),r.setIndent(e.getIndent()),o.forEach((e=>r.append(e))),n&&(r=n.append(r)),void e.replace(r)}let i=null,c=[];for(let o=0;o<s;o++){const l=r[o];u(l)?(z(e,c,c.length,t,n),c=[],i=l):null===i||null!==i&&g(l,i)?c.push(l):(z(e,c,c.length,t,n),c=[l])}z(e,c,c.length,t,n)}function z(e,n,o,l,r=null){if(0===n.length)return;const i=n[0],f=new Map,g=[];let p=t(i)?i:i.getParentOrThrow();p.isInline()&&(p=p.getParentOrThrow());let h=!1;for(;null!==p;){const e=p.getPreviousSibling();if(null!==e){p=e,h=!0;break}if(p=p.getParentOrThrow(),u(p))break}const _=new Set;for(let e=0;e<o;e++){const o=n[e];t(o)&&0===o.getChildrenSize()&&_.add(o.getKey())}const m=new Set;for(let e=0;e<o;e++){const o=n[e];let r=o.getParent();if(null!==r&&r.isInline()&&(r=r.getParent()),null!==r&&a(o)&&!m.has(o.getKey())){const e=r.getKey();if(void 0===f.get(e)){const n=l();n.setFormat(r.getFormatType()),n.setIndent(r.getIndent()),g.push(n),f.set(e,n),r.getChildren().forEach((e=>{n.append(e),m.add(e.getKey()),t(e)&&e.getChildrenKeys().forEach((e=>m.add(e)))})),k(r)}}else if(_.has(o.getKey())){if(!t(o))throw Error(\"Expected node in emptyElements to be an ElementNode\");const e=l();e.setFormat(o.getFormatType()),e.setIndent(o.getIndent()),g.push(e),o.remove(!0)}}if(null!==r)for(let e=0;e<g.length;e++){const t=g[e];r.append(t)}let y=null;if(u(p))if(h)if(null!==r)p.insertAfter(r);else for(let e=g.length-1;e>=0;e--){const t=g[e];p.insertAfter(t)}else{const e=p.getFirstChild();if(t(e)&&(p=e),null===e)if(r)p.append(r);else for(let e=0;e<g.length;e++){const t=g[e];p.append(t),y=t}else if(null!==r)e.insertBefore(r);else for(let t=0;t<g.length;t++){const n=g[t];e.insertBefore(n),y=n}}else if(r)p.insertAfter(r);else for(let e=g.length-1;e>=0;e--){const t=g[e];p.insertAfter(t),y=t}const T=s();c(T)&&O(T.anchor)&&O(T.focus)?d(T.clone()):null!==y?y.selectEnd():e.dirty=!0}function A(e,n){const o=p(e.focus,n);return h(o)&&!o.isIsolated()||t(o)&&!o.isInline()&&!o.canBeEmpty()}function R(e,t,n,o){e.modify(t?\"extend\":\"move\",n,o)}function D(e){const t=e.anchor.getNode();return\"rtl\"===(l(t)?t:t.getParentOrThrow()).getDirection()}function L(e,t,n){const o=D(e);R(e,t,n?!o:o,\"character\")}function H(n){const o=n.anchor,l=n.focus,r=o.getNode().getTopLevelElementOrThrow().getParentOrThrow();let s=r.getFirstDescendant(),i=r.getLastDescendant(),c=\"element\",f=\"element\",u=0;e(s)?c=\"text\":t(s)||null===s||(s=s.getParentOrThrow()),e(i)?(f=\"text\",u=i.getTextContentSize()):t(i)||null===i||(i=i.getParentOrThrow()),s&&i&&(o.set(s.getKey(),0,c),l.set(i.getKey(),u,f))}function M(e,t,n){const o=E(e.getStyle());return null!==o&&o[t]||n}function $(t,n,o=\"\"){let l=null;const r=t.getNodes(),s=t.anchor,i=t.focus,c=t.isBackward(),f=c?i.offset:s.offset,u=c?i.getNode():s.getNode();if(t.isCollapsed()&&\"\"!==t.style){const e=E(t.style);if(null!==e&&n in e)return e[n]}for(let t=0;t<r.length;t++){const s=r[t];if((0===t||0!==f||!s.is(u))&&e(s)){const e=M(s,n,o);if(null===l)l=e;else if(l!==e){l=\"\";break}}}return null===l?o:l}function j(n){if(h(n))return!1;if(!t(n)||u(n))return!1;const o=n.getFirstChild(),l=null===o||_(o)||e(o)||o.isInline();return!n.isInline()&&!1!==n.canBeEmpty()&&l}export{F as $addNodeStyle,v as $cloneWithProperties,$ as $getSelectionStyleValueForProperty,w as $isAtNodeEnd,D as $isParentElementRTL,R as $moveCaretSelection,L as $moveCharacter,K as $patchStyleText,H as $selectAll,b as $setBlocksType,A as $shouldOverrideDefaultCharacterSelection,C as $sliceSelectedTextNodeContent,B as $wrapNodes,x as createDOMRange,S as createRectsFromDOMRange,E as getStyleObjectFromCSS,P as trimTextContentFromAnchor};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalSelection.dev.mjs';\nimport * as modProd from './LexicalSelection.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $addNodeStyle = mod.$addNodeStyle;\nexport const $cloneWithProperties = mod.$cloneWithProperties;\nexport const $getSelectionStyleValueForProperty = mod.$getSelectionStyleValueForProperty;\nexport const $isAtNodeEnd = mod.$isAtNodeEnd;\nexport const $isParentElementRTL = mod.$isParentElementRTL;\nexport const $moveCaretSelection = mod.$moveCaretSelection;\nexport const $moveCharacter = mod.$moveCharacter;\nexport const $patchStyleText = mod.$patchStyleText;\nexport const $selectAll = mod.$selectAll;\nexport const $setBlocksType = mod.$setBlocksType;\nexport const $shouldOverrideDefaultCharacterSelection = mod.$shouldOverrideDefaultCharacterSelection;\nexport const $sliceSelectedTextNodeContent = mod.$sliceSelectedTextNodeContent;\nexport const $wrapNodes = mod.$wrapNodes;\nexport const createDOMRange = mod.createDOMRange;\nexport const createRectsFromDOMRange = mod.createRectsFromDOMRange;\nexport const getStyleObjectFromCSS = mod.getStyleObjectFromCSS;\nexport const trimTextContentFromAnchor = mod.trimTextContentFromAnchor;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { createRectsFromDOMRange, $cloneWithProperties } from '@lexical/selection';\nimport { $getSelection, $isRangeSelection, TextNode, $getRoot, $isElementNode, $isTextNode, $setSelection, $getPreviousSelection, $isRootOrShadowRoot, $splitNode, $createParagraphNode } from 'lexical';\nexport { $splitNode, isHTMLAnchorElement, isHTMLElement } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || $getRoot()).getLatest();\n  const end = endingNode || ($isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if ($isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = $cloneWithProperties(node);\n    if ($isTextNode(clone)) {\n      if (!$isTextNode(node)) {\n        throw Error(`Expected node be a TextNode`);\n      }\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  if ($isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ($isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ($isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = $getRoot();\n      root.append(node);\n    }\n    const paragraphNode = $createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\nexport { $dfs, $filter, $findMatchingParent, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $insertFirst, $insertNodeToNearestRoot, $restoreEditorState, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{createRectsFromDOMRange as e,$cloneWithProperties as t}from\"@lexical/selection\";import{$getSelection as n,$isRangeSelection as o,TextNode as r,$getRoot as l,$isElementNode as i,$isTextNode as s,$setSelection as c,$getPreviousSelection as u,$isRootOrShadowRoot as f,$splitNode as a,$createParagraphNode as d}from\"lexical\";export{$splitNode,isHTMLAnchorElement,isHTMLElement}from\"lexical\";var g=function(e){const t=new URLSearchParams;t.append(\"code\",e);for(let e=1;e<arguments.length;e++)t.append(\"v\",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)};const p=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,h=p&&\"documentMode\"in document?document.documentMode:null,m=p&&/Mac|iPod|iPhone|iPad/.test(navigator.platform),E=p&&/^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent),v=!(!p||!(\"InputEvent\"in window)||h)&&\"getTargetRanges\"in new window.InputEvent(\"input\"),w=p&&/Version\\/[\\d.]+.*Safari/.test(navigator.userAgent),y=p&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream,x=p&&/Android/.test(navigator.userAgent),N=p&&/^(?=.*Chrome).*/i.test(navigator.userAgent),P=p&&x&&N,S=p&&/AppleWebKit\\/[\\d.]+/.test(navigator.userAgent)&&!N;function A(...e){const t=[];for(const n of e)if(n&&\"string\"==typeof n)for(const[e]of n.matchAll(/\\S+/g))t.push(e);return t}function b(...e){return()=>{e.forEach((e=>e()))}}function L(e){return`${e}px`}const T={attributes:!0,characterData:!0,childList:!0,subtree:!0};function M(t,n,o){let r=null,l=null,i=null,s=[];const c=document.createElement(\"div\");function u(){if(null===r)throw Error(\"Unexpected null rootDOMNode\");if(null===l)throw Error(\"Unexpected null parentDOMNode\");const{left:i,top:u}=r.getBoundingClientRect(),f=l,a=e(t,n);c.isConnected||f.append(c);let d=!1;for(let e=0;e<a.length;e++){const t=a[e],n=s[e]||document.createElement(\"div\"),o=n.style;\"absolute\"!==o.position&&(o.position=\"absolute\",d=!0);const r=L(t.left-i);o.left!==r&&(o.left=r,d=!0);const l=L(t.top-u);o.top!==l&&(n.style.top=l,d=!0);const f=L(t.width);o.width!==f&&(n.style.width=f,d=!0);const g=L(t.height);o.height!==g&&(n.style.height=g,d=!0),n.parentNode!==c&&(c.append(n),d=!0),s[e]=n}for(;s.length>a.length;)s.pop();d&&o(s)}function f(){l=null,r=null,null!==i&&i.disconnect(),i=null,c.remove();for(const e of s)e.remove();s=[]}const a=t.registerRootListener((function e(){const n=t.getRootElement();if(null===n)return f();const o=n.parentElement;if(!(o instanceof HTMLElement))return f();f(),r=n,l=o,i=new MutationObserver((n=>{const o=t.getRootElement(),i=o&&o.parentElement;if(o!==r||i!==l)return e();for(const e of n)if(!c.contains(e.target))return u()})),i.observe(o,T),u()}));return()=>{a(),f()}}function _(e,t){let l=null,i=null,s=null,c=null,u=()=>{};function f(f){f.read((()=>{const f=n();if(!o(f))return l=null,i=null,s=null,c=null,u(),void(u=()=>{});const{anchor:a,focus:d}=f,g=a.getNode(),p=g.getKey(),h=a.offset,m=d.getNode(),E=m.getKey(),v=d.offset,w=e.getElementByKey(p),y=e.getElementByKey(E),x=null===l||null===w||h!==i||p!==l.getKey()||g!==l&&(!(l instanceof r)||g.updateDOM(l,w,e._config)),N=null===s||null===y||v!==c||E!==s.getKey()||m!==s&&(!(s instanceof r)||m.updateDOM(s,y,e._config));if(x||N){const n=e.getElementByKey(a.getNode().getKey()),o=e.getElementByKey(d.getNode().getKey());if(null!==n&&null!==o&&\"SPAN\"===n.tagName&&\"SPAN\"===o.tagName){const r=document.createRange();let l,i,s,c;d.isBefore(a)?(l=o,i=d.offset,s=n,c=a.offset):(l=n,i=a.offset,s=o,c=d.offset);const f=l.firstChild;if(null===f)throw Error(\"Expected text node to be first child of span\");const g=s.firstChild;if(null===g)throw Error(\"Expected text node to be first child of span\");r.setStart(f,i),r.setEnd(g,c),u(),u=M(e,r,(e=>{for(const t of e){const e=t.style;\"Highlight\"!==e.background&&(e.background=\"Highlight\"),\"HighlightText\"!==e.color&&(e.color=\"HighlightText\"),\"-1\"!==e.zIndex&&(e.zIndex=\"-1\"),\"none\"!==e.pointerEvents&&(e.pointerEvents=\"none\"),e.marginTop!==L(-1.5)&&(e.marginTop=L(-1.5)),e.paddingTop!==L(4)&&(e.paddingTop=L(4)),e.paddingBottom!==L(0)&&(e.paddingBottom=L(0))}void 0!==t&&t(e)}))}}l=g,i=h,s=m,c=v}))}return f(e.getEditorState()),b(e.registerUpdateListener((({editorState:e})=>f(e))),u,(()=>{u()}))}function B(e,...t){const n=A(...t);n.length>0&&e.classList.add(...n)}function C(e,...t){const n=A(...t);n.length>0&&e.classList.remove(...n)}function K(e,t){for(const n of t)if(e.type.startsWith(n))return!0;return!1}function O(e,t){const n=e[Symbol.iterator]();return new Promise(((e,o)=>{const r=[],l=()=>{const{done:i,value:s}=n.next();if(i)return e(r);const c=new FileReader;c.addEventListener(\"error\",o),c.addEventListener(\"load\",(()=>{const e=c.result;\"string\"==typeof e&&r.push({file:s,result:e}),l()})),K(s,t)?c.readAsDataURL(s):l()};l()}))}function R(e,t){const n=[],o=(e||l()).getLatest(),r=t||(i(o)?o.getLastDescendant():o);let s=o,c=function(e){let t=e,n=0;for(;null!==(t=t.getParent());)n++;return n}(s);for(;null!==s&&!s.is(r);)if(n.push({depth:c,node:s}),i(s)&&s.getChildrenSize()>0)s=s.getFirstChild(),c++;else{let e=null;for(;null===e&&null!==s;)e=s.getNextSibling(),null===e?(s=s.getParent(),c--):s=e}return null!==s&&s.is(r)&&n.push({depth:c,node:s}),n}function D(e,t){let n=e;for(;null!=n;){if(n instanceof t)return n;n=n.getParent()}return null}function H(e){const t=I(e,(e=>i(e)&&!e.isInline()));return i(t)||g(4,e.__key),t}const I=(e,t)=>{let n=e;for(;n!==l()&&null!=n;){if(t(n))return n;n=n.getParent()}return null};function z(e,t,n,o){const r=e=>e instanceof t;return e.registerNodeTransform(t,(e=>{const t=(e=>{const t=e.getChildren();for(let e=0;e<t.length;e++){const n=t[e];if(r(n))return null}let n=e,o=e;for(;null!==n;)if(o=n,n=n.getParent(),r(n))return{child:o,parent:n};return null})(e);if(null!==t){const{child:r,parent:l}=t;if(r.is(e)){o(l,e);const t=r.getNextSiblings(),i=t.length;if(l.insertAfter(r),0!==i){const e=n(l);r.insertAfter(e);for(let n=0;n<i;n++)e.append(t[n])}l.canBeEmpty()||0!==l.getChildrenSize()||l.remove()}}}))}function U(e,n){const o=new Map,r=e._pendingEditorState;for(const[e,r]of n._nodeMap){const n=t(r);if(s(n)){if(!s(r))throw Error(\"Expected node be a TextNode\");n.__text=r.__text}o.set(e,n)}r&&(r._nodeMap=o),e._dirtyType=2;const l=n._selection;c(null===l?null:l.clone())}function k(e){const t=n()||u();if(o(t)){const{focus:n}=t,o=n.getNode(),r=n.offset;if(f(o)){const t=o.getChildAtIndex(r);null==t?o.append(e):t.insertBefore(e),e.selectNext()}else{let t,n;s(o)?(t=o.getParentOrThrow(),n=o.getIndexWithinParent(),r>0&&(n+=1,o.splitText(r))):(t=o,n=r);const[,l]=a(t,n);l.insertBefore(e),l.selectStart()}}else{if(null!=t){const n=t.getNodes();n[n.length-1].getTopLevelElementOrThrow().insertAfter(e)}else{l().append(e)}const n=d();e.insertAfter(n),n.select()}return e.getLatest()}function F(e,t){const n=t();return e.replace(n),n.append(e),n}function $(e,t){return null!==e&&Object.getPrototypeOf(e).constructor.name===t.name}function W(e,t){const n=[];for(let o=0;o<e.length;o++){const r=t(e[o]);null!==r&&n.push(r)}return n}function V(e,t){const n=e.getFirstChild();null!==n?n.insertBefore(t):e.append(t)}function j(e){if(E)return 1;let t=1;for(;e;)t*=Number(window.getComputedStyle(e).getPropertyValue(\"zoom\")),e=e.parentElement;return t}export{R as $dfs,W as $filter,I as $findMatchingParent,H as $getNearestBlockElementAncestorOrThrow,D as $getNearestNodeOfType,V as $insertFirst,k as $insertNodeToNearestRoot,U as $restoreEditorState,F as $wrapNodeInElement,v as CAN_USE_BEFORE_INPUT,p as CAN_USE_DOM,x as IS_ANDROID,P as IS_ANDROID_CHROME,m as IS_APPLE,S as IS_APPLE_WEBKIT,N as IS_CHROME,E as IS_FIREFOX,y as IS_IOS,w as IS_SAFARI,B as addClassNamesToElement,j as calculateZoomLevel,K as isMimeType,_ as markSelection,O as mediaFileReader,b as mergeRegister,$ as objectKlassEquals,M as positionNodeOnRange,z as registerNestedElementResolver,C as removeClassNamesFromElement};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalUtils.dev.mjs';\nimport * as modProd from './LexicalUtils.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $dfs = mod.$dfs;\nexport const $filter = mod.$filter;\nexport const $findMatchingParent = mod.$findMatchingParent;\nexport const $getNearestBlockElementAncestorOrThrow = mod.$getNearestBlockElementAncestorOrThrow;\nexport const $getNearestNodeOfType = mod.$getNearestNodeOfType;\nexport const $insertFirst = mod.$insertFirst;\nexport const $insertNodeToNearestRoot = mod.$insertNodeToNearestRoot;\nexport const $restoreEditorState = mod.$restoreEditorState;\nexport const $splitNode = mod.$splitNode;\nexport const $wrapNodeInElement = mod.$wrapNodeInElement;\nexport const CAN_USE_BEFORE_INPUT = mod.CAN_USE_BEFORE_INPUT;\nexport const CAN_USE_DOM = mod.CAN_USE_DOM;\nexport const IS_ANDROID = mod.IS_ANDROID;\nexport const IS_ANDROID_CHROME = mod.IS_ANDROID_CHROME;\nexport const IS_APPLE = mod.IS_APPLE;\nexport const IS_APPLE_WEBKIT = mod.IS_APPLE_WEBKIT;\nexport const IS_CHROME = mod.IS_CHROME;\nexport const IS_FIREFOX = mod.IS_FIREFOX;\nexport const IS_IOS = mod.IS_IOS;\nexport const IS_SAFARI = mod.IS_SAFARI;\nexport const addClassNamesToElement = mod.addClassNamesToElement;\nexport const calculateZoomLevel = mod.calculateZoomLevel;\nexport const isHTMLAnchorElement = mod.isHTMLAnchorElement;\nexport const isHTMLElement = mod.isHTMLElement;\nexport const isMimeType = mod.isMimeType;\nexport const markSelection = mod.markSelection;\nexport const mediaFileReader = mod.mediaFileReader;\nexport const mergeRegister = mod.mergeRegister;\nexport const objectKlassEquals = mod.objectKlassEquals;\nexport const positionNodeOnRange = mod.positionNodeOnRange;\nexport const registerNestedElementResolver = mod.registerNestedElementResolver;\nexport const removeClassNamesFromElement = mod.removeClassNamesFromElement;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $cloneWithProperties, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $isTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        element.replaceWith(newElement);\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\n\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{$cloneWithProperties as e,$sliceSelectedTextNodeContent as n}from\"@lexical/selection\";import{isHTMLElement as t}from\"@lexical/utils\";import{$getRoot as l,$isElementNode as o,$isTextNode as r}from\"lexical\";function i(e,n){const t=n.body?n.body.childNodes:[];let l=[];for(let n=0;n<t.length;n++){const o=t[n];if(!u.has(o.nodeName)){const n=a(o,e);null!==n&&(l=l.concat(n))}}return l}function c(e,n){if(\"undefined\"==typeof document||\"undefined\"==typeof window&&void 0===global.window)throw new Error(\"To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.\");const t=document.createElement(\"div\"),o=l().getChildren();for(let l=0;l<o.length;l++){s(e,o[l],t,n)}return t.innerHTML}function s(l,i,c,u=null){let a=null===u||i.isSelected(u);const d=o(i)&&i.excludeFromCopy(\"html\");let f=i;if(null!==u){let t=e(i);t=r(t)&&null!==u?n(u,t):t,f=t}const p=o(f)?f.getChildren():[],m=l._nodes.get(f.getType());let h;h=m&&void 0!==m.exportDOM?m.exportDOM(l,f):f.exportDOM(l);const{element:g,after:y}=h;if(!g)return!1;const w=document.createDocumentFragment();for(let e=0;e<p.length;e++){const n=p[e],t=s(l,n,w,u);!a&&o(i)&&t&&i.extractWithChild(n,u,\"html\")&&(a=!0)}if(a&&!d){if(t(g)&&g.append(w),c.append(g),y){const e=y.call(f,g);e&&g.replaceWith(e)}}else c.append(w);return a}const u=new Set([\"STYLE\",\"SCRIPT\"]);function a(e,n,t=new Map,l){let r=[];if(u.has(e.nodeName))return r;let i=null;const c=function(e,n){const{nodeName:t}=e,l=n._htmlConversions.get(t.toLowerCase());let o=null;if(void 0!==l)for(const n of l){const t=n(e);null!==t&&(null===o||(o.priority||0)<(t.priority||0))&&(o=t)}return null!==o?o.conversion:null}(e,n),s=c?c(e):null;let d=null;if(null!==s){d=s.after;const n=s.node;if(i=Array.isArray(n)?n[n.length-1]:n,null!==i){for(const[,e]of t)if(i=e(i,l),!i)break;i&&r.push(...Array.isArray(n)?n:[i])}null!=s.forChild&&t.set(e.nodeName,s.forChild)}const f=e.childNodes;let p=[];for(let e=0;e<f.length;e++)p.push(...a(f[e],n,new Map(t),i));return null!=d&&(p=d(p)),null==i?r=r.concat(p):o(i)&&i.append(...p),r}export{c as $generateHtmlFromNodes,i as $generateNodesFromDOM};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalHtml.dev.mjs';\nimport * as modProd from './LexicalHtml.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $generateHtmlFromNodes = mod.$generateHtmlFromNodes;\nexport const $generateNodesFromDOM = mod.$generateNodesFromDOM;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $isElementNode, $isLeafNode, $createParagraphNode, $isParagraphNode, $applyNodeReplacement, ElementNode, $createTextNode, createCommand } from 'lexical';\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      if ($isRangeSelection(selection)) {\n        const anchorAndFocus = selection.getStartEndPoints();\n        if (!(anchorAndFocus !== null)) {\n          throw Error(`insertList: anchor should be defined`);\n        }\n        const [anchor] = anchorAndFocus;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n          if ($isRootOrShadowRoot(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if ($isElementNode(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n          return;\n        }\n      }\n      const handled = new Set();\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n          createListOrMerge(node, listType);\n          continue;\n        }\n        if ($isLeafNode(node)) {\n          let parent = node.getParent();\n          while (parent != null) {\n            const parentKey = parent.getKey();\n            if ($isListNode(parent)) {\n              if (!handled.has(parentKey)) {\n                const newListNode = $createListNode(listType);\n                append(newListNode, parent.getChildren());\n                parent.replace(newListNode);\n                handled.add(parentKey);\n              }\n              break;\n            } else {\n              const nextParent = parent.getParent();\n              if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                handled.add(parentKey);\n                createListOrMerge(parent, listType);\n                break;\n              }\n              parent = nextParent;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove();\n    // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    return list;\n  }\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if ($isLeafNode(node)) {\n            const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = $createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getChecked() != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListItemNode(node)) {\n        throw Error(`node is not a ListItemNode`);\n      }\n      if (node.__checked == null) {\n        return;\n      }\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number' && indent > -1)) {\n      throw Error(`Invalid indent value.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction convertListItemElement(domNode) {\n  const checked = isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListNode(node)) {\n        throw Error(`node is not a ListNode`);\n      }\n      mergeNextSiblingListIfSameType(node);\n      updateChildrenListItemValue(node);\n    };\n  }\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if ($isElementNode(currentNode)) {\n          const textNode = $createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push(wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType, start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\n\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $isListItemNode, $isListNode, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode, REMOVE_LIST_COMMAND, insertList, removeList };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{$getSelection as e,$isRangeSelection as t,$isRootOrShadowRoot as n,$isElementNode as r,$isLeafNode as i,$createParagraphNode as s,$isParagraphNode as o,$applyNodeReplacement as c,ElementNode as l,$createTextNode as h,createCommand as a}from\"lexical\";import{$getNearestNodeOfType as u,removeClassNamesFromElement as g,addClassNamesToElement as d,isHTMLElement as f}from\"@lexical/utils\";var p=function(e){const t=new URLSearchParams;t.append(\"code\",e);for(let e=1;e<arguments.length;e++)t.append(\"v\",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)};function _(e){let t=1,n=e.getParent();for(;null!=n;){if(I(n)){const e=n.getParent();if(z(e)){t++,n=e.getParent();continue}p(40)}return t}return t}function m(e){let t=e.getParent();z(t)||p(40);let n=t;for(;null!==n;)n=n.getParent(),z(n)&&(t=n);return t}function v(e){let t=[];const n=e.getChildren().filter(I);for(let e=0;e<n.length;e++){const r=n[e],i=r.getFirstChild();z(i)?t=t.concat(v(i)):t.push(r)}return t}function y(e){return I(e)&&z(e.getFirstChild())}function C(e){return D().append(e)}function T(e,t){return I(e)&&(0===t.length||1===t.length&&e.is(t[0])&&0===e.getChildrenSize())}function k(s,o){s.update((()=>{const s=e();if(null!==s){const e=s.getNodes();if(t(s)){const t=s.getStartEndPoints();null===t&&p(143);const[i]=t,c=i.getNode(),l=c.getParent();if(T(c,e)){const e=J(o);if(n(l)){c.replace(e);const t=D();r(c)&&(t.setFormat(c.getFormatType()),t.setIndent(c.getIndent())),e.append(t)}else if(I(c)){const t=c.getParentOrThrow();S(e,t.getChildren()),t.replace(e)}return}}const c=new Set;for(let t=0;t<e.length;t++){const s=e[t];if(!r(s)||!s.isEmpty()||I(s)||c.has(s.getKey())){if(i(s)){let e=s.getParent();for(;null!=e;){const t=e.getKey();if(z(e)){if(!c.has(t)){const n=J(o);S(n,e.getChildren()),e.replace(n),c.add(t)}break}{const r=e.getParent();if(n(r)&&!c.has(t)){c.add(t),b(e,o);break}e=r}}}}else b(s,o)}}}))}function S(e,t){e.splice(e.getChildrenSize(),0,t)}function b(e,t){if(z(e))return e;const n=e.getPreviousSibling(),r=e.getNextSibling(),i=D();if(i.setFormat(e.getFormatType()),i.setIndent(e.getIndent()),S(i,e.getChildren()),z(n)&&t===n.getListType())return n.append(i),e.remove(),z(r)&&t===r.getListType()&&(S(n,r.getChildren()),r.remove()),n;if(z(r)&&t===r.getListType())return r.getFirstChildOrThrow().insertBefore(i),e.remove(),r;{const n=J(t);return n.append(i),e.replace(n),n}}function P(e,t){const n=e.getLastChild(),r=t.getFirstChild();n&&r&&y(n)&&y(r)&&(P(n.getFirstChild(),r.getFirstChild()),r.remove());const i=t.getChildren();i.length>0&&e.append(...i),t.remove()}function N(n){n.update((()=>{const n=e();if(t(n)){const e=new Set,t=n.getNodes(),r=n.anchor.getNode();if(T(r,t))e.add(m(r));else for(let n=0;n<t.length;n++){const r=t[n];if(i(r)){const t=u(r,E);null!=t&&e.add(m(t))}}for(const t of e){let e=t;const r=v(t);for(const t of r){const r=s();S(r,t.getChildren()),e.insertAfter(r),e=r,t.__key===n.anchor.key&&n.anchor.set(r.getKey(),0,\"element\"),t.__key===n.focus.key&&n.focus.set(r.getKey(),0,\"element\"),t.remove()}t.remove()}}}))}function x(e){const t=new Set;if(y(e)||t.has(e.getKey()))return;const n=e.getParent(),r=e.getNextSibling(),i=e.getPreviousSibling();if(y(r)&&y(i)){const n=i.getFirstChild();if(z(n)){n.append(e);const i=r.getFirstChild();if(z(i)){S(n,i.getChildren()),r.remove(),t.add(r.getKey())}}}else if(y(r)){const t=r.getFirstChild();if(z(t)){const n=t.getFirstChild();null!==n&&n.insertBefore(e)}}else if(y(i)){const t=i.getFirstChild();z(t)&&t.append(e)}else if(z(n)){const t=D(),s=J(n.getListType());t.append(s),s.append(e),i?i.insertAfter(t):r?r.insertBefore(t):n.append(t)}}function A(e){if(y(e))return;const t=e.getParent(),n=t?t.getParent():void 0;if(z(n?n.getParent():void 0)&&I(n)&&z(t)){const r=t?t.getFirstChild():void 0,i=t?t.getLastChild():void 0;if(e.is(r))n.insertBefore(e),t.isEmpty()&&n.remove();else if(e.is(i))n.insertAfter(e),t.isEmpty()&&n.remove();else{const r=t.getListType(),i=D(),s=J(r);i.append(s),e.getPreviousSiblings().forEach((e=>s.append(e)));const o=D(),c=J(r);o.append(c),S(c,e.getNextSiblings()),n.insertBefore(i),n.insertAfter(o),n.replace(e)}}}function O(){const r=e();if(!t(r)||!r.isCollapsed())return!1;const i=r.anchor.getNode();if(!I(i)||0!==i.getChildrenSize())return!1;const c=m(i),l=i.getParent();z(l)||p(40);const h=l.getParent();let a;if(n(h))a=s(),c.insertAfter(a);else{if(!I(h))return!1;a=D(),h.insertAfter(a)}a.select();const u=i.getNextSiblings();if(u.length>0){const e=J(l.getListType());if(o(a))a.insertAfter(e);else{const t=D();t.append(e),a.insertAfter(t)}u.forEach((t=>{t.remove(),e.append(t)}))}return function(e){let t=e;for(;null==t.getNextSibling()&&null==t.getPreviousSibling();){const e=t.getParent();if(null==e||!I(t)&&!z(t))break;t=e}t.remove()}(i),!0}function L(...e){const t=[];for(const n of e)if(n&&\"string\"==typeof n)for(const[e]of n.matchAll(/\\S+/g))t.push(e);return t}class E extends l{static getType(){return\"listitem\"}static clone(e){return new E(e.__value,e.__checked,e.__key)}constructor(e,t,n){super(n),this.__value=void 0===e?1:e,this.__checked=t}createDOM(e){const t=document.createElement(\"li\"),n=this.getParent();return z(n)&&\"check\"===n.getListType()&&w(t,this,null),t.value=this.__value,F(t,e.theme,this),t}updateDOM(e,t,n){const r=this.getParent();return z(r)&&\"check\"===r.getListType()&&w(t,this,e),t.value=this.__value,F(t,n.theme,this),!1}static transform(){return e=>{if(I(e)||p(144),null==e.__checked)return;const t=e.getParent();z(t)&&\"check\"!==t.getListType()&&null!=e.getChecked()&&e.setChecked(void 0)}}static importDOM(){return{li:e=>({conversion:M,priority:0})}}static importJSON(e){const t=D();return t.setChecked(e.checked),t.setValue(e.value),t.setFormat(e.format),t.setDirection(e.direction),t}exportDOM(e){const t=this.createDOM(e._config);return t.style.textAlign=this.getFormatType(),{element:t}}exportJSON(){return{...super.exportJSON(),checked:this.getChecked(),type:\"listitem\",value:this.getValue(),version:1}}append(...e){for(let t=0;t<e.length;t++){const n=e[t];if(r(n)&&this.canMergeWith(n)){const e=n.getChildren();this.append(...e),n.remove()}else super.append(n)}return this}replace(e,t){if(I(e))return super.replace(e);this.setIndent(0);const n=this.getParentOrThrow();if(!z(n))return e;if(n.__first===this.getKey())n.insertBefore(e);else if(n.__last===this.getKey())n.insertAfter(e);else{const t=J(n.getListType());let r=this.getNextSibling();for(;r;){const e=r;r=r.getNextSibling(),t.append(e)}n.insertAfter(e),e.insertAfter(t)}return t&&(r(e)||p(139),this.getChildren().forEach((t=>{e.append(t)}))),this.remove(),0===n.getChildrenSize()&&n.remove(),e}insertAfter(e,t=!0){const n=this.getParentOrThrow();if(z(n)||p(39),I(e))return super.insertAfter(e,t);const r=this.getNextSiblings();if(n.insertAfter(e,t),0!==r.length){const i=J(n.getListType());r.forEach((e=>i.append(e))),e.insertAfter(i,t)}return e}remove(e){const t=this.getPreviousSibling(),n=this.getNextSibling();super.remove(e),t&&n&&y(t)&&y(n)&&(P(t.getFirstChild(),n.getFirstChild()),n.remove())}insertNewAfter(e,t=!0){const n=D(null==this.__checked&&void 0);return this.insertAfter(n,t),n}collapseAtStart(e){const t=s();this.getChildren().forEach((e=>t.append(e)));const n=this.getParentOrThrow(),r=n.getParentOrThrow(),i=I(r);if(1===n.getChildrenSize())if(i)n.remove(),r.select();else{n.insertBefore(t),n.remove();const r=e.anchor,i=e.focus,s=t.getKey();\"element\"===r.type&&r.getNode().is(this)&&r.set(s,r.offset,\"element\"),\"element\"===i.type&&i.getNode().is(this)&&i.set(s,i.offset,\"element\")}else n.insertBefore(t),this.remove();return!0}getValue(){return this.getLatest().__value}setValue(e){this.getWritable().__value=e}getChecked(){return this.getLatest().__checked}setChecked(e){this.getWritable().__checked=e}toggleChecked(){this.setChecked(!this.__checked)}getIndent(){const e=this.getParent();if(null===e)return this.getLatest().__indent;let t=e.getParentOrThrow(),n=0;for(;I(t);)t=t.getParentOrThrow().getParentOrThrow(),n++;return n}setIndent(e){\"number\"==typeof e&&e>-1||p(117);let t=this.getIndent();for(;t!==e;)t<e?(x(this),t++):(A(this),t--);return this}canInsertAfter(e){return I(e)}canReplaceWith(e){return I(e)}canMergeWith(e){return o(e)||I(e)}extractWithChild(e,n){if(!t(n))return!1;const r=n.anchor.getNode(),i=n.focus.getNode();return this.isParentOf(r)&&this.isParentOf(i)&&this.getTextContent().length===n.getTextContent().length}isParentRequired(){return!0}createParentElementNode(){return J(\"bullet\")}}function F(e,t,n){const r=[],i=[],s=t.list,o=s?s.listitem:void 0;let c;if(s&&s.nested&&(c=s.nested.listitem),void 0!==o&&r.push(...L(o)),s){const e=n.getParent(),t=z(e)&&\"check\"===e.getListType(),o=n.getChecked();t&&!o||i.push(s.listitemUnchecked),t&&o||i.push(s.listitemChecked),t&&r.push(o?s.listitemChecked:s.listitemUnchecked)}if(void 0!==c){const e=L(c);n.getChildren().some((e=>z(e)))?r.push(...e):i.push(...e)}i.length>0&&g(e,...i),r.length>0&&d(e,...r)}function w(e,t,n,r){z(t.getFirstChild())?(e.removeAttribute(\"role\"),e.removeAttribute(\"tabIndex\"),e.removeAttribute(\"aria-checked\")):(e.setAttribute(\"role\",\"checkbox\"),e.setAttribute(\"tabIndex\",\"-1\"),n&&t.__checked===n.__checked||e.setAttribute(\"aria-checked\",t.getChecked()?\"true\":\"false\"))}function M(e){return{node:D(f(e)&&\"true\"===e.getAttribute(\"aria-checked\"))}}function D(e){return c(new E(void 0,e))}function I(e){return e instanceof E}class R extends l{static getType(){return\"list\"}static clone(e){const t=e.__listType||V[e.__tag];return new R(t,e.__start,e.__key)}constructor(e,t,n){super(n);const r=V[e]||e;this.__listType=r,this.__tag=\"number\"===r?\"ol\":\"ul\",this.__start=t}getTag(){return this.__tag}setListType(e){const t=this.getWritable();t.__listType=e,t.__tag=\"number\"===e?\"ol\":\"ul\"}getListType(){return this.__listType}getStart(){return this.__start}createDOM(e,t){const n=this.__tag,r=document.createElement(n);return 1!==this.__start&&r.setAttribute(\"start\",String(this.__start)),r.__lexicalListType=this.__listType,K(r,e.theme,this),r}updateDOM(e,t,n){return e.__tag!==this.__tag||(K(t,n.theme,this),!1)}static transform(){return e=>{if(!z(e))throw Error(\"node is not a ListNode\");!function(e){const t=e.getNextSibling();z(t)&&e.getListType()===t.getListType()&&P(e,t)}(e),function(e){const t=\"check\"!==e.getListType();let n=e.getStart();for(const r of e.getChildren())I(r)&&(r.getValue()!==n&&r.setValue(n),t&&null!=r.getChecked()&&r.setChecked(void 0),z(r.getFirstChild())||n++)}(e)}}static importDOM(){return{ol:e=>({conversion:W,priority:0}),ul:e=>({conversion:W,priority:0})}}static importJSON(e){const t=J(e.listType,e.start);return t.setFormat(e.format),t.setIndent(e.indent),t.setDirection(e.direction),t}exportDOM(e){const{element:t}=super.exportDOM(e);return t&&f(t)&&(1!==this.__start&&t.setAttribute(\"start\",String(this.__start)),\"check\"===this.__listType&&t.setAttribute(\"__lexicalListType\",\"check\")),{element:t}}exportJSON(){return{...super.exportJSON(),listType:this.getListType(),start:this.getStart(),tag:this.getTag(),type:\"list\",version:1}}canBeEmpty(){return!1}canIndent(){return!1}append(...e){for(let t=0;t<e.length;t++){const n=e[t];if(I(n))super.append(n);else{const e=D();if(z(n))e.append(n);else if(r(n)){const t=h(n.getTextContent());e.append(t)}else e.append(n);super.append(e)}}return this}extractWithChild(e){return I(e)}}function K(e,t,n){const r=[],i=[],s=t.list;if(void 0!==s){const e=s[`${n.__tag}Depth`]||[],t=_(n)-1,o=t%e.length,c=e[o],l=s[n.__tag];let h;const a=s.nested,u=s.checklist;if(void 0!==a&&a.list&&(h=a.list),void 0!==l&&r.push(l),void 0!==u&&\"check\"===n.__listType&&r.push(u),void 0!==c){r.push(...L(c));for(let t=0;t<e.length;t++)t!==o&&i.push(n.__tag+t)}if(void 0!==h){const e=L(h);t>1?r.push(...e):i.push(...e)}}i.length>0&&g(e,...i),r.length>0&&d(e,...r)}function B(e){const t=[];for(let n=0;n<e.length;n++){const r=e[n];if(I(r)){t.push(r);const e=r.getChildren();e.length>1&&e.forEach((e=>{z(e)&&t.push(C(e))}))}else t.push(C(r))}return t}function W(e){const t=e.nodeName.toLowerCase();let n=null;if(\"ol\"===t){n=J(\"number\",e.start)}else\"ul\"===t&&(n=f(e)&&\"check\"===e.getAttribute(\"__lexicallisttype\")?J(\"check\"):J(\"bullet\"));return{after:B,node:n}}const V={ol:\"number\",ul:\"bullet\"};function J(e,t=1){return c(new R(e,t))}function z(e){return e instanceof R}const U=a(\"INSERT_UNORDERED_LIST_COMMAND\"),$=a(\"INSERT_ORDERED_LIST_COMMAND\"),q=a(\"INSERT_CHECK_LIST_COMMAND\"),H=a(\"REMOVE_LIST_COMMAND\");export{D as $createListItemNode,J as $createListNode,_ as $getListDepth,O as $handleListInsertParagraph,I as $isListItemNode,z as $isListNode,q as INSERT_CHECK_LIST_COMMAND,$ as INSERT_ORDERED_LIST_COMMAND,U as INSERT_UNORDERED_LIST_COMMAND,E as ListItemNode,R as ListNode,H as REMOVE_LIST_COMMAND,k as insertList,N as removeList};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalList.dev.mjs';\nimport * as modProd from './LexicalList.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $createListItemNode = mod.$createListItemNode;\nexport const $createListNode = mod.$createListNode;\nexport const $getListDepth = mod.$getListDepth;\nexport const $handleListInsertParagraph = mod.$handleListInsertParagraph;\nexport const $isListItemNode = mod.$isListItemNode;\nexport const $isListNode = mod.$isListNode;\nexport const INSERT_CHECK_LIST_COMMAND = mod.INSERT_CHECK_LIST_COMMAND;\nexport const INSERT_ORDERED_LIST_COMMAND = mod.INSERT_ORDERED_LIST_COMMAND;\nexport const INSERT_UNORDERED_LIST_COMMAND = mod.INSERT_UNORDERED_LIST_COMMAND;\nexport const ListItemNode = mod.ListItemNode;\nexport const ListNode = mod.ListNode;\nexport const REMOVE_LIST_COMMAND = mod.REMOVE_LIST_COMMAND;\nexport const insertList = mod.insertList;\nexport const removeList = mod.removeList;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { addClassNamesToElement, isHTMLAnchorElement } from '@lexical/utils';\nimport { createCommand, ElementNode, $applyNodeReplacement, $isRangeSelection, $isElementNode, $getSelection } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url, attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateDOM(prevNode, anchor, config) {\n    const url = this.__url;\n    const target = this.__target;\n    const rel = this.__rel;\n    const title = this.__title;\n    if (url !== prevNode.__url) {\n      anchor.href = url;\n    }\n    if (target !== prevNode.__target) {\n      if (target) {\n        anchor.target = target;\n      } else {\n        anchor.removeAttribute('target');\n      }\n    }\n    if (rel !== prevNode.__rel) {\n      if (rel) {\n        anchor.rel = rel;\n      } else {\n        anchor.removeAttribute('rel');\n      }\n    }\n    if (title !== prevNode.__title) {\n      if (title) {\n        anchor.title = title;\n      } else {\n        anchor.removeAttribute('title');\n      }\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  sanitizeUrl(url) {\n    try {\n      const parsedUrl = new URL(url);\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n}\nfunction convertAnchorElement(domNode) {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes { target, rel, title }\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url, attributes) {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'autolink',\n      version: 1\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url, attributes) {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = createCommand('TOGGLE_LINK_COMMAND');\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n */\nfunction toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return;\n  }\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0];\n      // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n      const linkNode = $getAncestor(firstNode, $isLinkNode);\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n    }\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if (parent === linkNode || parent === null || $isElementNode(node) && !node.isInline()) {\n        return;\n      }\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target,\n          title\n        });\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n        if (linkNode !== null) {\n          const children = node.getChildren();\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n        node.remove();\n        return;\n      }\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\nexport { $createAutoLinkNode, $createLinkNode, $isAutoLinkNode, $isLinkNode, AutoLinkNode, LinkNode, TOGGLE_LINK_COMMAND, toggleLink };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{addClassNamesToElement as t,isHTMLAnchorElement as e}from\"@lexical/utils\";import{createCommand as r,ElementNode as i,$applyNodeReplacement as n,$isRangeSelection as l,$isElementNode as s,$getSelection as u}from\"lexical\";const o=new Set([\"http:\",\"https:\",\"mailto:\",\"sms:\",\"tel:\"]);class _ extends i{static getType(){return\"link\"}static clone(t){return new _(t.__url,{rel:t.__rel,target:t.__target,title:t.__title},t.__key)}constructor(t,e={},r){super(r);const{target:i=null,rel:n=null,title:l=null}=e;this.__url=t,this.__target=i,this.__rel=n,this.__title=l}createDOM(e){const r=document.createElement(\"a\");return r.href=this.sanitizeUrl(this.__url),null!==this.__target&&(r.target=this.__target),null!==this.__rel&&(r.rel=this.__rel),null!==this.__title&&(r.title=this.__title),t(r,e.theme.link),r}updateDOM(t,e,r){const i=this.__url,n=this.__target,l=this.__rel,s=this.__title;return i!==t.__url&&(e.href=i),n!==t.__target&&(n?e.target=n:e.removeAttribute(\"target\")),l!==t.__rel&&(l?e.rel=l:e.removeAttribute(\"rel\")),s!==t.__title&&(s?e.title=s:e.removeAttribute(\"title\")),!1}static importDOM(){return{a:t=>({conversion:a,priority:1})}}static importJSON(t){const e=g(t.url,{rel:t.rel,target:t.target,title:t.title});return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e}sanitizeUrl(t){try{const e=new URL(t);if(!o.has(e.protocol))return\"about:blank\"}catch(e){return t}return t}exportJSON(){return{...super.exportJSON(),rel:this.getRel(),target:this.getTarget(),title:this.getTitle(),type:\"link\",url:this.getURL(),version:1}}getURL(){return this.getLatest().__url}setURL(t){this.getWritable().__url=t}getTarget(){return this.getLatest().__target}setTarget(t){this.getWritable().__target=t}getRel(){return this.getLatest().__rel}setRel(t){this.getWritable().__rel=t}getTitle(){return this.getLatest().__title}setTitle(t){this.getWritable().__title=t}insertNewAfter(t,e=!0){const r=g(this.__url,{rel:this.__rel,target:this.__target,title:this.__title});return this.insertAfter(r,e),r}canInsertTextBefore(){return!1}canInsertTextAfter(){return!1}canBeEmpty(){return!1}isInline(){return!0}extractWithChild(t,e,r){if(!l(e))return!1;const i=e.anchor.getNode(),n=e.focus.getNode();return this.isParentOf(i)&&this.isParentOf(n)&&e.getTextContent().length>0}}function a(t){let r=null;if(e(t)){const e=t.textContent;(null!==e&&\"\"!==e||t.children.length>0)&&(r=g(t.getAttribute(\"href\")||\"\",{rel:t.getAttribute(\"rel\"),target:t.getAttribute(\"target\"),title:t.getAttribute(\"title\")}))}return{node:r}}function g(t,e){return n(new _(t,e))}function c(t){return t instanceof _}class h extends _{static getType(){return\"autolink\"}static clone(t){return new h(t.__url,{rel:t.__rel,target:t.__target,title:t.__title},t.__key)}static importJSON(t){const e=f(t.url,{rel:t.rel,target:t.target,title:t.title});return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e}static importDOM(){return null}exportJSON(){return{...super.exportJSON(),type:\"autolink\",version:1}}insertNewAfter(t,e=!0){const r=this.getParentOrThrow().insertNewAfter(t,e);if(s(r)){const t=f(this.__url,{rel:this.__rel,target:this.__target,title:this.__title});return r.append(t),t}return null}}function f(t,e){return n(new h(t,e))}function p(t){return t instanceof h}const d=r(\"TOGGLE_LINK_COMMAND\");function m(t,e={}){const{target:r,title:i}=e,n=void 0===e.rel?\"noreferrer\":e.rel,o=u();if(!l(o))return;const _=o.extract();if(null===t)_.forEach((t=>{const e=t.getParent();if(c(e)){const t=e.getChildren();for(let r=0;r<t.length;r++)e.insertBefore(t[r]);e.remove()}}));else{if(1===_.length){const e=function(t,e){let r=t;for(;null!==r&&null!==r.getParent()&&!e(r);)r=r.getParentOrThrow();return e(r)?r:null}(_[0],c);if(null!==e)return e.setURL(t),void 0!==r&&e.setTarget(r),null!==n&&e.setRel(n),void(void 0!==i&&e.setTitle(i))}let e=null,l=null;_.forEach((u=>{const o=u.getParent();if(o!==l&&null!==o&&(!s(u)||u.isInline())){if(c(o))return l=o,o.setURL(t),void 0!==r&&o.setTarget(r),null!==n&&l.setRel(n),void(void 0!==i&&l.setTitle(i));if(o.is(e)||(e=o,l=g(t,{rel:n,target:r,title:i}),c(o)?null===u.getPreviousSibling()?o.insertBefore(l):o.insertAfter(l):u.insertBefore(l)),c(u)){if(u.is(l))return;if(null!==l){const t=u.getChildren();for(let e=0;e<t.length;e++)l.append(t[e])}u.remove()}else null!==l&&l.append(u)}}))}}export{f as $createAutoLinkNode,g as $createLinkNode,p as $isAutoLinkNode,c as $isLinkNode,h as AutoLinkNode,_ as LinkNode,d as TOGGLE_LINK_COMMAND,m as toggleLink};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalLink.dev.mjs';\nimport * as modProd from './LexicalLink.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $createAutoLinkNode = mod.$createAutoLinkNode;\nexport const $createLinkNode = mod.$createLinkNode;\nexport const $isAutoLinkNode = mod.$isAutoLinkNode;\nexport const $isLinkNode = mod.$isLinkNode;\nexport const AutoLinkNode = mod.AutoLinkNode;\nexport const LinkNode = mod.LinkNode;\nexport const TOGGLE_LINK_COMMAND = mod.TOGGLE_LINK_COMMAND;\nexport const toggleLink = mod.toggleLink;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $cloneWithProperties, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getRoot, $parseSerializedNode, $isTextNode, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $isElementNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor) {\n  const selection = $getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\nfunction $getLexicalContent(editor) {\n  const selection = $getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const part = parts[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          selection.insertParagraph();\n        } else if (part === '\\t') {\n          selection.insertNodes([$createTabNode()]);\n        } else {\n          selection.insertText(part);\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n  if (!domSelection) {\n    return false;\n  }\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n  if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = $getSelection();\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{$generateHtmlFromNodes as e,$generateNodesFromDOM as t}from\"@lexical/html\";import{$addNodeStyle as n,$cloneWithProperties as o,$sliceSelectedTextNodeContent as l}from\"@lexical/selection\";import{objectKlassEquals as r}from\"@lexical/utils\";import{$getSelection as i,$isRangeSelection as a,$createTabNode as c,SELECTION_INSERT_CLIPBOARD_NODES_COMMAND as s,$getRoot as u,$parseSerializedNode as d,$isTextNode as f,COPY_COMMAND as p,COMMAND_PRIORITY_CRITICAL as m,isSelectionWithinEditor as h,$isElementNode as x}from\"lexical\";var g=function(e){const t=new URLSearchParams;t.append(\"code\",e);for(let e=1;e<arguments.length;e++)t.append(\"v\",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)};const w=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,y=e=>w?(e||window).getSelection():null;function v(t){const n=i();if(null==n)throw Error(\"Expected valid LexicalSelection\");return a(n)&&n.isCollapsed()||0===n.getNodes().length?\"\":e(t,n)}function D(e){const t=i();if(null==t)throw Error(\"Expected valid LexicalSelection\");return a(t)&&t.isCollapsed()||0===t.getNodes().length?null:JSON.stringify(T(e,t))}function C(e,t){const n=e.getData(\"text/plain\")||e.getData(\"text/uri-list\");null!=n&&t.insertRawText(n)}function E(e,n,o){const l=e.getData(\"application/x-lexical-editor\");if(l)try{const e=JSON.parse(l);if(e.namespace===o._config.namespace&&Array.isArray(e.nodes)){return N(o,_(e.nodes),n)}}catch(e){}const r=e.getData(\"text/html\");if(r)try{const e=(new DOMParser).parseFromString(r,\"text/html\");return N(o,t(o,e),n)}catch(e){}const i=e.getData(\"text/plain\")||e.getData(\"text/uri-list\");if(null!=i)if(a(n)){const e=i.split(/(\\r?\\n|\\t)/);\"\"===e[e.length-1]&&e.pop();for(let t=0;t<e.length;t++){const o=e[t];\"\\n\"===o||\"\\r\\n\"===o?n.insertParagraph():\"\\t\"===o?n.insertNodes([c()]):n.insertText(o)}}else n.insertRawText(i)}function N(e,t,n){e.dispatchCommand(s,{nodes:t,selection:n})||n.insertNodes(t)}function S(e,t,n,r=[]){let i=null===t||n.isSelected(t);const a=x(n)&&n.excludeFromCopy(\"html\");let c=n;if(null!==t){let e=o(n);e=f(e)&&null!==t?l(t,e):e,c=e}const s=x(c)?c.getChildren():[],u=function(e){const t=e.exportJSON(),n=e.constructor;if(t.type!==n.getType()&&g(58,n.name),x(e)){const e=t.children;Array.isArray(e)||g(59,n.name)}return t}(c);if(f(c)){const e=c.__text;e.length>0?u.text=e:i=!1}for(let o=0;o<s.length;o++){const l=s[o],r=S(e,t,l,u.children);!i&&x(n)&&r&&n.extractWithChild(l,t,\"clone\")&&(i=!0)}if(i&&!a)r.push(u);else if(Array.isArray(u.children))for(let e=0;e<u.children.length;e++){const t=u.children[e];r.push(t)}return i}function T(e,t){const n=[],o=u().getChildren();for(let l=0;l<o.length;l++){S(e,t,o[l],n)}return{namespace:e._config.namespace,nodes:n}}function _(e){const t=[];for(let o=0;o<e.length;o++){const l=e[o],r=d(l);f(r)&&n(r),t.push(r)}return t}let A=null;async function R(e,t){if(null!==A)return!1;if(null!==t)return new Promise(((n,o)=>{e.update((()=>{n(P(e,t))}))}));const n=e.getRootElement(),o=null==e._window?window.document:e._window.document,l=y(e._window);if(null===n||null===l)return!1;const i=o.createElement(\"span\");i.style.cssText=\"position: fixed; top: -1000px;\",i.append(o.createTextNode(\"#\")),n.append(i);const a=new Range;return a.setStart(i,0),a.setEnd(i,1),l.removeAllRanges(),l.addRange(a),new Promise(((t,n)=>{const l=e.registerCommand(p,(n=>(r(n,ClipboardEvent)&&(l(),null!==A&&(window.clearTimeout(A),A=null),t(P(e,n))),!0)),m);A=window.setTimeout((()=>{l(),A=null,t(!1)}),50),o.execCommand(\"copy\"),i.remove()}))}function P(e,t){const n=y(e._window);if(!n)return!1;const o=n.anchorNode,l=n.focusNode;if(null!==o&&null!==l&&!h(e,o,l))return!1;t.preventDefault();const r=t.clipboardData,a=i();if(null===r||null===a)return!1;const c=v(e),s=D(e);let u=\"\";return null!==a&&(u=a.getTextContent()),null!==c&&r.setData(\"text/html\",c),null!==s&&r.setData(\"application/x-lexical-editor\",s),r.setData(\"text/plain\",u),!0}export{T as $generateJSONFromSelectedNodes,_ as $generateNodesFromSerializedNodes,v as $getHtmlContent,D as $getLexicalContent,C as $insertDataTransferForPlainText,E as $insertDataTransferForRichText,N as $insertGeneratedNodes,R as copyToClipboard};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalClipboard.dev.mjs';\nimport * as modProd from './LexicalClipboard.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $generateJSONFromSelectedNodes = mod.$generateJSONFromSelectedNodes;\nexport const $generateNodesFromSerializedNodes = mod.$generateNodesFromSerializedNodes;\nexport const $getHtmlContent = mod.$getHtmlContent;\nexport const $getLexicalContent = mod.$getLexicalContent;\nexport const $insertDataTransferForPlainText = mod.$insertDataTransferForPlainText;\nexport const $insertDataTransferForRichText = mod.$insertDataTransferForRichText;\nexport const $insertGeneratedNodes = mod.$insertGeneratedNodes;\nexport const copyToClipboard = mod.copyToClipboard;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { mergeRegister } from '@lexical/utils';\nimport { UNDO_COMMAND, COMMAND_PRIORITY_EDITOR, REDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, $isRangeSelection, $isTextNode, $isRootNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!$isRangeSelection(nextSelection) || !$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && $isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!$isTextNode(prevDirtyNode) || !$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  let isDeletingLine = false;\n  if ($isRangeSelection(prevSelection) && $isRangeSelection(nextSelection)) {\n    isDeletingLine = prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  }\n  if (!isDeletingLine && $isTextNode(prevNode) && $isTextNode(nextNode)) {\n    return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregisterCommandListener = mergeRegister(editor.registerCommand(UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  const unregisterUpdateListener = editor.registerUpdateListener(applyChange);\n  return () => {\n    unregisterCommandListener();\n    unregisterUpdateListener();\n  };\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\nexport { createEmptyHistoryState, registerHistory };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{mergeRegister as t}from\"@lexical/utils\";import{UNDO_COMMAND as e,COMMAND_PRIORITY_EDITOR as n,REDO_COMMAND as r,CLEAR_EDITOR_COMMAND as o,CLEAR_HISTORY_COMMAND as i,CAN_REDO_COMMAND as s,CAN_UNDO_COMMAND as c,$isRangeSelection as a,$isTextNode as u,$isRootNode as d}from\"lexical\";const l=0,_=1,f=2,p=0,h=1,m=2,g=3,y=4;function S(t,e,n,r,o){if(null===t||0===n.size&&0===r.size&&!o)return p;const i=e._selection,s=t._selection;if(o)return h;if(!(a(i)&&a(s)&&s.isCollapsed()&&i.isCollapsed()))return p;const c=function(t,e,n){const r=t._nodeMap,o=[];for(const t of e){const e=r.get(t);void 0!==e&&o.push(e)}for(const[t,e]of n){if(!e)continue;const n=r.get(t);void 0===n||d(n)||o.push(n)}return o}(e,n,r);if(0===c.length)return p;if(c.length>1){const n=e._nodeMap,r=n.get(i.anchor.key),o=n.get(s.anchor.key);return r&&o&&!t._nodeMap.has(r.__key)&&u(r)&&1===r.__text.length&&1===i.anchor.offset?m:p}const l=c[0],_=t._nodeMap.get(l.__key);if(!u(_)||!u(l)||_.__mode!==l.__mode)return p;const f=_.__text,S=l.__text;if(f===S)return p;const k=i.anchor,C=s.anchor;if(k.key!==C.key||\"text\"!==k.type)return p;const x=k.offset,M=C.offset,z=S.length-f.length;return 1===z&&M===x-1?m:-1===z&&M===x+1?g:-1===z&&M===x?y:p}function k(t,e){let n=Date.now(),r=p;return(o,i,s,c,d,h)=>{const m=Date.now();if(h.has(\"historic\"))return r=p,n=m,f;const g=S(o,i,c,d,t.isComposing()),y=(()=>{const y=null===s||s.editor===t,S=h.has(\"history-push\");if(!S&&y&&h.has(\"history-merge\"))return l;if(null===o)return _;const k=i._selection;if(!(c.size>0||d.size>0))return null!==k?l:f;if(!1===S&&g!==p&&g===r&&m<n+e&&y)return l;if(1===c.size){if(function(t,e,n){const r=e._nodeMap.get(t),o=n._nodeMap.get(t),i=e._selection,s=n._selection;let c=!1;return a(i)&&a(s)&&(c=\"element\"===i.anchor.type&&\"element\"===i.focus.type&&\"text\"===s.anchor.type&&\"text\"===s.focus.type),!(c||!u(r)||!u(o))&&r.__type===o.__type&&r.__text===o.__text&&r.__mode===o.__mode&&r.__detail===o.__detail&&r.__style===o.__style&&r.__format===o.__format&&r.__parent===o.__parent}(Array.from(c)[0],o,i))return l}return _})();return n=m,r=g,y}}function C(t){t.undoStack=[],t.redoStack=[],t.current=null}function x(a,u,d){const l=k(a,d),p=({editorState:t,prevEditorState:e,dirtyLeaves:n,dirtyElements:r,tags:o})=>{const i=u.current,d=u.redoStack,p=u.undoStack,h=null===i?null:i.editorState;if(null!==i&&t===h)return;const m=l(e,t,i,n,r,o);if(m===_)0!==d.length&&(u.redoStack=[],a.dispatchCommand(s,!1)),null!==i&&(p.push({...i}),a.dispatchCommand(c,!0));else if(m===f)return;u.current={editor:a,editorState:t}},h=t(a.registerCommand(e,(()=>(function(t,e){const n=e.redoStack,r=e.undoStack;if(0!==r.length){const o=e.current,i=r.pop();null!==o&&(n.push(o),t.dispatchCommand(s,!0)),0===r.length&&t.dispatchCommand(c,!1),e.current=i||null,i&&i.editor.setEditorState(i.editorState,{tag:\"historic\"})}}(a,u),!0)),n),a.registerCommand(r,(()=>(function(t,e){const n=e.redoStack,r=e.undoStack;if(0!==n.length){const o=e.current;null!==o&&(r.push(o),t.dispatchCommand(c,!0));const i=n.pop();0===n.length&&t.dispatchCommand(s,!1),e.current=i||null,i&&i.editor.setEditorState(i.editorState,{tag:\"historic\"})}}(a,u),!0)),n),a.registerCommand(o,(()=>(C(u),!1)),n),a.registerCommand(i,(()=>(C(u),a.dispatchCommand(s,!1),a.dispatchCommand(c,!1),!0)),n),a.registerUpdateListener(p)),m=a.registerUpdateListener(p);return()=>{h(),m()}}function M(){return{current:null,redoStack:[],undoStack:[]}}export{M as createEmptyHistoryState,x as registerHistory};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalHistory.dev.mjs';\nimport * as modProd from './LexicalHistory.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const createEmptyHistoryState = mod.createEmptyHistoryState;\nexport const registerHistory = mod.registerHistory;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $getRoot, $isDecoratorNode, $isElementNode, $isParagraphNode, $isTextNode, TextNode, $createTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = $getRoot();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = $getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ($isDecoratorNode(topBlock)) {\n      return false;\n    }\n    if ($isElementNode(topBlock)) {\n      if (!$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ($isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const replaceWithSimpleText = node => {\n    const textNode = $createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ($isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ($isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      } else {\n        const nextMatch = getMatch(nextText);\n        if (nextMatch !== null && nextMatch.start === 0) {\n          return;\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && $isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n    }\n  };\n  const reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ($isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      replaceWithSimpleText(prevSibling);\n      replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(TextNode, textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexport { $canShowPlaceholder, $canShowPlaceholderCurry, $findTextIntersectionFromCharacters, $isRootTextContentEmpty, $isRootTextContentEmptyCurry, $rootTextContent, registerLexicalTextEntity };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{$getRoot as t,$isDecoratorNode as e,$isElementNode as n,$isParagraphNode as r,$isTextNode as i,TextNode as o,$createTextNode as l}from\"lexical\";function s(){return t().getTextContent()}function u(t,e=!0){if(t)return!1;let n=s();return e&&(n=n.trim()),\"\"===n}function f(t,e){return()=>u(t,e)}function c(o){if(!u(o,!1))return!1;const l=t().getChildren(),s=l.length;if(s>1)return!1;for(let t=0;t<s;t++){const o=l[t];if(e(o))return!1;if(n(o)){if(!r(o))return!1;if(0!==o.__indent)return!1;const e=o.getChildren(),n=e.length;for(let r=0;r<n;r++){const n=e[t];if(!i(n))return!1}}}return!0}function g(t){return()=>c(t)}function x(t,e){let r=t.getFirstChild(),o=0;t:for(;null!==r;){if(n(r)){const t=r.getFirstChild();if(null!==t){r=t;continue}}else if(i(r)){const t=r.getTextContentSize();if(o+t>e)return{node:r,offset:e-o};o+=t}const t=r.getNextSibling();if(null!==t){r=t;continue}let l=r.getParent();for(;null!==l;){const t=l.getNextSibling();if(null!==t){r=t;continue t}l=l.getParent()}break}return null}function a(t,e,n,r){const s=t=>t instanceof n,u=t=>{const e=l(t.getTextContent());e.setFormat(t.getFormat()),t.replace(e)};return[t.registerNodeTransform(o,(t=>{if(!t.isSimpleText())return;const n=t.getPreviousSibling();let o,l=t.getTextContent(),f=t;if(i(n)){const r=n.getTextContent(),i=e(r+l);if(s(n)){if(null===i||0!==(t=>t.getLatest().__mode)(n))return void u(n);{const e=i.end-r.length;if(e>0){const i=r+l.slice(0,e);if(n.select(),n.setTextContent(i),e===l.length)t.remove();else{const n=l.slice(e);t.setTextContent(n)}return}}}else if(null===i||i.start<r.length)return}for(;;){o=e(l);let t,c=null===o?\"\":l.slice(o.end);if(l=c,\"\"===c){const t=f.getNextSibling();if(i(t)){c=f.getTextContent()+t.getTextContent();const n=e(c);if(null===n)return void(s(t)?u(t):t.markDirty());if(0!==n.start)return}}else{const t=e(c);if(null!==t&&0===t.start)return}if(null===o)return;if(0===o.start&&i(n)&&n.isTextEntity())continue;0===o.start?[t,f]=f.splitText(o.end):[,t,f]=f.splitText(o.start,o.end);const g=r(t);if(g.setFormat(t.getFormat()),t.replace(g),null==f)return}})),t.registerNodeTransform(n,(t=>{const n=t.getTextContent(),r=e(n);if(null===r||0!==r.start)return void u(t);if(n.length>r.end)return void t.splitText(r.end);const o=t.getPreviousSibling();i(o)&&o.isTextEntity()&&(u(o),u(t));const l=t.getNextSibling();i(l)&&l.isTextEntity()&&(u(l),s(t)&&u(t))}))]}export{c as $canShowPlaceholder,g as $canShowPlaceholderCurry,x as $findTextIntersectionFromCharacters,u as $isRootTextContentEmpty,f as $isRootTextContentEmptyCurry,s as $rootTextContent,a as registerLexicalTextEntity};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalText.dev.mjs';\nimport * as modProd from './LexicalText.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $canShowPlaceholder = mod.$canShowPlaceholder;\nexport const $canShowPlaceholderCurry = mod.$canShowPlaceholderCurry;\nexport const $findTextIntersectionFromCharacters = mod.$findTextIntersectionFromCharacters;\nexport const $isRootTextContentEmpty = mod.$isRootTextContentEmpty;\nexport const $isRootTextContentEmptyCurry = mod.$isRootTextContentEmptyCurry;\nexport const $rootTextContent = mod.$rootTextContent;\nexport const registerLexicalTextEntity = mod.registerLexicalTextEntity;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $insertDataTransferForRichText, copyToClipboard } from '@lexical/clipboard';\nimport { $shouldOverrideDefaultCharacterSelection, $moveCharacter } from '@lexical/selection';\nimport { addClassNamesToElement, isHTMLElement, objectKlassEquals, mergeRegister, $findMatchingParent, $getNearestBlockElementAncestorOrThrow } from '@lexical/utils';\nimport { createCommand, ElementNode, $applyNodeReplacement, $createParagraphNode, CLICK_COMMAND, $getSelection, $isNodeSelection, DELETE_CHARACTER_COMMAND, $isRangeSelection, COMMAND_PRIORITY_EDITOR, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, REMOVE_TEXT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, $isElementNode, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, $insertNodes, $createTabNode, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, KEY_ARROW_UP_COMMAND, $isDecoratorNode, $getAdjacentNode, KEY_ARROW_DOWN_COMMAND, $getRoot, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_BACKSPACE_COMMAND, $isRootNode, KEY_DELETE_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, DROP_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $isTextNode, $normalizeSelection__EXPERIMENTAL, $setSelection, DRAGSTART_COMMAND, DRAGOVER_COMMAND, SELECT_ALL_COMMAND, $selectAll, COPY_COMMAND, CUT_COMMAND, PASTE_COMMAND, isSelectionCapturedInDecoratorInput } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nCAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst DRAG_DROP_PASTE = createCommand('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'quote'\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = $createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return $applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      addClassNamesToElement(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const newElement = anchorOffet === this.getTextContentSize() || !selection ? $createParagraphNode() : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = $createParagraphNode();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag) {\n  return $applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = $getSelection();\n    const clipboardData = objectKlassEquals(event, InputEvent) || objectKlassEquals(event, KeyboardEvent) ? null : event.clipboardData;\n    if (clipboardData != null && selection !== null) {\n      $insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.removeText();\n    } else if ($isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if (objectKlassEquals(event, DragEvent)) {\n    dataTransfer = event.dataTransfer;\n  } else if (objectKlassEquals(event, ClipboardEvent)) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction handleIndentAndOutdent(indentOrOutdent) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = $getNearestBlockElementAncestorOrThrow(node);\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = $getNearestNodeFromDOMNode(target);\n  return $isDecoratorNode(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === $getRoot().getChildrenSize();\n}\nfunction registerRichText(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(CLICK_COMMAND, payload => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, 0), editor.registerCommand(DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_WORD_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_LINE_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = $getSelection();\n    if (typeof eventOrText === 'string') {\n      if (selection !== null) {\n        selection.insertText(eventOrText);\n      }\n    } else {\n      if (selection === null) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        $insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if ($isRangeSelection(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REMOVE_TEXT_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_TEXT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_ELEMENT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(OUTDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      const possibleNode = $getAdjacentNode(selection.focus, true);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = $getAdjacentNode(selection.focus, false);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if ($shouldOverrideDefaultCharacterSelection(selection, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if ($shouldOverrideDefaultCharacterSelection(selection, false)) {\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (selection.isCollapsed() && anchor.offset === 0 && !$isRootNode(anchorNode)) {\n      const element = $getNearestBlockElementAncestorOrThrow(anchorNode);\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ENTER_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND, undefined);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = $getNearestNodeFromDOMNode(domNode);\n        if (node !== null) {\n          const selection = $createRangeSelection();\n          if ($isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = $normalizeSelection__EXPERIMENTAL(selection);\n          $setSelection(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = $getNearestNodeFromDOMNode(eventRange.node);\n      if ($isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECT_ALL_COMMAND, () => {\n    $selectAll();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(COPY_COMMAND, event => {\n    copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    // if inputs then paste within the input ignore creating a new node on paste event\n    if (isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection !== null) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexport { $createHeadingNode, $createQuoteNode, $isHeadingNode, $isQuoteNode, DRAG_DROP_PASTE, HeadingNode, QuoteNode, eventFiles, registerRichText };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{$insertDataTransferForRichText as t,copyToClipboard as e}from\"@lexical/clipboard\";import{$shouldOverrideDefaultCharacterSelection as n,$moveCharacter as r}from\"@lexical/selection\";import{addClassNamesToElement as o,isHTMLElement as i,objectKlassEquals as s,mergeRegister as a,$findMatchingParent as c,$getNearestBlockElementAncestorOrThrow as u}from\"@lexical/utils\";import{createCommand as l,ElementNode as d,$applyNodeReplacement as m,$createParagraphNode as f,CLICK_COMMAND as g,$getSelection as p,$isNodeSelection as h,DELETE_CHARACTER_COMMAND as v,$isRangeSelection as C,COMMAND_PRIORITY_EDITOR as y,DELETE_WORD_COMMAND as D,DELETE_LINE_COMMAND as x,CONTROLLED_TEXT_INSERTION_COMMAND as w,REMOVE_TEXT_COMMAND as E,FORMAT_TEXT_COMMAND as N,FORMAT_ELEMENT_COMMAND as A,$isElementNode as P,INSERT_LINE_BREAK_COMMAND as O,INSERT_PARAGRAPH_COMMAND as T,INSERT_TAB_COMMAND as I,$insertNodes as S,$createTabNode as _,INDENT_CONTENT_COMMAND as F,OUTDENT_CONTENT_COMMAND as M,KEY_ARROW_UP_COMMAND as b,$isDecoratorNode as K,$getAdjacentNode as k,KEY_ARROW_DOWN_COMMAND as J,$getRoot as q,KEY_ARROW_LEFT_COMMAND as L,KEY_ARROW_RIGHT_COMMAND as R,KEY_BACKSPACE_COMMAND as z,$isRootNode as W,KEY_DELETE_COMMAND as X,KEY_ENTER_COMMAND as Y,KEY_ESCAPE_COMMAND as B,DROP_COMMAND as G,$getNearestNodeFromDOMNode as V,$createRangeSelection as j,$isTextNode as H,$normalizeSelection__EXPERIMENTAL as Q,$setSelection as U,DRAGSTART_COMMAND as Z,DRAGOVER_COMMAND as $,SELECT_ALL_COMMAND as tt,$selectAll as et,COPY_COMMAND as nt,CUT_COMMAND as rt,PASTE_COMMAND as ot,isSelectionCapturedInDecoratorInput as it}from\"lexical\";function st(t,e){if(void 0!==document.caretRangeFromPoint){const n=document.caretRangeFromPoint(t,e);return null===n?null:{node:n.startContainer,offset:n.startOffset}}if(\"undefined\"!==document.caretPositionFromPoint){const n=document.caretPositionFromPoint(t,e);return null===n?null:{node:n.offsetNode,offset:n.offset}}return null}const at=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,ct=at&&\"documentMode\"in document?document.documentMode:null;at&&/Mac|iPod|iPhone|iPad/.test(navigator.platform),at&&/^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);const ut=!(!at||!(\"InputEvent\"in window)||ct)&&\"getTargetRanges\"in new window.InputEvent(\"input\"),lt=at&&/Version\\/[\\d.]+.*Safari/.test(navigator.userAgent),dt=at&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream,mt=(at&&/Android/.test(navigator.userAgent),at&&/^(?=.*Chrome).*/i.test(navigator.userAgent)),ft=at&&/AppleWebKit\\/[\\d.]+/.test(navigator.userAgent)&&!mt,gt=l(\"DRAG_DROP_PASTE_FILE\");class pt extends d{static getType(){return\"quote\"}static clone(t){return new pt(t.__key)}constructor(t){super(t)}createDOM(t){const e=document.createElement(\"blockquote\");return o(e,t.theme.quote),e}updateDOM(t,e){return!1}static importDOM(){return{blockquote:t=>({conversion:xt,priority:0})}}exportDOM(t){const{element:e}=super.exportDOM(t);if(e&&i(e)){this.isEmpty()&&e.append(document.createElement(\"br\"));const t=this.getFormatType();e.style.textAlign=t;const n=this.getDirection();n&&(e.dir=n)}return{element:e}}static importJSON(t){const e=ht();return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e}exportJSON(){return{...super.exportJSON(),type:\"quote\"}}insertNewAfter(t,e){const n=f(),r=this.getDirection();return n.setDirection(r),this.insertAfter(n,e),n}collapseAtStart(){const t=f();return this.getChildren().forEach((e=>t.append(e))),this.replace(t),!0}}function ht(){return m(new pt)}function vt(t){return t instanceof pt}class Ct extends d{static getType(){return\"heading\"}static clone(t){return new Ct(t.__tag,t.__key)}constructor(t,e){super(e),this.__tag=t}getTag(){return this.__tag}createDOM(t){const e=this.__tag,n=document.createElement(e),r=t.theme.heading;if(void 0!==r){const t=r[e];o(n,t)}return n}updateDOM(t,e){return!1}static importDOM(){return{h1:t=>({conversion:Dt,priority:0}),h2:t=>({conversion:Dt,priority:0}),h3:t=>({conversion:Dt,priority:0}),h4:t=>({conversion:Dt,priority:0}),h5:t=>({conversion:Dt,priority:0}),h6:t=>({conversion:Dt,priority:0}),p:t=>{const e=t.firstChild;return null!==e&&yt(e)?{conversion:()=>({node:null}),priority:3}:null},span:t=>yt(t)?{conversion:t=>({node:wt(\"h1\")}),priority:3}:null}}exportDOM(t){const{element:e}=super.exportDOM(t);if(e&&i(e)){this.isEmpty()&&e.append(document.createElement(\"br\"));const t=this.getFormatType();e.style.textAlign=t;const n=this.getDirection();n&&(e.dir=n)}return{element:e}}static importJSON(t){const e=wt(t.tag);return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e}exportJSON(){return{...super.exportJSON(),tag:this.getTag(),type:\"heading\",version:1}}insertNewAfter(t,e=!0){const n=t?t.anchor.offset:0,r=n!==this.getTextContentSize()&&t?wt(this.getTag()):f(),o=this.getDirection();if(r.setDirection(o),this.insertAfter(r,e),0===n&&!this.isEmpty()&&t){const t=f();t.select(),this.replace(t,!0)}return r}collapseAtStart(){const t=this.isEmpty()?f():wt(this.getTag());return this.getChildren().forEach((e=>t.append(e))),this.replace(t),!0}extractWithChild(){return!0}}function yt(t){return\"span\"===t.nodeName.toLowerCase()&&\"26pt\"===t.style.fontSize}function Dt(t){const e=t.nodeName.toLowerCase();let n=null;return\"h1\"!==e&&\"h2\"!==e&&\"h3\"!==e&&\"h4\"!==e&&\"h5\"!==e&&\"h6\"!==e||(n=wt(e),null!==t.style&&n.setFormat(t.style.textAlign)),{node:n}}function xt(t){const e=ht();return null!==t.style&&e.setFormat(t.style.textAlign),{node:e}}function wt(t){return m(new Ct(t))}function Et(t){return t instanceof Ct}function Nt(t){let e=null;if(s(t,DragEvent)?e=t.dataTransfer:s(t,ClipboardEvent)&&(e=t.clipboardData),null===e)return[!1,[],!1];const n=e.types,r=n.includes(\"Files\"),o=n.includes(\"text/html\")||n.includes(\"text/plain\");return[r,Array.from(e.files),o]}function At(t){const e=p();if(!C(e))return!1;const n=new Set,r=e.getNodes();for(let e=0;e<r.length;e++){const o=r[e],i=o.getKey();if(n.has(i))continue;const s=u(o),a=s.getKey();s.canIndent()&&!n.has(a)&&(n.add(a),t(s))}return n.size>0}function Pt(t){const e=V(t);return K(e)}function Ot(o){return a(o.registerCommand(g,(t=>{const e=p();return!!h(e)&&(e.clear(),!0)}),0),o.registerCommand(v,(t=>{const e=p();return!!C(e)&&(e.deleteCharacter(t),!0)}),y),o.registerCommand(D,(t=>{const e=p();return!!C(e)&&(e.deleteWord(t),!0)}),y),o.registerCommand(x,(t=>{const e=p();return!!C(e)&&(e.deleteLine(t),!0)}),y),o.registerCommand(w,(e=>{const n=p();if(\"string\"==typeof e)null!==n&&n.insertText(e);else{if(null===n)return!1;const r=e.dataTransfer;if(null!=r)t(r,n,o);else if(C(n)){const t=e.data;return t&&n.insertText(t),!0}}return!0}),y),o.registerCommand(E,(()=>{const t=p();return!!C(t)&&(t.removeText(),!0)}),y),o.registerCommand(N,(t=>{const e=p();return!!C(e)&&(e.formatText(t),!0)}),y),o.registerCommand(A,(t=>{const e=p();if(!C(e)&&!h(e))return!1;const n=e.getNodes();for(const e of n){const n=c(e,(t=>P(t)&&!t.isInline()));null!==n&&n.setFormat(t)}return!0}),y),o.registerCommand(O,(t=>{const e=p();return!!C(e)&&(e.insertLineBreak(t),!0)}),y),o.registerCommand(T,(()=>{const t=p();return!!C(t)&&(t.insertParagraph(),!0)}),y),o.registerCommand(I,(()=>(S([_()]),!0)),y),o.registerCommand(F,(()=>At((t=>{const e=t.getIndent();t.setIndent(e+1)}))),y),o.registerCommand(M,(()=>At((t=>{const e=t.getIndent();e>0&&t.setIndent(e-1)}))),y),o.registerCommand(b,(t=>{const e=p();if(h(e)&&!Pt(t.target)){const t=e.getNodes();if(t.length>0)return t[0].selectPrevious(),!0}else if(C(e)){const n=k(e.focus,!0);if(!t.shiftKey&&K(n)&&!n.isIsolated()&&!n.isInline())return n.selectPrevious(),t.preventDefault(),!0}return!1}),y),o.registerCommand(J,(t=>{const e=p();if(h(e)){const t=e.getNodes();if(t.length>0)return t[0].selectNext(0,0),!0}else if(C(e)){if(function(t){const e=t.focus;return\"root\"===e.key&&e.offset===q().getChildrenSize()}(e))return t.preventDefault(),!0;const n=k(e.focus,!1);if(!t.shiftKey&&K(n)&&!n.isIsolated()&&!n.isInline())return n.selectNext(),t.preventDefault(),!0}return!1}),y),o.registerCommand(L,(t=>{const e=p();if(h(e)){const n=e.getNodes();if(n.length>0)return t.preventDefault(),n[0].selectPrevious(),!0}if(!C(e))return!1;if(n(e,!0)){const n=t.shiftKey;return t.preventDefault(),r(e,n,!0),!0}return!1}),y),o.registerCommand(R,(t=>{const e=p();if(h(e)&&!Pt(t.target)){const n=e.getNodes();if(n.length>0)return t.preventDefault(),n[0].selectNext(0,0),!0}if(!C(e))return!1;const o=t.shiftKey;return!!n(e,!1)&&(t.preventDefault(),r(e,o,!1),!0)}),y),o.registerCommand(z,(t=>{if(Pt(t.target))return!1;const e=p();if(!C(e))return!1;t.preventDefault();const{anchor:n}=e,r=n.getNode();if(e.isCollapsed()&&0===n.offset&&!W(r)){if(u(r).getIndent()>0)return o.dispatchCommand(M,void 0)}return o.dispatchCommand(v,!0)}),y),o.registerCommand(X,(t=>{if(Pt(t.target))return!1;const e=p();return!!C(e)&&(t.preventDefault(),o.dispatchCommand(v,!1))}),y),o.registerCommand(Y,(t=>{const e=p();if(!C(e))return!1;if(null!==t){if((dt||lt||ft)&&ut)return!1;if(t.preventDefault(),t.shiftKey)return o.dispatchCommand(O,!1)}return o.dispatchCommand(T,void 0)}),y),o.registerCommand(B,(()=>{const t=p();return!!C(t)&&(o.blur(),!0)}),y),o.registerCommand(G,(t=>{const[,e]=Nt(t);if(e.length>0){const n=st(t.clientX,t.clientY);if(null!==n){const{offset:t,node:r}=n,i=V(r);if(null!==i){const e=j();if(H(i))e.anchor.set(i.getKey(),t,\"text\"),e.focus.set(i.getKey(),t,\"text\");else{const t=i.getParentOrThrow().getKey(),n=i.getIndexWithinParent()+1;e.anchor.set(t,n,\"element\"),e.focus.set(t,n,\"element\")}const n=Q(e);U(n)}o.dispatchCommand(gt,e)}return t.preventDefault(),!0}const n=p();return!!C(n)}),y),o.registerCommand(Z,(t=>{const[e]=Nt(t),n=p();return!(e&&!C(n))}),y),o.registerCommand($,(t=>{const[e]=Nt(t),n=p();if(e&&!C(n))return!1;const r=st(t.clientX,t.clientY);if(null!==r){const e=V(r.node);K(e)&&t.preventDefault()}return!0}),y),o.registerCommand(tt,(()=>(et(),!0)),y),o.registerCommand(nt,(t=>(e(o,s(t,ClipboardEvent)?t:null),!0)),y),o.registerCommand(rt,(t=>(async function(t,n){await e(n,s(t,ClipboardEvent)?t:null),n.update((()=>{const t=p();C(t)?t.removeText():h(t)&&t.getNodes().forEach((t=>t.remove()))}))}(t,o),!0)),y),o.registerCommand(ot,(e=>{const[,n,r]=Nt(e);if(n.length>0&&!r)return o.dispatchCommand(gt,n),!0;if(it(e.target))return!1;return null!==p()&&(function(e,n){e.preventDefault(),n.update((()=>{const r=p(),o=s(e,InputEvent)||s(e,KeyboardEvent)?null:e.clipboardData;null!=o&&null!==r&&t(o,r,n)}),{tag:\"paste\"})}(e,o),!0)}),y))}export{wt as $createHeadingNode,ht as $createQuoteNode,Et as $isHeadingNode,vt as $isQuoteNode,gt as DRAG_DROP_PASTE,Ct as HeadingNode,pt as QuoteNode,Nt as eventFiles,Ot as registerRichText};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalRichText.dev.mjs';\nimport * as modProd from './LexicalRichText.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $createHeadingNode = mod.$createHeadingNode;\nexport const $createQuoteNode = mod.$createQuoteNode;\nexport const $isHeadingNode = mod.$isHeadingNode;\nexport const $isQuoteNode = mod.$isQuoteNode;\nexport const DRAG_DROP_PASTE = mod.DRAG_DROP_PASTE;\nexport const HeadingNode = mod.HeadingNode;\nexport const QuoteNode = mod.QuoteNode;\nexport const eventFiles = mod.eventFiles;\nexport const registerRichText = mod.registerRichText;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { addClassNamesToElement, $findMatchingParent, removeClassNamesFromElement, isHTMLElement } from '@lexical/utils';\nimport { ElementNode, $applyNodeReplacement, $createParagraphNode, $isElementNode, $isLineBreakNode, $isTextNode, createCommand, $createTextNode, $getSelection, $isRangeSelection, $normalizeSelection__EXPERIMENTAL, $getNodeByKey, isCurrentlyReadOnlyMode, $createPoint, $setSelection, SELECTION_CHANGE_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $getRoot, KEY_ARROW_DOWN_COMMAND, COMMAND_PRIORITY_HIGH, KEY_ARROW_UP_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ESCAPE_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND, COMMAND_PRIORITY_CRITICAL, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, KEY_TAB_COMMAND, FOCUS_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getPreviousSelection, $createRangeSelectionFromDom, INSERT_PARAGRAPH_COMMAND } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    const cellNode = new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n    cellNode.__rowSpan = node.__rowSpan;\n    cellNode.__backgroundColor = node.__backgroundColor;\n    return cellNode;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    const cellNode = $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined);\n    cellNode.__rowSpan = rowSpan;\n    cellNode.__backgroundColor = serializedNode.backgroundColor || null;\n    return cellNode;\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      const element_ = element;\n      const maxWidth = 700;\n      const colCount = this.getParentOrThrow().getChildrenSize();\n      element_.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n      element_.style.width = `${this.getWidth() || Math.max(90, maxWidth / colCount)}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.__colSpan;\n  }\n  setColSpan(colSpan) {\n    this.getWritable().__colSpan = colSpan;\n    return this;\n  }\n  getRowSpan() {\n    return this.__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    this.getWritable().__rowSpan = rowSpan;\n    return this;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState) {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    this.getWritable().__backgroundColor = newBackgroundColor;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const style = domNode_.style;\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = style.textDecoration === 'line-through';\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = style.textDecoration === 'underline';\n  return {\n    after: childLexicalNodes => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push($createParagraphNode());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !$isElementNode(lexicalNode)) {\n        const paragraphNode = $createParagraphNode();\n        if ($isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        if ($isTextNode(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst INSERT_TABLE_COMMAND = createCommand('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass TableRowNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(this.getHeight() && {\n        height: this.getHeight()\n      }),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return $applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = $createParagraphNode();\n      paragraphNode.append($createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append($createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = $computeTableMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        const currentCell = focusEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n    if (!$isTableRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusEndRowNode.insertAfter(newRow);\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n      if (startRow === focusStartRow) {\n        const currentCell = focusStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n    if (!$isTableRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusStartRowNode.insertBefore(newRow);\n  }\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append($createParagraphNode());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append($createParagraphNode());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected GridNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusRowMap[focusStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    const [map, cellMap] = $computeTableMap(grid, cell, cell);\n    const {\n      startColumn,\n      startRow\n    } = cellMap;\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = 0; j < colSpan; j++) {\n          $insertFirst(currentRowNode, $createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      } else {\n        for (let j = 0; j < colSpan; j++) {\n          insertAfterCell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function write(startRow, startColumn, cell) {\n    const value = {\n      cell,\n      startColumn,\n      startRow\n    };\n    const rowSpan = cell.__rowSpan;\n    const colSpan = cell.__colSpan;\n    for (let i = 0; i < rowSpan; i++) {\n      if (tableMap[startRow + i] === undefined) {\n        tableMap[startRow + i] = [];\n      }\n      for (let j = 0; j < colSpan; j++) {\n        tableMap[startRow + i][startColumn + j] = value;\n      }\n    }\n    if (cellA.is(cell)) {\n      cellAValue = value;\n    }\n    if (cellB.is(cell)) {\n      cellBValue = value;\n    }\n  }\n  function isEmpty(row, column) {\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\n  }\n  const gridChildren = grid.getChildren();\n  for (let i = 0; i < gridChildren.length; i++) {\n    const row = gridChildren[i];\n    if (!$isTableRowNode(row)) {\n      throw Error(`Expected GridNode children to be TableRowNode`);\n    }\n    const rowChildren = row.getChildren();\n    let j = 0;\n    for (const cell of rowChildren) {\n      if (!$isTableCellNode(cell)) {\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\n      }\n      while (!isEmpty(i, j)) {\n        j++;\n      }\n      write(i, j, cell);\n      j += cell.__colSpan;\n    }\n  }\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Grid`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Grid`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = $findMatchingParent(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    throw Error(`Expected TableRowNode to have a parent GridNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isTableSelection(selection)) {\n      return false;\n    }\n    return this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!$isElementNode(focusNode)) {\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n    if (!$isTableCellNode(anchorCellNode)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCellNode);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNode = $getNodeByKey(this.focus.key);\n    if (!$isTableCellNode(focusCellNode)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCellNode);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = $findMatchingParent(anchorNode, $isTableCellNode);\n    // todo replace with triplet\n    const focusCell = $findMatchingParent(focusNode, $isTableCellNode);\n    if (!$isTableCellNode(anchorCell)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    if (!$isTableCellNode(focusCell)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const anchorRow = anchorCell.getParent();\n    if (!$isTableRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent TableRowNode`);\n    }\n    const tableNode = anchorRow.getParent();\n    if (!$isTableNode(tableNode)) {\n      throw Error(`Expected tableNode to have a parent TableNode`);\n    }\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          throw Error(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          throw Error(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n        exploredMinColumn = previousColumn;\n      }\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n        exploredMinRow = previousRow;\n      }\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n        exploredMaxColumn = nextColumn;\n      }\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n        exploredMaxRow = nextRow;\n      }\n    }\n    const nodes = [tableNode];\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodes.push(currentRow);\n        }\n        nodes.push(cell, ...$getChildrenRecursively(cell));\n        lastRow = currentRow;\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n    if ($isElementNode(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTable();\n    this.isSelecting = false;\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n        this.table = getTable(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      this.table = getTable(tableElement);\n      observer.observe(tableElement, {\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const grid = getTable(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      addClassNamesToElement(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n  updateTableTableSelection(selection) {\n    if (selection !== null && selection.tableKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    } else {\n      this.tableNodeKey = selection.tableKey;\n      this.updateTableTableSelection(selection);\n    }\n  }\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window);\n        // Collapse the selection\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n      this.focusX = cellX;\n      this.focusY = cellY;\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n        if (this.tableSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode) && tableNode.is($findTableNode(focusTableCellNode))) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.tableSelection = this.tableSelection.clone() || $createTableSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          $setSelection(this.tableSelection);\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.table, this.tableSelection);\n        }\n      }\n    });\n  }\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const formatSelection = $createRangeSelection();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      selection.getNodes().forEach(cellNode => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n      $setSelection(selection);\n      this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const selection = $getSelection();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n      if (selectedNodes.length === this.table.columns * this.table.rows) {\n        tableNode.selectPrevious();\n        // Delete entire table\n        tableNode.remove();\n        const rootNode = $getRoot();\n        rootNode.selectStart();\n        return;\n      }\n      selectedNodes.forEach(cellNode => {\n        if ($isElementNode(cellNode)) {\n          const paragraphNode = $createParagraphNode();\n          const textNode = $createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.table, null);\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  const createMouseHandlers = () => {\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n    const onMouseMove = moveEvent => {\n      const focusCell = getDOMCellFromTarget(moveEvent.target);\n      if (focusCell !== null && (tableObserver.anchorX !== focusCell.x || tableObserver.anchorY !== focusCell.y)) {\n        moveEvent.preventDefault();\n        tableObserver.setFocusCellForSelection(focusCell);\n      }\n    };\n    return {\n      onMouseMove: onMouseMove,\n      onMouseUp: onMouseUp\n    };\n  };\n  tableElement.addEventListener('mousedown', event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n      if (!editorWindow) {\n        return;\n      }\n      const anchorCell = getDOMCellFromTarget(event.target);\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableObserver.setAnchorCellForSelection(anchorCell);\n      }\n      const {\n        onMouseUp,\n        onMouseMove\n      } = createMouseHandlers();\n      tableObserver.isSelecting = true;\n      editorWindow.addEventListener('mouseup', onMouseUp);\n      editorWindow.addEventListener('mousemove', onMouseMove);\n    }, 0);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n    editor.update(() => {\n      const selection = $getSelection();\n      const target = event.target;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback);\n  tableObserver.listenersToRemove.add(() => editorWindow.removeEventListener('mousedown', mouseDownCallback));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findMatchingParent(selection.focus.getNode(), $isTableCellNode);\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.clearText();\n        return true;\n      }\n      const nearestElementNode = $findMatchingParent(selection.anchor.getNode(), n => $isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && $findMatchingParent(nearestElementNode, n => $isElementNode(n) && $isTableCellNode(n.getParent()));\n      if (!$isElementNode(topLevelCellElementNode) || !$isElementNode(nearestElementNode)) {\n        return false;\n      }\n      if (command === DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  [DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_CRITICAL));\n  });\n  const deleteCellHandler = event => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      event.preventDefault();\n      event.stopPropagation();\n      tableObserver.clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  };\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_BACKSPACE_COMMAND, deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_DELETE_COMMAND, deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.formatCells(payload);\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow, focusCell.startRow);\n    const maxColumn = Math.max(anchorCell.startColumn, focusCell.startColumn);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ($isElementNode(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearHighlight();\n      return false;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null) {\n        return false;\n      }\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n      selectTableNodeInDirection(tableObserver, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, COMMAND_PRIORITY_HIGH));\n  function getObserverCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n    return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = $isRangeSelection(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && $findMatchingParent(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor] = anchorAndFocus;\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = $findMatchingParent(anchor.getNode(), n => $isTableCellNode(n));\n    const gridRowNode = gridCellNode && $findMatchingParent(gridCellNode, n => $isTableRowNode(n));\n    const gridNode = gridRowNode && $findMatchingParent(gridRowNode, n => $isTableNode(n));\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    let newAnchorCellKey;\n    let newFocusCellKey;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!$isTableRowNode(currentGridRowNode)) {\n        return false;\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!$isTableRowNode(newGridRowNode)) {\n        return false;\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!$isTableCellNode(currentGridCellNode)) {\n          return false;\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!$isTableCellNode(newGridCellNode)) {\n          return false;\n        }\n        if (r === fromY && c === fromX) {\n          newAnchorCellKey = currentGridCellNode.getKey();\n        } else if (r === toY && c === toX) {\n          newFocusCellKey = currentGridCellNode.getKey();\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach(child => {\n          if ($isTextNode(child)) {\n            const paragraphNode = $createParagraphNode();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    if (newAnchorCellKey && newFocusCellKey) {\n      const newTableSelection = $createTableSelection();\n      newTableSelection.set(nodes[0].getKey(), newAnchorCellKey, newFocusCellKey);\n      $setSelection(newTableSelection);\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n    const selection = $getSelection();\n    const prevSelection = $getPreviousSelection();\n    if ($isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          newSelection.focus.set(tableNode.getParentOrThrow().getKey(), isBackward ? tableNode.getIndexWithinParent() : tableNode.getIndexWithinParent() + 1, 'element');\n        } else {\n          newSelection.anchor.set(tableNode.getParentOrThrow().getKey(), isBackward ? tableNode.getIndexWithinParent() + 1 : tableNode.getIndexWithinParent(), 'element');\n        }\n        $setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.setAnchorCellForSelection(getObserverCellFromCellNode(anchorCellNode));\n          tableObserver.setFocusCellForSelection(getObserverCellFromCellNode(focusCellNode), true);\n          if (!tableObserver.isSelecting) {\n            setTimeout(() => {\n              const {\n                onMouseUp,\n                onMouseMove\n              } = createMouseHandlers();\n              tableObserver.isSelecting = true;\n              editorWindow.addEventListener('mouseup', onMouseUp);\n              editorWindow.addEventListener('mousemove', onMouseMove);\n            }, 0);\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = $getNearestNodeFromDOMNode(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.is($findTableNode(focusNode));\n        const anchorNode = $getNearestNodeFromDOMNode(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.is($findTableNode(anchorNode));\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = $createRangeSelectionFromDom(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTable(tableElement) {\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = $getNearestNodeFromDOMNode(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nconst adjustFocusNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table));\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y - 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y + 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n};\nfunction $isSelectionInTable(selection, tableNode) {\n  if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nconst BROWSER_BLUE_RGB = '172,206,247';\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n  element.style.setProperty('caret-color', 'transparent');\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\nfunction $findCellNode(node) {\n  const cellNode = $findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = $findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  const selection = $getSelection();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if (direction === 'backward' && $isRangeSelection(selection) && selection.isCollapsed()) {\n      const anchorType = selection.anchor.type;\n      const anchorOffset = selection.anchor.offset;\n      if (anchorType !== 'element' && !(anchorType === 'text' && anchorOffset === 0)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n      if (!parentNode) {\n        return false;\n      }\n      const siblingNode = parentNode.getPreviousSibling();\n      if (!siblingNode || !$isTableNode(siblingNode)) {\n        return false;\n      }\n      stopEvent(event);\n      siblingNode.selectEnd();\n      return true;\n    }\n    return false;\n  }\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = editor.getElementByKey(anchorCellTable.getKey());\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTableElement);\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n      }\n    }\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      if (isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)) {\n        return $handleTableExit(event, anchorNode, tableNode, direction);\n      }\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n        tableObserver.setAnchorCellForSelection(cell);\n        tableObserver.setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    const tableElement = editor.getElementByKey(tableNodeFromSelection.getKey());\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.updateTableTableSelection(selection);\n    const grid = getTable(tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, grid);\n      return adjustFocusNodeInDirection(tableObserver, tableNodeFromSelection, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isExitingTableAnchor(type, offset, anchorNode, direction) {\n  return isExitingTableElementAnchor(type, anchorNode, direction) || isExitingTableTextAnchor(type, offset, anchorNode, direction);\n}\nfunction isExitingTableElementAnchor(type, anchorNode, direction) {\n  return type === 'element' && (direction === 'backward' ? anchorNode.getPreviousSibling() === null : anchorNode.getNextSibling() === null);\n}\nfunction isExitingTableTextAnchor(type, offset, anchorNode, direction) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset = direction === 'backward' ? offset === 0 : offset === anchorNode.getTextContentSize();\n  return type === 'text' && hasValidOffset && (direction === 'backward' ? parentNode.getPreviousSibling() === null : parentNode.getNextSibling() === null);\n}\nfunction $handleTableExit(event, anchorNode, tableNode, direction) {\n  const anchorCellNode = $findMatchingParent(anchorNode, $isTableCellNode);\n  if (!$isTableCellNode(anchorCellNode)) {\n    return false;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n  const toNode = getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\nfunction isExitingCell(tableMap, cellValue, direction) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startColumn,\n    startRow\n  } = cellValue;\n  return direction === 'backward' ? startColumn === firstCell.startColumn && startRow === firstCell.startRow : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\nfunction getExitingToNode(anchorNode, direction, tableNode) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling = direction === 'backward' ? parentNode.getPreviousSibling() : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling) ? anchorSibling : direction === 'backward' ? tableNode.getPreviousSibling() : tableNode.getNextSibling();\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = $createParagraphNode();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  // TODO: Add support for nested tables\n  const domSelection = window.getSelection();\n  if (!domSelection || domSelection.anchorNode !== editor.getRootElement()) {\n    return undefined;\n  }\n  const anchorCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = $findMatchingParent(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass TableNode extends ElementNode {\n  static getType() {\n    return 'table';\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(_serializedNode) {\n    return $createTableNode();\n  }\n  constructor(key) {\n    super(key);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'table',\n      version: 1\n    };\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    addClassNamesToElement(tableElement, config.theme.table);\n    return tableElement;\n  }\n  updateDOM() {\n    return false;\n  }\n  exportDOM(editor) {\n    return {\n      ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          if (isHTMLElement(tableElement)) {\n            tBody.append(...tableElement.children);\n          }\n          const firstRow = this.getFirstChildOrThrow();\n          if (!$isTableRowNode(firstRow)) {\n            throw new Error('Expected to find row node.');\n          }\n          const colCount = firstRow.getChildrenSize();\n          for (let i = 0; i < colCount; i++) {\n            const col = document.createElement('col');\n            colGroup.append(col);\n          }\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      const x = row.findIndex(cell => {\n        if (!cell) {\n          return;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const cell = row[x];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = $getNearestNodeFromDOMNode(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n  return getTable(tableElement);\n}\nfunction convertTableElement(_domNode) {\n  return {\n    node: $createTableNode()\n  };\n}\nfunction $createTableNode() {\n  return $applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\nexport { $computeTableMap, $createTableCellNode, $createTableNode, $createTableNodeWithDimensions, $createTableRowNode, $createTableSelection, $deleteTableColumn, $deleteTableColumn__EXPERIMENTAL, $deleteTableRow__EXPERIMENTAL, $getElementForTableNode, $getNodeTriplet, $getTableCellNodeFromLexicalNode, $getTableCellNodeRect, $getTableColumnIndexFromTableCellNode, $getTableNodeFromLexicalNodeOrThrow, $getTableRowIndexFromTableCellNode, $getTableRowNodeFromTableCellNodeOrThrow, $insertTableColumn, $insertTableColumn__EXPERIMENTAL, $insertTableRow, $insertTableRow__EXPERIMENTAL, $isTableCellNode, $isTableNode, $isTableRowNode, $isTableSelection, $removeTableRowAtIndex, $unmergeCell, INSERT_TABLE_COMMAND, TableCellHeaderStates, TableCellNode, TableNode, TableObserver, TableRowNode, applyTableHandlers, getDOMCellFromTarget, getTableObserverFromTableElement };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{addClassNamesToElement as e,$findMatchingParent as t,removeClassNamesFromElement as n,isHTMLElement as o}from\"@lexical/utils\";import{ElementNode as r,$applyNodeReplacement as l,$createParagraphNode as s,$isElementNode as i,$isLineBreakNode as a,$isTextNode as c,createCommand as h,$createTextNode as d,$getSelection as u,$isRangeSelection as g,$normalizeSelection__EXPERIMENTAL as f,$getNodeByKey as m,isCurrentlyReadOnlyMode as p,$createPoint as C,$setSelection as S,SELECTION_CHANGE_COMMAND as _,$getNearestNodeFromDOMNode as w,$createRangeSelection as b,$getRoot as y,KEY_ARROW_DOWN_COMMAND as N,COMMAND_PRIORITY_HIGH as x,KEY_ARROW_UP_COMMAND as T,KEY_ARROW_LEFT_COMMAND as v,KEY_ARROW_RIGHT_COMMAND as E,KEY_ESCAPE_COMMAND as O,DELETE_WORD_COMMAND as M,DELETE_LINE_COMMAND as R,DELETE_CHARACTER_COMMAND as K,COMMAND_PRIORITY_CRITICAL as k,KEY_BACKSPACE_COMMAND as F,KEY_DELETE_COMMAND as H,FORMAT_TEXT_COMMAND as P,FORMAT_ELEMENT_COMMAND as A,CONTROLLED_TEXT_INSERTION_COMMAND as B,KEY_TAB_COMMAND as D,FOCUS_COMMAND as I,SELECTION_INSERT_CLIPBOARD_NODES_COMMAND as L,$getPreviousSelection as W,$createRangeSelectionFromDom as U,INSERT_PARAGRAPH_COMMAND as z}from\"lexical\";const X=/^(\\d+(?:\\.\\d+)?)px$/,Y={BOTH:3,COLUMN:2,NO_STATUS:0,ROW:1};class J extends r{static getType(){return\"tablecell\"}static clone(e){const t=new J(e.__headerState,e.__colSpan,e.__width,e.__key);return t.__rowSpan=e.__rowSpan,t.__backgroundColor=e.__backgroundColor,t}static importDOM(){return{td:e=>({conversion:$,priority:0}),th:e=>({conversion:$,priority:0})}}static importJSON(e){const t=e.colSpan||1,n=e.rowSpan||1,o=j(e.headerState,t,e.width||void 0);return o.__rowSpan=n,o.__backgroundColor=e.backgroundColor||null,o}constructor(e=Y.NO_STATUS,t=1,n,o){super(o),this.__colSpan=t,this.__rowSpan=1,this.__headerState=e,this.__width=n,this.__backgroundColor=null}createDOM(t){const n=document.createElement(this.getTag());return this.__width&&(n.style.width=`${this.__width}px`),this.__colSpan>1&&(n.colSpan=this.__colSpan),this.__rowSpan>1&&(n.rowSpan=this.__rowSpan),null!==this.__backgroundColor&&(n.style.backgroundColor=this.__backgroundColor),e(n,t.theme.tableCell,this.hasHeader()&&t.theme.tableCellHeader),n}exportDOM(e){const{element:t}=super.exportDOM(e);if(t){const e=t,n=700,o=this.getParentOrThrow().getChildrenSize();e.style.border=\"1px solid black\",this.__colSpan>1&&(e.colSpan=this.__colSpan),this.__rowSpan>1&&(e.rowSpan=this.__rowSpan),e.style.width=`${this.getWidth()||Math.max(90,n/o)}px`,e.style.verticalAlign=\"top\",e.style.textAlign=\"start\";const r=this.getBackgroundColor();null!==r?e.style.backgroundColor=r:this.hasHeader()&&(e.style.backgroundColor=\"#f2f3f5\")}return{element:t}}exportJSON(){return{...super.exportJSON(),backgroundColor:this.getBackgroundColor(),colSpan:this.__colSpan,headerState:this.__headerState,rowSpan:this.__rowSpan,type:\"tablecell\",width:this.getWidth()}}getColSpan(){return this.__colSpan}setColSpan(e){return this.getWritable().__colSpan=e,this}getRowSpan(){return this.__rowSpan}setRowSpan(e){return this.getWritable().__rowSpan=e,this}getTag(){return this.hasHeader()?\"th\":\"td\"}setHeaderStyles(e){return this.getWritable().__headerState=e,this.__headerState}getHeaderStyles(){return this.getLatest().__headerState}setWidth(e){return this.getWritable().__width=e,this.__width}getWidth(){return this.getLatest().__width}getBackgroundColor(){return this.getLatest().__backgroundColor}setBackgroundColor(e){this.getWritable().__backgroundColor=e}toggleHeaderStyle(e){const t=this.getWritable();return(t.__headerState&e)===e?t.__headerState-=e:t.__headerState+=e,t}hasHeaderState(e){return(this.getHeaderStyles()&e)===e}hasHeader(){return this.getLatest().__headerState!==Y.NO_STATUS}updateDOM(e){return e.__headerState!==this.__headerState||e.__width!==this.__width||e.__colSpan!==this.__colSpan||e.__rowSpan!==this.__rowSpan||e.__backgroundColor!==this.__backgroundColor}isShadowRoot(){return!0}collapseAtStart(){return!0}canBeEmpty(){return!1}canIndent(){return!1}}function $(e){const t=e,n=e.nodeName.toLowerCase();let o;X.test(t.style.width)&&(o=parseFloat(t.style.width));const r=j(\"th\"===n?Y.ROW:Y.NO_STATUS,t.colSpan,o);r.__rowSpan=t.rowSpan;const l=t.style.backgroundColor;\"\"!==l&&(r.__backgroundColor=l);const h=t.style,d=\"700\"===h.fontWeight||\"bold\"===h.fontWeight,u=\"line-through\"===h.textDecoration,g=\"italic\"===h.fontStyle,f=\"underline\"===h.textDecoration;return{after:e=>(0===e.length&&e.push(s()),e),forChild:(e,t)=>{if(q(t)&&!i(e)){const t=s();return a(e)&&\"\\n\"===e.getTextContent()?null:(c(e)&&(d&&e.toggleFormat(\"bold\"),u&&e.toggleFormat(\"strikethrough\"),g&&e.toggleFormat(\"italic\"),f&&e.toggleFormat(\"underline\")),t.append(e),t)}return e},node:r}}function j(e,t=1,n){return l(new J(e,t,n))}function q(e){return e instanceof J}const G=h(\"INSERT_TABLE_COMMAND\");class Q extends r{static getType(){return\"tablerow\"}static clone(e){return new Q(e.__height,e.__key)}static importDOM(){return{tr:e=>({conversion:V,priority:0})}}static importJSON(e){return Z(e.height)}constructor(e,t){super(t),this.__height=e}exportJSON(){return{...super.exportJSON(),...this.getHeight()&&{height:this.getHeight()},type:\"tablerow\",version:1}}createDOM(t){const n=document.createElement(\"tr\");return this.__height&&(n.style.height=`${this.__height}px`),e(n,t.theme.tableRow),n}isShadowRoot(){return!0}setHeight(e){return this.getWritable().__height=e,this.__height}getHeight(){return this.getLatest().__height}updateDOM(e){return e.__height!==this.__height}canBeEmpty(){return!1}canIndent(){return!1}}function V(e){const t=e;let n;return X.test(t.style.height)&&(n=parseFloat(t.style.height)),{node:Z(n)}}function Z(e){return l(new Q(e))}function ee(e){return e instanceof Q}var te=function(e){const t=new URLSearchParams;t.append(\"code\",e);for(let e=1;e<arguments.length;e++)t.append(\"v\",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)};const ne=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement;function oe(e,t,n=!0){const o=tt();for(let r=0;r<e;r++){const e=Z();for(let o=0;o<t;o++){let t=Y.NO_STATUS;\"object\"==typeof n?(0===r&&n.rows&&(t|=Y.ROW),0===o&&n.columns&&(t|=Y.COLUMN)):n&&(0===r&&(t|=Y.ROW),0===o&&(t|=Y.COLUMN));const l=j(t),i=s();i.append(d()),l.append(i),e.append(l)}o.append(e)}return o}function re(e){const n=t(e,(e=>q(e)));return q(n)?n:null}function le(e){const n=t(e,(e=>ee(e)));if(ee(n))return n;throw new Error(\"Expected table cell to be inside of table row.\")}function se(e){const n=t(e,(e=>nt(e)));if(nt(n))return n;throw new Error(\"Expected table cell to be inside of table.\")}function ie(e){const t=le(e);return se(t).getChildren().findIndex((e=>e.is(t)))}function ae(e){return le(e).getChildren().findIndex((t=>t.is(e)))}function ce(e,t){const n=se(e),{x:o,y:r}=n.getCordsFromCellNode(e,t);return{above:n.getCellNodeFromCords(o,r-1,t),below:n.getCellNodeFromCords(o,r+1,t),left:n.getCellNodeFromCords(o-1,r,t),right:n.getCellNodeFromCords(o+1,r,t)}}function he(e,t){const n=e.getChildren();if(t>=n.length||t<0)throw new Error(\"Expected table cell to be inside of table row.\");return n[t].remove(),e}function de(e,t,n=!0,o,r){const l=e.getChildren();if(t>=l.length||t<0)throw new Error(\"Table row target index out of range\");const i=l[t];if(!ee(i))throw new Error(\"Row before insertion index does not exist.\");for(let e=0;e<o;e++){const e=i.getChildren(),t=e.length,o=Z();for(let n=0;n<t;n++){const t=e[n];q(t)||te(12);const{above:l,below:i}=ce(t,r);let a=Y.NO_STATUS;const c=l&&l.getWidth()||i&&i.getWidth()||void 0;(l&&l.hasHeaderState(Y.COLUMN)||i&&i.hasHeaderState(Y.COLUMN))&&(a|=Y.COLUMN);const h=j(a,1,c);h.append(s()),o.append(h)}n?i.insertAfter(o):i.insertBefore(o)}return e}const ue=(e,t)=>e===Y.BOTH||e===t?t:Y.NO_STATUS;function ge(e=!0){const t=u();g(t)||ve(t)||te(118);const n=t.focus.getNode(),[o,,r]=Ne(n),[l,i]=ye(r,o,o),a=l[0].length,{startRow:c}=i;if(e){const e=c+o.__rowSpan-1,t=l[e],n=Z();for(let o=0;o<a;o++){const{cell:r,startRow:l}=t[o];if(l+r.__rowSpan-1<=e){const e=t[o].cell.__headerState,r=ue(e,Y.COLUMN);n.append(j(r).append(s()))}else r.setRowSpan(r.__rowSpan+1)}const i=r.getChildAtIndex(e);ee(i)||te(145),i.insertAfter(n)}else{const e=l[c],t=Z();for(let n=0;n<a;n++){const{cell:o,startRow:r}=e[n];if(r===c){const o=e[n].cell.__headerState,r=ue(o,Y.COLUMN);t.append(j(r).append(s()))}else o.setRowSpan(o.__rowSpan+1)}const n=r.getChildAtIndex(c);ee(n)||te(145),n.insertBefore(t)}}function fe(e,t,n=!0,o,r){const l=e.getChildren(),i=[];for(let e=0;e<l.length;e++){const n=l[e];if(ee(n))for(let e=0;e<o;e++){const e=n.getChildren();if(t>=e.length||t<0)throw new Error(\"Table column target index out of range\");const o=e[t];q(o)||te(12);const{left:l,right:a}=ce(o,r);let c=Y.NO_STATUS;(l&&l.hasHeaderState(Y.ROW)||a&&a.hasHeaderState(Y.ROW))&&(c|=Y.ROW);const h=j(c);h.append(s()),i.push({newTableCell:h,targetCell:o})}}return i.forEach((({newTableCell:e,targetCell:t})=>{n?t.insertAfter(e):t.insertBefore(e)})),e}function me(e=!0){const t=u();g(t)||ve(t)||te(118);const n=t.anchor.getNode(),o=t.focus.getNode(),[r]=Ne(n),[l,,i]=Ne(o),[a,c,h]=ye(i,l,r),d=a.length,f=e?Math.max(c.startColumn,h.startColumn):Math.min(c.startColumn,h.startColumn),m=e?f+l.__colSpan-1:f-1,p=i.getFirstChild();ee(p)||te(120);let C=null;function S(e=Y.NO_STATUS){const t=j(e).append(s());return null===C&&(C=t),t}let _=p;e:for(let e=0;e<d;e++){if(0!==e){const e=_.getNextSibling();ee(e)||te(121),_=e}const t=a[e],n=t[m<0?0:m].cell.__headerState,o=ue(n,Y.ROW);if(m<0){we(_,S(o));continue}const{cell:r,startColumn:l,startRow:s}=t[m];if(l+r.__colSpan-1<=m){let n=r,l=s,i=m;for(;l!==e&&n.__rowSpan>1;){if(i-=r.__colSpan,!(i>=0)){_.append(S(o));continue e}{const{cell:e,startRow:o}=t[i];n=e,l=o}}n.insertAfter(S(o))}else r.setColSpan(r.__colSpan+1)}null!==C&&_e(C)}function pe(e,t){const n=e.getChildren();for(let e=0;e<n.length;e++){const o=n[e];if(ee(o)){const e=o.getChildren();if(t>=e.length||t<0)throw new Error(\"Table column target index out of range\");e[t].remove()}}return e}function Ce(){const e=u();g(e)||ve(e)||te(118);const t=e.anchor.getNode(),n=e.focus.getNode(),[o,,r]=Ne(t),[l]=Ne(n),[s,i,a]=ye(r,o,l),{startRow:c}=i,{startRow:h}=a,d=h+l.__rowSpan-1;if(s.length===d-c+1)return void r.remove();const f=s[0].length,m=s[d+1],p=r.getChildAtIndex(d+1);for(let e=d;e>=c;e--){for(let t=f-1;t>=0;t--){const{cell:n,startRow:o,startColumn:r}=s[e][t];if(r===t&&(e===c&&o<c&&n.setRowSpan(n.__rowSpan-(o-c)),o>=c&&o+n.__rowSpan-1>d))if(n.setRowSpan(n.__rowSpan-(d-o+1)),null===p&&te(122),0===t)we(p,n);else{const{cell:e}=m[t-1];e.insertAfter(n)}}const t=r.getChildAtIndex(e);ee(t)||te(123,String(e)),t.remove()}if(void 0!==m){const{cell:e}=m[0];_e(e)}else{const e=s[c-1],{cell:t}=e[0];_e(t)}}function Se(){const e=u();g(e)||ve(e)||te(118);const t=e.anchor.getNode(),n=e.focus.getNode(),[o,,r]=Ne(t),[l]=Ne(n),[s,i,a]=ye(r,o,l),{startColumn:c}=i,{startRow:h,startColumn:d}=a,f=Math.min(c,d),m=Math.max(c+o.__colSpan-1,d+l.__colSpan-1),p=m-f+1;if(s[0].length===m-f+1)return r.selectPrevious(),void r.remove();const C=s.length;for(let e=0;e<C;e++)for(let t=f;t<=m;t++){const{cell:n,startColumn:o}=s[e][t];if(o<f){if(t===f){const e=f-o;n.setColSpan(n.__colSpan-Math.min(p,n.__colSpan-e))}}else if(o+n.__colSpan-1>m){if(t===m){const e=m-o+1;n.setColSpan(n.__colSpan-e)}}else n.remove()}const S=s[h],_=S[d+l.__colSpan];if(void 0!==_){const{cell:e}=_;_e(e)}else{const e=S[d-1],{cell:t}=e;_e(t)}}function _e(e){const t=e.getFirstDescendant();null==t?e.selectStart():t.getParentOrThrow().selectStart()}function we(e,t){const n=e.getFirstChild();null!==n?n.insertBefore(t):e.append(t)}function be(){const e=u();g(e)||ve(e)||te(118);const t=e.anchor.getNode(),[n,o,r]=Ne(t),l=n.__colSpan,s=n.__rowSpan;if(l>1){for(let e=1;e<l;e++)n.insertAfter(j(Y.NO_STATUS));n.setColSpan(1)}if(s>1){const[e,t]=ye(r,n,n),{startColumn:i,startRow:a}=t;let c;for(let t=1;t<s;t++){const n=a+t,r=e[n];c=(c||o).getNextSibling(),ee(c)||te(125);let s=null;for(let e=0;e<i;e++){const t=r[e],o=t.cell;t.startRow===n&&(s=o),o.__colSpan>1&&(e+=o.__colSpan-1)}if(null===s)for(let e=0;e<l;e++)we(c,j(Y.NO_STATUS));else for(let e=0;e<l;e++)s.insertAfter(j(Y.NO_STATUS))}n.setRowSpan(1)}}function ye(e,t,n){const o=[];let r=null,l=null;function s(e,s,i){const a={cell:i,startColumn:s,startRow:e},c=i.__rowSpan,h=i.__colSpan;for(let t=0;t<c;t++){void 0===o[e+t]&&(o[e+t]=[]);for(let n=0;n<h;n++)o[e+t][s+n]=a}t.is(i)&&(r=a),n.is(i)&&(l=a)}function i(e,t){return void 0===o[e]||void 0===o[e][t]}const a=e.getChildren();for(let e=0;e<a.length;e++){const t=a[e];ee(t)||te(146);const n=t.getChildren();let o=0;for(const t of n){for(q(t)||te(147);!i(e,o);)o++;s(e,o,t),o+=t.__colSpan}}return null===r&&te(110),null===l&&te(111),[o,r,l]}function Ne(e){let n;if(e instanceof J)n=e;else if(\"__type\"in e){const o=t(e,q);q(o)||te(148),n=o}else{const o=t(e.getNode(),q);q(o)||te(148),n=o}const o=n.getParent();ee(o)||te(149);const r=o.getParent();return nt(r)||te(150),[n,o,r]}function xe(e){const[t,,n]=Ne(e),o=n.getChildren(),r=o.length,l=o[0].getChildren().length,s=new Array(r);for(let e=0;e<r;e++)s[e]=new Array(l);for(let e=0;e<r;e++){const n=o[e].getChildren();let r=0;for(let o=0;o<n.length;o++){for(;s[e][r];)r++;const l=n[o],i=l.__rowSpan||1,a=l.__colSpan||1;for(let t=0;t<i;t++)for(let n=0;n<a;n++)s[e+t][r+n]=l;if(t===l)return{colSpan:a,columnIndex:r,rowIndex:e,rowSpan:i};r+=a}}return null}class Te{constructor(e,t,n){this.anchor=t,this.focus=n,t._selection=this,n._selection=this,this._cachedNodes=null,this.dirty=!1,this.tableKey=e}getStartEndPoints(){return[this.anchor,this.focus]}isBackward(){return this.focus.isBefore(this.anchor)}getCachedNodes(){return this._cachedNodes}setCachedNodes(e){this._cachedNodes=e}is(e){return!!ve(e)&&(this.tableKey===e.tableKey&&this.anchor.is(e.anchor)&&this.focus.is(e.focus))}set(e,t,n){this.dirty=!0,this.tableKey=e,this.anchor.key=t,this.focus.key=n,this._cachedNodes=null}clone(){return new Te(this.tableKey,this.anchor,this.focus)}isCollapsed(){return!1}extract(){return this.getNodes()}insertRawText(e){}insertText(){}insertNodes(e){const t=this.focus.getNode();i(t)||te(151);f(t.select(0,t.getChildrenSize())).insertNodes(e)}getShape(){const e=m(this.anchor.key);q(e)||te(152);const t=xe(e);null===t&&te(153);const n=m(this.focus.key);q(n)||te(154);const o=xe(n);null===o&&te(155);const r=Math.min(t.columnIndex,o.columnIndex),l=Math.max(t.columnIndex,o.columnIndex),s=Math.min(t.rowIndex,o.rowIndex),i=Math.max(t.rowIndex,o.rowIndex);return{fromX:Math.min(r,l),fromY:Math.min(s,i),toX:Math.max(r,l),toY:Math.max(s,i)}}getNodes(){const e=this._cachedNodes;if(null!==e)return e;const n=this.anchor.getNode(),o=this.focus.getNode(),r=t(n,q),l=t(o,q);q(r)||te(152),q(l)||te(154);const s=r.getParent();ee(s)||te(156);const i=s.getParent();nt(i)||te(157);const a=l.getParents()[1];if(a!==i){if(i.isParentOf(l)){const e=a.getParent();null==e&&te(159),this.set(this.tableKey,l.getKey(),e.getKey())}else{const e=i.getParent();null==e&&te(158),this.set(this.tableKey,e.getKey(),l.getKey())}return this.getNodes()}const[c,h,d]=ye(i,r,l);let u=Math.min(h.startColumn,d.startColumn),g=Math.min(h.startRow,d.startRow),f=Math.max(h.startColumn+h.cell.__colSpan-1,d.startColumn+d.cell.__colSpan-1),m=Math.max(h.startRow+h.cell.__rowSpan-1,d.startRow+d.cell.__rowSpan-1),C=u,S=g,_=u,w=g;function b(e){const{cell:t,startColumn:n,startRow:o}=e;u=Math.min(u,n),g=Math.min(g,o),f=Math.max(f,n+t.__colSpan-1),m=Math.max(m,o+t.__rowSpan-1)}for(;u<C||g<S||f>_||m>w;){if(u<C){const e=w-S,t=C-1;for(let n=0;n<=e;n++)b(c[S+n][t]);C=t}if(g<S){const e=_-C,t=S-1;for(let n=0;n<=e;n++)b(c[t][C+n]);S=t}if(f>_){const e=w-S,t=_+1;for(let n=0;n<=e;n++)b(c[S+n][t]);_=t}if(m>w){const e=_-C,t=w+1;for(let n=0;n<=e;n++)b(c[t][C+n]);w=t}}const y=[i];let N=null;for(let e=g;e<=m;e++)for(let t=u;t<=f;t++){const{cell:n}=c[e][t],o=n.getParent();ee(o)||te(160),o!==N&&y.push(o),y.push(n,...Oe(n)),N=o}return p()||(this._cachedNodes=y),y}getTextContent(){const e=this.getNodes();let t=\"\";for(let n=0;n<e.length;n++)t+=e[n].getTextContent();return t}}function ve(e){return e instanceof Te}function Ee(){const e=C(\"root\",0,\"element\"),t=C(\"root\",0,\"element\");return new Te(\"root\",e,t)}function Oe(e){const t=[],n=[e];for(;n.length>0;){const o=n.pop();void 0===o&&te(112),i(o)&&n.unshift(...o.getChildren()),o!==e&&t.push(o)}return t}class Me{constructor(e,t){this.isHighlightingCells=!1,this.anchorX=-1,this.anchorY=-1,this.focusX=-1,this.focusY=-1,this.listenersToRemove=new Set,this.tableNodeKey=t,this.editor=e,this.table={columns:0,domRows:[],rows:0},this.tableSelection=null,this.anchorCellNodeKey=null,this.focusCellNodeKey=null,this.anchorCell=null,this.focusCell=null,this.hasHijackedSelectionStyles=!1,this.trackTable(),this.isSelecting=!1}getTable(){return this.table}removeListeners(){Array.from(this.listenersToRemove).forEach((e=>e()))}trackTable(){const e=new MutationObserver((e=>{this.editor.update((()=>{let t=!1;for(let n=0;n<e.length;n++){const o=e[n].target.nodeName;if(\"TABLE\"===o||\"TR\"===o){t=!0;break}}if(!t)return;const n=this.editor.getElementByKey(this.tableNodeKey);if(!n)throw new Error(\"Expected to find TableElement in DOM\");this.table=Pe(n)}))}));this.editor.update((()=>{const t=this.editor.getElementByKey(this.tableNodeKey);if(!t)throw new Error(\"Expected to find TableElement in DOM\");this.table=Pe(t),e.observe(t,{childList:!0,subtree:!0})}))}clearHighlight(){const e=this.editor;this.isHighlightingCells=!1,this.anchorX=-1,this.anchorY=-1,this.focusX=-1,this.focusY=-1,this.tableSelection=null,this.anchorCellNodeKey=null,this.focusCellNodeKey=null,this.anchorCell=null,this.focusCell=null,this.hasHijackedSelectionStyles=!1,this.enableHighlightStyle(),e.update((()=>{if(!nt(m(this.tableNodeKey)))throw new Error(\"Expected TableNode.\");const t=e.getElementByKey(this.tableNodeKey);if(!t)throw new Error(\"Expected to find TableElement in DOM\");const n=Pe(t);Ae(e,n,null),S(null),e.dispatchCommand(_,void 0)}))}enableHighlightStyle(){const e=this.editor;e.update((()=>{const t=e.getElementByKey(this.tableNodeKey);if(!t)throw new Error(\"Expected to find TableElement in DOM\");n(t,e._config.theme.tableSelection),t.classList.remove(\"disable-selection\"),this.hasHijackedSelectionStyles=!1}))}disableHighlightStyle(){const t=this.editor;t.update((()=>{const n=t.getElementByKey(this.tableNodeKey);if(!n)throw new Error(\"Expected to find TableElement in DOM\");e(n,t._config.theme.tableSelection),this.hasHijackedSelectionStyles=!0}))}updateTableTableSelection(e){if(null!==e&&e.tableKey===this.tableNodeKey){const t=this.editor;this.tableSelection=e,this.isHighlightingCells=!0,this.disableHighlightStyle(),Ae(t,this.table,this.tableSelection)}else null==e?this.clearHighlight():(this.tableNodeKey=e.tableKey,this.updateTableTableSelection(e))}setFocusCellForSelection(e,t=!1){const n=this.editor;n.update((()=>{const o=m(this.tableNodeKey);if(!nt(o))throw new Error(\"Expected TableNode.\");if(!n.getElementByKey(this.tableNodeKey))throw new Error(\"Expected to find TableElement in DOM\");const r=e.x,l=e.y;if(this.focusCell=e,null!==this.anchorCell){const e=Ke(n._window);e&&e.setBaseAndExtent(this.anchorCell.elem,0,this.focusCell.elem,0)}if(this.isHighlightingCells||this.anchorX===r&&this.anchorY===l&&!t){if(r===this.focusX&&l===this.focusY)return}else this.isHighlightingCells=!0,this.disableHighlightStyle();if(this.focusX=r,this.focusY=l,this.isHighlightingCells){const t=w(e.elem);if(null!=this.tableSelection&&null!=this.anchorCellNodeKey&&q(t)&&o.is($e(t))){const e=t.getKey();this.tableSelection=this.tableSelection.clone()||Ee(),this.focusCellNodeKey=e,this.tableSelection.set(this.tableNodeKey,this.anchorCellNodeKey,this.focusCellNodeKey),S(this.tableSelection),n.dispatchCommand(_,void 0),Ae(n,this.table,this.tableSelection)}}}))}setAnchorCellForSelection(e){this.isHighlightingCells=!1,this.anchorCell=e,this.anchorX=e.x,this.anchorY=e.y,this.editor.update((()=>{const t=w(e.elem);if(q(t)){const e=t.getKey();this.tableSelection=null!=this.tableSelection?this.tableSelection.clone():Ee(),this.anchorCellNodeKey=e}}))}formatCells(e){this.editor.update((()=>{const t=u();ve(t)||te(11);const n=b(),o=n.anchor,r=n.focus;t.getNodes().forEach((t=>{q(t)&&0!==t.getTextContentSize()&&(o.set(t.getKey(),0,\"element\"),r.set(t.getKey(),t.getChildrenSize(),\"element\"),n.formatText(e))})),S(t),this.editor.dispatchCommand(_,void 0)}))}clearText(){const e=this.editor;e.update((()=>{const t=m(this.tableNodeKey);if(!nt(t))throw new Error(\"Expected TableNode.\");const n=u();ve(n)||te(11);const o=n.getNodes().filter(q);if(o.length!==this.table.columns*this.table.rows)o.forEach((e=>{if(i(e)){const t=s(),n=d();t.append(n),e.append(t),e.getChildren().forEach((e=>{e!==t&&e.remove()}))}})),Ae(e,this.table,null),S(null),e.dispatchCommand(_,void 0);else{t.selectPrevious(),t.remove();y().selectStart()}}))}}const Re=\"__lexicalTableSelection\",Ke=e=>ne?(e||window).getSelection():null;function ke(e,n,o,r){const l=o.getRootElement();if(null===l)throw new Error(\"No root element.\");const a=new Me(o,e.getKey()),h=o._window||window;!function(e,t){e[Re]=t}(n,a);const f=()=>{const e=()=>{a.isSelecting=!1,h.removeEventListener(\"mouseup\",e),h.removeEventListener(\"mousemove\",t)},t=e=>{const t=He(e.target);null===t||a.anchorX===t.x&&a.anchorY===t.y||(e.preventDefault(),a.setFocusCellForSelection(t))};return{onMouseMove:t,onMouseUp:e}};n.addEventListener(\"mousedown\",(e=>{setTimeout((()=>{if(0!==e.button)return;if(!h)return;const t=He(e.target);null!==t&&(qe(e),a.setAnchorCellForSelection(t));const{onMouseUp:n,onMouseMove:o}=f();a.isSelecting=!0,h.addEventListener(\"mouseup\",n),h.addEventListener(\"mousemove\",o)}),0)}));const m=e=>{0===e.button&&o.update((()=>{const t=u(),n=e.target;ve(t)&&t.tableKey===a.tableNodeKey&&l.contains(n)&&a.clearHighlight()}))};h.addEventListener(\"mousedown\",m),a.listenersToRemove.add((()=>h.removeEventListener(\"mousedown\",m))),a.listenersToRemove.add(o.registerCommand(N,(t=>je(o,t,\"down\",e,a)),x)),a.listenersToRemove.add(o.registerCommand(T,(t=>je(o,t,\"up\",e,a)),x)),a.listenersToRemove.add(o.registerCommand(v,(t=>je(o,t,\"backward\",e,a)),x)),a.listenersToRemove.add(o.registerCommand(E,(t=>je(o,t,\"forward\",e,a)),x)),a.listenersToRemove.add(o.registerCommand(O,(e=>{const n=u();if(ve(n)){const o=t(n.focus.getNode(),q);if(q(o))return qe(e),o.selectEnd(),!0}return!1}),x));[M,R,K].forEach((n=>{a.listenersToRemove.add(o.registerCommand(n,(n=>()=>{const o=u();if(!We(o,e))return!1;if(ve(o))return a.clearText(),!0;if(g(o)){const r=t(o.anchor.getNode(),(e=>q(e)));if(!q(r))return!1;const l=o.anchor.getNode(),s=o.focus.getNode(),c=e.isParentOf(l),h=e.isParentOf(s);if(c&&!h||h&&!c)return a.clearText(),!0;const d=t(o.anchor.getNode(),(e=>i(e))),u=d&&t(d,(e=>i(e)&&q(e.getParent())));if(!i(u)||!i(d))return!1;if(n===R&&null===u.getPreviousSibling())return!0}return!1})(n),k))}));const p=n=>{const o=u();if(!We(o,e))return!1;if(ve(o))return n.preventDefault(),n.stopPropagation(),a.clearText(),!0;if(g(o)){const e=t(o.anchor.getNode(),(e=>q(e)));if(!q(e))return!1}return!1};function C(t){const n=e.getCordsFromCellNode(t,a.table);return e.getDOMCellFromCordsOrThrow(n.x,n.y,a.table)}return a.listenersToRemove.add(o.registerCommand(F,p,k)),a.listenersToRemove.add(o.registerCommand(H,p,k)),a.listenersToRemove.add(o.registerCommand(P,(n=>{const o=u();if(!We(o,e))return!1;if(ve(o))return a.formatCells(n),!0;if(g(o)){const e=t(o.anchor.getNode(),(e=>q(e)));if(!q(e))return!1}return!1}),k)),a.listenersToRemove.add(o.registerCommand(A,(t=>{const n=u();if(!ve(n)||!We(n,e))return!1;const o=n.anchor.getNode(),r=n.focus.getNode();if(!q(o)||!q(r))return!1;const[l,s,a]=ye(e,o,r),c=Math.max(s.startRow,a.startRow),h=Math.max(s.startColumn,a.startColumn),d=Math.min(s.startRow,a.startRow),g=Math.min(s.startColumn,a.startColumn);for(let e=d;e<=c;e++)for(let n=g;n<=h;n++){const o=l[e][n].cell;o.setFormat(t);const r=o.getChildren();for(let e=0;e<r.length;e++){const n=r[e];i(n)&&!n.isInline()&&n.setFormat(t)}}return!0}),k)),a.listenersToRemove.add(o.registerCommand(B,(n=>{const r=u();if(!We(r,e))return!1;if(ve(r))return a.clearHighlight(),!1;if(g(r)){const l=t(r.anchor.getNode(),(e=>q(e)));if(!q(l))return!1;if(\"string\"==typeof n){const t=Qe(o,r,e);if(t)return Ge(t,e,[d(n)]),!0}}return!1}),k)),r&&a.listenersToRemove.add(o.registerCommand(D,(t=>{const n=u();if(!g(n)||!n.isCollapsed()||!We(n,e))return!1;const o=Je(n.anchor.getNode());if(null===o)return!1;qe(t);const r=e.getCordsFromCellNode(o,a.table);return Ie(a,e,r.x,r.y,t.shiftKey?\"backward\":\"forward\"),!0}),k)),a.listenersToRemove.add(o.registerCommand(I,(t=>e.isSelected()),x)),a.listenersToRemove.add(o.registerCommand(L,(e=>{const{nodes:n,selection:o}=e,r=o.getStartEndPoints(),l=ve(o),i=g(o)&&null!==t(o.anchor.getNode(),(e=>q(e)))&&null!==t(o.focus.getNode(),(e=>q(e)))||l;if(1!==n.length||!nt(n[0])||!i||null===r)return!1;const[a]=r,h=n[0],d=h.getChildren(),u=h.getFirstChildOrThrow().getChildrenSize(),f=h.getChildrenSize(),m=t(a.getNode(),(e=>q(e))),p=m&&t(m,(e=>ee(e))),C=p&&t(p,(e=>nt(e)));if(!q(m)||!ee(p)||!nt(C))return!1;const _=p.getIndexWithinParent(),w=Math.min(C.getChildrenSize()-1,_+f-1),b=m.getIndexWithinParent(),y=Math.min(p.getChildrenSize()-1,b+u-1),N=Math.min(b,y),x=Math.min(_,w),T=Math.max(b,y),v=Math.max(_,w),E=C.getChildren();let O,M,R=0;for(let e=x;e<=v;e++){const t=E[e];if(!ee(t))return!1;const n=d[R];if(!ee(n))return!1;const o=t.getChildren(),r=n.getChildren();let l=0;for(let t=N;t<=T;t++){const n=o[t];if(!q(n))return!1;const i=r[l];if(!q(i))return!1;e===x&&t===N?O=n.getKey():e===v&&t===T&&(M=n.getKey());const a=n.getChildren();i.getChildren().forEach((e=>{if(c(e)){s().append(e),n.append(e)}else n.append(e)})),a.forEach((e=>e.remove())),l++}R++}if(O&&M){const e=Ee();e.set(n[0].getKey(),O,M),S(e)}return!0}),k)),a.listenersToRemove.add(o.registerCommand(_,(()=>{const t=u(),n=W();if(g(t)){const{anchor:n,focus:r}=t,l=n.getNode(),s=r.getNode(),i=Je(l),c=Je(s),d=!(!i||!e.is($e(i))),u=!(!c||!e.is($e(c))),g=d!==u,m=d&&u,p=t.isBackward();if(g){const n=t.clone();u?n.focus.set(e.getParentOrThrow().getKey(),p?e.getIndexWithinParent():e.getIndexWithinParent()+1,\"element\"):n.anchor.set(e.getParentOrThrow().getKey(),p?e.getIndexWithinParent()+1:e.getIndexWithinParent(),\"element\"),S(n),De(o,a)}else m&&(i.is(c)||(a.setAnchorCellForSelection(C(i)),a.setFocusCellForSelection(C(c),!0),a.isSelecting||setTimeout((()=>{const{onMouseUp:e,onMouseMove:t}=f();a.isSelecting=!0,h.addEventListener(\"mouseup\",e),h.addEventListener(\"mousemove\",t)}),0)))}else if(t&&ve(t)&&t.is(n)&&t.tableKey===e.getKey()){const n=Ke(o._window);if(n&&n.anchorNode&&n.focusNode){const r=w(n.focusNode),l=r&&!e.is($e(r)),s=w(n.anchorNode),i=s&&e.is($e(s));if(l&&i&&n.rangeCount>0){const r=U(n,o);r&&(r.anchor.set(e.getKey(),t.isBackward()?e.getChildrenSize():0,\"element\"),n.removeAllRanges(),S(r))}}}return t&&!t.is(n)&&(ve(t)||ve(n))&&a.tableSelection&&!a.tableSelection.is(n)?(ve(t)&&t.tableKey===a.tableNodeKey?a.updateTableTableSelection(t):!ve(t)&&ve(n)&&n.tableKey===a.tableNodeKey&&a.updateTableTableSelection(null),!1):(a.hasHijackedSelectionStyles&&!e.isSelected()?function(e,t){t.enableHighlightStyle(),Be(t.table,(t=>{const n=t.elem;t.highlighted=!1,Ye(e,t),n.getAttribute(\"style\")||n.removeAttribute(\"style\")}))}(o,a):!a.hasHijackedSelectionStyles&&e.isSelected()&&De(o,a),!1)}),k)),a.listenersToRemove.add(o.registerCommand(z,(()=>{const t=u();if(!g(t)||!t.isCollapsed()||!We(t,e))return!1;const n=Qe(o,t,e);return!!n&&(Ge(n,e),!0)}),k)),a}function Fe(e){return e[Re]}function He(e){let t=e;for(;null!=t;){const e=t.nodeName;if(\"TD\"===e||\"TH\"===e){const e=t._cell;return void 0===e?null:e}t=t.parentNode}return null}function Pe(e){const t=[],n={columns:0,domRows:t,rows:0};let o=e.firstChild,r=0,l=0;for(t.length=0;null!=o;){const e=o.nodeName;if(\"TD\"===e||\"TH\"===e){const e={elem:o,hasBackgroundColor:\"\"!==o.style.backgroundColor,highlighted:!1,x:r,y:l};o._cell=e;let n=t[l];void 0===n&&(n=t[l]=[]),n[r]=e}else{const e=o.firstChild;if(null!=e){o=e;continue}}const n=o.nextSibling;if(null!=n){r++,o=n;continue}const s=o.parentNode;if(null!=s){const e=s.nextSibling;if(null==e)break;l++,r=0,o=e}}return n.columns=r+1,n.rows=l+1,n}function Ae(e,t,n){const o=new Set(n?n.getNodes():[]);Be(t,((t,n)=>{const r=t.elem;o.has(n)?(t.highlighted=!0,Xe(e,t)):(t.highlighted=!1,Ye(e,t),r.getAttribute(\"style\")||r.removeAttribute(\"style\"))}))}function Be(e,t){const{domRows:n}=e;for(let e=0;e<n.length;e++){const o=n[e];if(o)for(let n=0;n<o.length;n++){const r=o[n];if(!r)continue;const l=w(r.elem);null!==l&&t(r,l,{x:n,y:e})}}}function De(e,t){t.disableHighlightStyle(),Be(t.table,(t=>{t.highlighted=!0,Xe(e,t)}))}const Ie=(e,t,n,o,r)=>{const l=\"forward\"===r;switch(r){case\"backward\":case\"forward\":return n!==(l?e.table.columns-1:0)?Ue(t.getCellNodeFromCordsOrThrow(n+(l?1:-1),o,e.table),l):o!==(l?e.table.rows-1:0)?Ue(t.getCellNodeFromCordsOrThrow(l?0:e.table.columns-1,o+(l?1:-1),e.table),l):l?t.selectNext():t.selectPrevious(),!0;case\"up\":return 0!==o?Ue(t.getCellNodeFromCordsOrThrow(n,o-1,e.table),!1):t.selectPrevious(),!0;case\"down\":return o!==e.table.rows-1?Ue(t.getCellNodeFromCordsOrThrow(n,o+1,e.table),!0):t.selectNext(),!0;default:return!1}},Le=(e,t,n,o,r)=>{const l=\"forward\"===r;switch(r){case\"backward\":case\"forward\":return n!==(l?e.table.columns-1:0)&&e.setFocusCellForSelection(t.getDOMCellFromCordsOrThrow(n+(l?1:-1),o,e.table)),!0;case\"up\":return 0!==o&&(e.setFocusCellForSelection(t.getDOMCellFromCordsOrThrow(n,o-1,e.table)),!0);case\"down\":return o!==e.table.rows-1&&(e.setFocusCellForSelection(t.getDOMCellFromCordsOrThrow(n,o+1,e.table)),!0);default:return!1}};function We(e,t){if(g(e)||ve(e)){const n=t.isParentOf(e.anchor.getNode()),o=t.isParentOf(e.focus.getNode());return n&&o}return!1}function Ue(e,t){t?e.selectStart():e.selectEnd()}const ze=\"172,206,247\";function Xe(e,t){const n=t.elem,o=w(n);q(o)||te(131);null===o.getBackgroundColor()?n.style.setProperty(\"background-color\",`rgb(${ze})`):n.style.setProperty(\"background-image\",`linear-gradient(to right, rgba(${ze},0.85), rgba(${ze},0.85))`),n.style.setProperty(\"caret-color\",\"transparent\")}function Ye(e,t){const n=t.elem,o=w(n);q(o)||te(131);null===o.getBackgroundColor()&&n.style.removeProperty(\"background-color\"),n.style.removeProperty(\"background-image\"),n.style.removeProperty(\"caret-color\")}function Je(e){const n=t(e,q);return q(n)?n:null}function $e(e){const n=t(e,nt);return nt(n)?n:null}function je(e,n,o,r,l){const s=u();if(!We(s,r)){if(\"backward\"===o&&g(s)&&s.isCollapsed()){const e=s.anchor.type,o=s.anchor.offset;if(\"element\"!==e&&(\"text\"!==e||0!==o))return!1;const r=s.anchor.getNode();if(!r)return!1;const l=t(r,(e=>i(e)&&!e.isInline()));if(!l)return!1;const a=l.getPreviousSibling();return!(!a||!nt(a))&&(qe(n),a.selectEnd(),!0)}return!1}if(g(s)&&s.isCollapsed()){const{anchor:a,focus:c}=s,h=t(a.getNode(),q),d=t(c.getNode(),q);if(!q(h)||!h.is(d))return!1;const u=$e(h);if(u!==r&&null!=u){const t=e.getElementByKey(u.getKey());if(null!=t)return l.table=Pe(t),je(e,n,o,u,l)}if(\"backward\"===o||\"forward\"===o){const e=a.type,l=a.offset,s=a.getNode();return!!s&&(!!function(e,n,o,r){return function(e,t,n){return\"element\"===e&&(\"backward\"===n?null===t.getPreviousSibling():null===t.getNextSibling())}(e,o,r)||function(e,n,o,r){const l=t(o,(e=>i(e)&&!e.isInline()));if(!l)return!1;const s=\"backward\"===r?0===n:n===o.getTextContentSize();return\"text\"===e&&s&&(\"backward\"===r?null===l.getPreviousSibling():null===l.getNextSibling())}(e,n,o,r)}(e,l,s,o)&&function(e,n,o,r){const l=t(n,q);if(!q(l))return!1;const[s,a]=ye(o,l,l);if(!function(e,t,n){const o=e[0][0],r=e[e.length-1][e[0].length-1],{startColumn:l,startRow:s}=t;return\"backward\"===n?l===o.startColumn&&s===o.startRow:l===r.startColumn&&s===r.startRow}(s,a,r))return!1;const c=function(e,n,o){const r=t(e,(e=>i(e)&&!e.isInline()));if(!r)return;const l=\"backward\"===n?r.getPreviousSibling():r.getNextSibling();return l&&nt(l)?l:\"backward\"===n?o.getPreviousSibling():o.getNextSibling()}(n,r,o);if(!c||nt(c))return!1;qe(e),\"backward\"===r?c.selectEnd():c.selectStart();return!0}(n,s,r,o))}const g=e.getElementByKey(h.__key),f=e.getElementByKey(a.key);if(null==f||null==g)return!1;let m;if(\"element\"===a.type)m=f.getBoundingClientRect();else{const e=window.getSelection();if(null===e||0===e.rangeCount)return!1;m=e.getRangeAt(0).getBoundingClientRect()}const p=\"up\"===o?h.getFirstChild():h.getLastChild();if(null==p)return!1;const C=e.getElementByKey(p.__key);if(null==C)return!1;const S=C.getBoundingClientRect();if(\"up\"===o?S.top>m.top-m.height:m.bottom+m.height>S.bottom){qe(n);const e=r.getCordsFromCellNode(h,l.table);if(!n.shiftKey)return Ie(l,r,e.x,e.y,o);{const t=r.getDOMCellFromCordsOrThrow(e.x,e.y,l.table);l.setAnchorCellForSelection(t),l.setFocusCellForSelection(t,!0)}return!0}}else if(ve(s)){const{anchor:i,focus:a}=s,c=t(i.getNode(),q),h=t(a.getNode(),q),[d]=s.getNodes(),u=e.getElementByKey(d.getKey());if(!q(c)||!q(h)||!nt(d)||null==u)return!1;l.updateTableTableSelection(s);const g=Pe(u),f=r.getCordsFromCellNode(c,g),m=r.getDOMCellFromCordsOrThrow(f.x,f.y,g);if(l.setAnchorCellForSelection(m),qe(n),n.shiftKey){const e=r.getCordsFromCellNode(h,g);return Le(l,d,e.x,e.y,o)}return h.selectEnd(),!0}return!1}function qe(e){e.preventDefault(),e.stopImmediatePropagation(),e.stopPropagation()}function Ge(e,t,n){const o=s();\"first\"===e?t.insertBefore(o):t.insertAfter(o),o.append(...n||[]),o.selectEnd()}function Qe(e,n,o){const r=window.getSelection();if(!r||r.anchorNode!==e.getRootElement())return;const l=t(n.anchor.getNode(),(e=>q(e)));if(!l)return;const s=t(l,(e=>nt(e)));if(!nt(s)||!s.is(o))return;const[i,a]=ye(o,l,l),c=i[0][0],h=i[i.length-1][i[0].length-1],{startRow:d,startColumn:u}=a,g=d===c.startRow&&u===c.startColumn,f=d===h.startRow&&u===h.startColumn;return g?\"first\":f?\"last\":void 0}class Ve extends r{static getType(){return\"table\"}static clone(e){return new Ve(e.__key)}static importDOM(){return{table:e=>({conversion:et,priority:1})}}static importJSON(e){return tt()}constructor(e){super(e)}exportJSON(){return{...super.exportJSON(),type:\"table\",version:1}}createDOM(t,n){const o=document.createElement(\"table\");return e(o,t.theme.table),o}updateDOM(){return!1}exportDOM(e){return{...super.exportDOM(e),after:e=>{if(e){const t=e.cloneNode(),n=document.createElement(\"colgroup\"),r=document.createElement(\"tbody\");o(e)&&r.append(...e.children);const l=this.getFirstChildOrThrow();if(!ee(l))throw new Error(\"Expected to find row node.\");const s=l.getChildrenSize();for(let e=0;e<s;e++){const e=document.createElement(\"col\");n.append(e)}return t.replaceChildren(n,r),t}}}}canBeEmpty(){return!1}isShadowRoot(){return!0}getCordsFromCellNode(e,t){const{rows:n,domRows:o}=t;for(let t=0;t<n;t++){const n=o[t];if(null==n)continue;const r=n.findIndex((t=>{if(!t)return;const{elem:n}=t;return w(n)===e}));if(-1!==r)return{x:r,y:t}}throw new Error(\"Cell not found in table.\")}getDOMCellFromCords(e,t,n){const{domRows:o}=n,r=o[t];if(null==r)return null;const l=r[e];return null==l?null:l}getDOMCellFromCordsOrThrow(e,t,n){const o=this.getDOMCellFromCords(e,t,n);if(!o)throw new Error(\"Cell not found at cords.\");return o}getCellNodeFromCords(e,t,n){const o=this.getDOMCellFromCords(e,t,n);if(null==o)return null;const r=w(o.elem);return q(r)?r:null}getCellNodeFromCordsOrThrow(e,t,n){const o=this.getCellNodeFromCords(e,t,n);if(!o)throw new Error(\"Node at cords not TableCellNode.\");return o}canSelectBefore(){return!0}canIndent(){return!1}}function Ze(e,t){const n=e.getElementByKey(t.getKey());if(null==n)throw new Error(\"Table Element Not Found\");return Pe(n)}function et(e){return{node:tt()}}function tt(){return l(new Ve)}function nt(e){return e instanceof Ve}export{ye as $computeTableMap,j as $createTableCellNode,tt as $createTableNode,oe as $createTableNodeWithDimensions,Z as $createTableRowNode,Ee as $createTableSelection,pe as $deleteTableColumn,Se as $deleteTableColumn__EXPERIMENTAL,Ce as $deleteTableRow__EXPERIMENTAL,Ze as $getElementForTableNode,Ne as $getNodeTriplet,re as $getTableCellNodeFromLexicalNode,xe as $getTableCellNodeRect,ae as $getTableColumnIndexFromTableCellNode,se as $getTableNodeFromLexicalNodeOrThrow,ie as $getTableRowIndexFromTableCellNode,le as $getTableRowNodeFromTableCellNodeOrThrow,fe as $insertTableColumn,me as $insertTableColumn__EXPERIMENTAL,de as $insertTableRow,ge as $insertTableRow__EXPERIMENTAL,q as $isTableCellNode,nt as $isTableNode,ee as $isTableRowNode,ve as $isTableSelection,he as $removeTableRowAtIndex,be as $unmergeCell,G as INSERT_TABLE_COMMAND,Y as TableCellHeaderStates,J as TableCellNode,Ve as TableNode,Me as TableObserver,Q as TableRowNode,ke as applyTableHandlers,He as getDOMCellFromTarget,Fe as getTableObserverFromTableElement};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalTable.dev.mjs';\nimport * as modProd from './LexicalTable.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $computeTableMap = mod.$computeTableMap;\nexport const $createTableCellNode = mod.$createTableCellNode;\nexport const $createTableNode = mod.$createTableNode;\nexport const $createTableNodeWithDimensions = mod.$createTableNodeWithDimensions;\nexport const $createTableRowNode = mod.$createTableRowNode;\nexport const $createTableSelection = mod.$createTableSelection;\nexport const $deleteTableColumn = mod.$deleteTableColumn;\nexport const $deleteTableColumn__EXPERIMENTAL = mod.$deleteTableColumn__EXPERIMENTAL;\nexport const $deleteTableRow__EXPERIMENTAL = mod.$deleteTableRow__EXPERIMENTAL;\nexport const $getElementForTableNode = mod.$getElementForTableNode;\nexport const $getNodeTriplet = mod.$getNodeTriplet;\nexport const $getTableCellNodeFromLexicalNode = mod.$getTableCellNodeFromLexicalNode;\nexport const $getTableCellNodeRect = mod.$getTableCellNodeRect;\nexport const $getTableColumnIndexFromTableCellNode = mod.$getTableColumnIndexFromTableCellNode;\nexport const $getTableNodeFromLexicalNodeOrThrow = mod.$getTableNodeFromLexicalNodeOrThrow;\nexport const $getTableRowIndexFromTableCellNode = mod.$getTableRowIndexFromTableCellNode;\nexport const $getTableRowNodeFromTableCellNodeOrThrow = mod.$getTableRowNodeFromTableCellNodeOrThrow;\nexport const $insertTableColumn = mod.$insertTableColumn;\nexport const $insertTableColumn__EXPERIMENTAL = mod.$insertTableColumn__EXPERIMENTAL;\nexport const $insertTableRow = mod.$insertTableRow;\nexport const $insertTableRow__EXPERIMENTAL = mod.$insertTableRow__EXPERIMENTAL;\nexport const $isTableCellNode = mod.$isTableCellNode;\nexport const $isTableNode = mod.$isTableNode;\nexport const $isTableRowNode = mod.$isTableRowNode;\nexport const $isTableSelection = mod.$isTableSelection;\nexport const $removeTableRowAtIndex = mod.$removeTableRowAtIndex;\nexport const $unmergeCell = mod.$unmergeCell;\nexport const INSERT_TABLE_COMMAND = mod.INSERT_TABLE_COMMAND;\nexport const TableCellHeaderStates = mod.TableCellHeaderStates;\nexport const TableCellNode = mod.TableCellNode;\nexport const TableNode = mod.TableNode;\nexport const TableObserver = mod.TableObserver;\nexport const TableRowNode = mod.TableRowNode;\nexport const applyTableHandlers = mod.applyTableHandlers;\nexport const getDOMCellFromTarget = mod.getDOMCellFromTarget;\nexport const getTableObserverFromTableElement = mod.getTableObserverFromTableElement;"],"names":["createCommand","type","SELECTION_CHANGE_COMMAND","SELECTION_INSERT_CLIPBOARD_NODES_COMMAND","CLICK_COMMAND","DELETE_CHARACTER_COMMAND","INSERT_LINE_BREAK_COMMAND","INSERT_PARAGRAPH_COMMAND","CONTROLLED_TEXT_INSERTION_COMMAND","PASTE_COMMAND","REMOVE_TEXT_COMMAND","DELETE_WORD_COMMAND","DELETE_LINE_COMMAND","FORMAT_TEXT_COMMAND","UNDO_COMMAND","REDO_COMMAND","KEY_DOWN_COMMAND","KEY_ARROW_RIGHT_COMMAND","MOVE_TO_END","KEY_ARROW_LEFT_COMMAND","MOVE_TO_START","KEY_ARROW_UP_COMMAND","KEY_ARROW_DOWN_COMMAND","KEY_ENTER_COMMAND","KEY_SPACE_COMMAND","KEY_BACKSPACE_COMMAND","KEY_ESCAPE_COMMAND","KEY_DELETE_COMMAND","KEY_TAB_COMMAND","INSERT_TAB_COMMAND","INDENT_CONTENT_COMMAND","OUTDENT_CONTENT_COMMAND","DROP_COMMAND","FORMAT_ELEMENT_COMMAND","DRAGSTART_COMMAND","DRAGOVER_COMMAND","DRAGEND_COMMAND","COPY_COMMAND","CUT_COMMAND","SELECT_ALL_COMMAND","CLEAR_EDITOR_COMMAND","CLEAR_HISTORY_COMMAND","CAN_REDO_COMMAND","CAN_UNDO_COMMAND","FOCUS_COMMAND","BLUR_COMMAND","KEY_MODIFIER_COMMAND","CAN_USE_DOM","window","document","createElement","documentMode","IS_APPLE","test","navigator","platform","IS_FIREFOX","userAgent","CAN_USE_BEFORE_INPUT","InputEvent","IS_SAFARI","IS_IOS","MSStream","IS_ANDROID","IS_CHROME","IS_ANDROID_CHROME","IS_APPLE_WEBKIT","DOM_ELEMENT_TYPE","DOM_TEXT_TYPE","NO_DIRTY_NODES","HAS_DIRTY_NODES","FULL_RECONCILE","IS_NORMAL","IS_TOKEN","IS_SEGMENTED","IS_BOLD","IS_ITALIC","IS_STRIKETHROUGH","IS_UNDERLINE","IS_CODE","IS_SUBSCRIPT","IS_SUPERSCRIPT","IS_HIGHLIGHT","IS_ALL_FORMATTING","IS_DIRECTIONLESS","IS_UNMERGEABLE","IS_ALIGN_LEFT","IS_ALIGN_CENTER","IS_ALIGN_RIGHT","IS_ALIGN_JUSTIFY","IS_ALIGN_START","IS_ALIGN_END","NON_BREAKING_SPACE","ZERO_WIDTH_SPACE","COMPOSITION_SUFFIX","DOUBLE_LINE_BREAK","COMPOSITION_START_CHAR","RTL","LTR","RTL_REGEX","RegExp","LTR_REGEX","TEXT_TYPE_TO_FORMAT","bold","code","highlight","italic","strikethrough","subscript","superscript","underline","DETAIL_TYPE_TO_DETAIL","directionless","unmergeable","ELEMENT_TYPE_TO_FORMAT","center","end","justify","left","right","start","ELEMENT_FORMAT_TO_TYPE","TEXT_MODE_TO_TYPE","normal","segmented","token","TEXT_TYPE_TO_MODE","normalizeClassNames","classNames","rval","className","s","matchAll","push","TEXT_MUTATION_VARIANCE","isProcessingMutations","lastTextEntryTimeStamp","getIsProcessingMutations","updateTimeStamp","event","timeStamp","initTextEntryListener","editor","getWindow","addEventListener","isManagedLineBreak","dom","target","__lexicalLineBreak","_key","undefined","getLastSelection","getEditorState","read","selection","$getSelection","clone","handleTextMutation","node","domSelection","getDOMSelection","_window","anchorOffset","focusOffset","anchorNode","text","nodeValue","$updateTextNodeFromDOMContent","shouldUpdateTextNodeFromMutation","targetDOM","targetNode","$isRangeSelection","anchor","getNode","is","format","getFormat","nodeType","isAttached","$flushMutations$1","mutations","observer","shouldFlushTextMutations","performance","now","updateEditor","badDOMTargets","Map","rootElement","getRootElement","currentEditorState","_editorState","blockCursorElement","_blockCursorElement","shouldRevertSelection","possibleTextForFirefoxPaste","i","length","mutation","$getNearestNodeFromDOMNode","$isDecoratorNode","$isTextNode","addedDOMs","addedNodes","addedDOM","getNodeFromDOMNode","parentDOM","parentNode","nodeName","possibleText","innerText","removeChild","removedDOMs","removedNodes","removedDOMsLength","unremovedBRs","removedDOM","appendChild","internalGetRoot","set","size","$isElementNode","childKeys","getChildrenKeys","currentDOM","firstChild","key","correctDOM","getElementByKey","replaceChild","nextSibling","markDirty","records","takeRecords","record","dirty","$setSelection","isFirefoxClipboardEvents","insertRawText","flushRootMutations","_observer","initMutationObserver","MutationObserver","$canSimpleTextNodesBeMerged","node1","node2","node1Mode","__mode","node1Format","__format","node1Style","__style","node2Mode","node2Format","node2Style","$mergeTextNodes","writableNode1","mergeWithSibling","normalizedNodes","getActiveEditor","_normalizedNodes","add","__key","$normalizeTextNode","textNode","__text","isSimpleText","isUnmergeable","remove","previousNode","getPreviousSibling","nextNode","getNextSibling","$normalizeSelection","$normalizePoint","focus","point","offset","nextOffsetAtEnd","getChildrenSize","getChildAtIndex","getTextContentSize","keyCounter","generateRandomKey","getRegisteredNodeOrThrow","registeredNode","_nodes","get","Error","scheduleMicroTask","queueMicrotask","fn","Promise","resolve","then","$isSelectionCapturedInDecorator","isSelectionCapturedInDecoratorInput","anchorDOM","activeElement","contentEditable","__lexicalEditor","isSelectionWithinEditor","focusDOM","contains","getNearestEditorFromDOMNode","error","currentNode","getParentElement","getTextDirection","$isTokenOrSegmented","isToken","isSegmented","isDOMNodeLexicalTextNode","getDOMTextNode","element","toggleTextFormatType","alignWithFormat","activeFormat","newFormat","$isLeafNode","$isLineBreakNode","$setNodeKey","existingKey","errorOnReadOnly","errorOnInfiniteTransforms","editorState","getActiveEditorState","_nodeMap","_dirtyElements","_dirtyLeaves","_cloneNotNeeded","_dirtyType","internalMarkParentElementsAsDirty","parentKey","nodeMap","dirtyElements","nextParentKey","has","__parent","removeFromParent","oldParent","getParent","writableNode","getWritable","writableParent","prevSibling","writableNextSibling","__first","__prev","writablePrevSibling","__next","__last","__size","internalMarkNodeAsDirty","latest","getLatest","parent","internalMarkSiblingsAsDirty","$setCompositionKey","compositionKey","previousCompositionKey","_compositionKey","$getNodeByKey","$getCompositionKey","isCurrentlyReadOnlyMode","startingDOM","cloneDecorators","currentDecorators","_decorators","pendingDecorators","Object","assign","_pendingDecorators","getEditorStateTextContent","$getRoot","getTextContent","markAllNodesAsDirty","isEmpty","_pendingEditorState","tag","isFrozen","setCachedNodes","_selection","$flushMutations","getNodeFromDOM","nodeKey","getNodeKeyFromDOM","getTextNodeOffset","moveSelectionToEnd","doesContainGrapheme","str","getEditorsToPropagate","editorsToPropagate","currentEditor","_parentEditor","createUID","Math","random","toString","replace","substr","getAnchorTextFromDOM","$updateSelectedTextFromDOM","isCompositionEnd","data","textContent","compositionEnd","isDirty","isComposing","normalizedTextContent","slice","prevTextContent","setTimeout","update","prevSelection","$getPreviousSelection","prevTextContentSize","getKey","canInsertTextBefore","canInsertTextAfter","setTextContent","setTextNodeRange","originalTextContent","replacement","$createTextNode","$previousSiblingDoesNotAcceptText","previousSibling","isInline","$shouldInsertTextAfterOrBeforeTextNode","isCollapsed","getParentOrThrow","isTab","keyCode","altKey","ctrlKey","metaKey","isBold","controlOrMeta","isItalic","isUnderline","isParagraph","shiftKey","isReturn","isLineBreak","isOpenLineBreak","isDeleteWordBackward","isBackspace","isDeleteWordForward","isDelete","isDeleteLineBackward","isDeleteLineForward","isDeleteBackward","isDeleteForward","isUndo","isRedo","isCopy","isCut","isArrowLeft","isArrowRight","isArrowUp","isArrowDown","isMoveBackward","isMoveToStart","isMoveForward","isMoveToEnd","isMoveUp","isMoveDown","isModifier","isSpace","isEscape","isSelectAll","$selectAll","root","select","getCachedClassNameArray","classNamesTheme","classNameThemeType","__lexicalClassNameCache","classNamesCache","cachedClassNames","classNamesArr","setMutatedNode","mutatedNodes","registeredNodes","mutationListeners","__type","klass","mutatedNodesByType","prevMutation","isMove","$nodesOfType","readOnly","_readOnly","klassType","getType","nodes","nodesOfType","resolveElement","isBackward","block","getIndexWithinParent","$getAdjacentNode","focusNode","possibleNode","inputType","dispatchCommand","command","payload","triggerCommandListeners","$textContentRequiresDoubleLinebreakAtEnd","$isRootNode","isLastChild","getElementByKeyOrThrow","_keyToDOMMap","parentElement","assignedSlot","host","scrollIntoViewIfNeeded","selectionRect","doc","ownerDocument","defaultView","top","currentTop","bottom","currentBottom","targetTop","targetBottom","isBodyElement","body","innerHeight","targetRect","getBoundingClientRect","diff","scrollBy","scrollTop","yOffset","$hasUpdateTag","_updateTags","$addUpdateTag","$maybeMoveChildrenSelectionToParent","$hasAncestor","child","getDefaultView","domElem","ownerDoc","windowObj","$isInlineElementOrDecoratorNode","$getNearestRootOrShadowRoot","$isRootOrShadowRoot","isShadowRoot","$copyNode","copy","constructor","$applyNodeReplacement","replaceFunc","replacementNode","errorOnInsertTextNodeOnRoot","insertNode","createBlockCursorElement","editorConfig","theme","setAttribute","blockCursorTheme","blockCursor","classList","needsBlockCursor","canBeEmpty","removeDOMBlockCursorElement","style","removeProperty","updateDOMBlockCursorElement","nextSelection","elementNode","elementNodeSize","isBlockCursor","insertBeforeElement","sibling","elementDOM","_config","caretColor","insertBefore","targetWindow","getSelection","$splitNode","startNode","recurse","isParentRoot","nodeToMove","insertAfter","leftTree","rightTree","newParent","nextSiblings","getNextSiblings","append","isHTMLAnchorElement","x","isHTMLElement","tagName","INTERNAL_$isBlock","getFirstChild","isLeafElement","$getAncestor","predicate","$getEditor","$garbageCollectDetachedDecorators","pendingEditorState","decorators","$garbageCollectDetachedDeepChildNodes","prevNodeMap","nodeMapDelete","dirtyNodes","childKey","delete","$garbageCollectDetachedNodes","prevEditorState","dirtyLeaves","subTreeTextContent","subTreeDirectionedTextContent","subTreeTextFormat","editorTextContent","activeEditorConfig","activeEditor$1","activeEditorNodes","treatAllNodesAsDirty","activeEditorStateReadOnly","activeMutationListeners","activeTextDirection","activeDirtyElements","activeDirtyLeaves","activePrevNodeMap","activeNextNodeMap","activePrevKeyToDOMMap","destroyNode","getPrevElementByKeyOrThrow","children","createChildrenArray","destroyChildren","_startIndex","endIndex","startIndex","setTextAlign","domStyle","value","setProperty","DEFAULT_INDENT_VALUE","setElementIndent","indent","indentClassName","elementHasClassName","indentationBaseValue","getComputedStyle","getPropertyValue","setElementFormat","createNode","insertDOM","createDOM","storeDOMWithKey","__indent","childrenSize","createChildrenWithDirection","reconcileElementTerminatingLineBreak","decorator","decorate","reconcileDecorator","isDirectionless","possibleLineBreak","freeze","previousSubTreeDirectionedTextContent","createChildren","reconcileBlockDirection","previousSubTreeTextContent","__lexicalTextContent","isLastChildLineBreakOrDecorator","prevElement","nextElement","prevLineBreak","nextLineBreak","reconcileParagraphFormat","$isParagraphNode","__textFormat","setTextFormat","previousSubTreeDirectionTextContent","__lexicalDirTextContent","previousDirection","__lexicalDir","hasEmptyDirectionedTextContent","direction","previousDirectionTheme","nextDirectionTheme","removeAttribute","dir","__dir","reconcileChildrenWithDirection","reconcileChildren","prevChildrenSize","nextChildrenSize","prevFirstChildKey","nextFrstChildKey","reconcileNode","lastDOM","replacementDOM","nextChildNode","prevChildren","nextChildren","lexicalLineBreak","canUseFastPath","reconcileNodeChildren","prevNode","updateDOM","nextIndent","nextFormat","__cachedText","nextRootNode","prevChildrenLength","nextChildrenLength","prevEndIndex","nextEndIndex","prevChildrenSet","nextChildrenSet","siblingDOM","prevIndex","nextIndex","prevKey","nextKey","Set","nextHasPrevKey","prevHasNextKey","childDOM","appendNewChildren","removeOldChildren","reconcileRoot","nextEditorState","dirtyType","_listeners","currentMutatedNodes","keyToDOMMap","PASS_THROUGH_COMMAND","ANDROID_COMPOSITION_LATENCY","rootElementEvents","onKeyDown","onPointerDown","onCompositionStart","onCompositionEnd","onInput","onClick","onBeforeInput","lastKeyDownTimeStamp","lastKeyCode","lastBeforeInputInsertTextTimeStamp","unprocessedBeforeInputData","rootElementsRegistered","WeakMap","isSelectionChangeFromDOMUpdate","isSelectionChangeFromMouseDown","isInsertLineBreak","isFirefoxEndingComposition","collapsedSelectionFormat","$shouldPreventDefaultAndInsertText","domTargetRange","isBeforeInput","domAnchorNode","anchorKey","backingAnchorElement","textLength","collapsed","startContainer","startOffset","getStyle","shouldSkipSelectionChange","domNode","onSelectionChange","isActive","windowEvent","currentTimeStamp","lastFormat","lastStyle","lastOffset","lastKey","isRootTextContentEmpty","lastNode","ParagraphNode","getTextFormat","focusKey","getNodes","nodesLength","endOffset","startKey","endKey","combinedFormat","hasTextNodes","textContentSize","lastSelection","getTopLevelElementOrThrow","removeAllRanges","detail","pointerType","newSelection","internalCreateRangeSelection","Node","getTargetRange","getTargetRanges","targetRanges","$canRemoveText","isPossiblyAndroidKeyPress","targetRange","isSelectionAnchorSameAsFocus","preventDefault","selectedNodeText","hasSelectedAllTextInNode","shouldLetBrowserHandleDelete","applyDOMRange","dataTransfer","getData","stopPropagation","onCompositionEndImpl","characterData","$isNodeSelection","getRootElementRemoveHandles","eventHandles","__lexicalEventHandles","activeNestedEditorsMap","onDocumentSelectionChange","nextActiveEditor","editors","rootEditor","rootEditorKey","activeNestedEditor","prevActiveEditor","stopLexicalPropagation","_lexicalHandled","hasStoppedLexicalPropagation","stopped","addRootElementEvents","documentRootElementsCount","removeHandles","eventName","onEvent","eventHandler","isEditable","removeEventListener","removeRootElementEvents","cleanActiveNestedEditorsMap","markSelectionChangeFromDOMUpdate","markCollapsedSelectionFormat","removeNode","nodeToRemove","restoreSelection","preserveEmptyParent","selectionMoved","moveSelectionPointToSibling","isSelected","selectPrevious","index","$updateElementSelectionOnCreateDeleteNode","selectEnd","LexicalNode","name","_data","errorOnTypeKlassMismatch","targetSelection","some","n","getTopLevelElement","getParents","parents","getParentKeys","self","getPreviousSiblings","siblings","getCommonAncestor","a","b","unshift","aLength","bLength","bSet","ancestor","object","isBefore","isParentOf","commonAncestor","indexA","indexB","getNodesBetween","visited","getLastChild","parentSibling","reverse","latestNode","cloneNotNeeded","mutableNode","__detail","_editor","_prevNode","_dom","exportDOM","exportJSON","importJSON","_serializedNode","transform","replaceWith","includeChildren","toReplaceKey","writableReplaceWith","getChildren","forEach","$moveSelectionPointToEnd","nodeToInsert","writableSelf","writableNodeToInsert","elementAnchorSelectionOnNode","elementFocusSelectionOnNode","oldIndex","oldParentKey","insertKey","writableParentKey","isParentRequired","createParentElementNode","$createParagraphNode","selectStart","selectNext","editorKlass","insertRangeAfter","firstToInsert","lastToInsert","lastToInsert2","current","nodesToInsert","LineBreakNode","importDOM","br","isOnlyChild","conversion","convertLineBreakElement","priority","serializedLineBreakNode","$createLineBreakNode","version","isWhitespaceDomTextNode","lastChild","getElementOuterTag","getElementInnerTag","setTextThemeClassNames","prevFormat","textClassNames","domClassList","hasUnderlineStrikethrough","prevUnderlineStrikethrough","nextUnderlineStrikethrough","flag","diffComposedText","nextText","suffix","insert","deleteData","insertData","createTextInnerDOM","innerDOM","innerTag","config","wrapElementWith","el","TextNode","getDetail","getMode","hasFormat","formatFlag","getFormatFlags","canHaveFormat","outerTag","cssText","prevOuterTag","nextOuterTag","prevInnerTag","nextInnerTag","prevTag","nextTag","prevInnerDOM","nextInnerDOM","prevStyle","nextStyle","convertTextDOMNode","convertBringAttentionToElement","convertTextFormatElement","em","span","convertSpanElement","strong","sub","sup","u","serializedNode","setFormat","setDetail","setMode","mode","setStyle","whiteSpace","selectionTransform","toggleFormat","toggleDirectionless","toggleUnmergeable","_anchorOffset","_focusOffset","internalMakeRangeSelection","spliceText","delCount","newText","moveSelection","handledTextLength","newOffset","updatedText","splitText","splitOffsets","offsetsSet","parts","string","partsLength","firstPart","hasReplacedSelf","splitNodes","textSize","part","partSize","siblingKey","nextTextSize","insertionIndex","splice","targetKey","adjustPointOffsetForMergedSibling","targetText","isTextEntity","fontWeight","hasBoldFontWeight","hasLinethroughTextDecoration","textDecoration","hasItalicFontStyle","fontStyle","hasUnderlineTextDecoration","verticalAlign","forChild","lexicalNode","hasNormalFontWeight","preParentCache","isNodePre","startsWith","findParentPreDOMNode","cached","resultNode","domNode_","parentDom","split","$createTabNode","previousText","isStartOfLine","findTextInLine","previousTextContent","isEndOfLine","nextTextContent","inlineParents","forward","display","match","descendant","nodeNameToTextFormat","toLowerCase","TabNode","newNode","serializedTabNode","_text","_detail","_type","$isTabNode","Point","aNode","bNode","aOffset","bOffset","aNodeDescendant","getDescendantByIndex","bNodeDescendant","oldKey","$createPoint","selectPointOnNode","textContentLength","getLastDescendant","$transferStartingElementPointToTextPoint","placementNode","$setPointValues","NodeSelection","objects","_cachedNodes","getCachedNodes","Array","from","every","getStartEndPoints","clear","extract","insertText","insertNodes","selectedNodes","selectedNodesLength","lastSelectedNode","selectionAtEnd","cachedNodes","RangeSelection","firstPoint","lastPoint","firstNode","firstNodeDescendant","lastNodeDescendant","$getCharacterOffsets","prevWasElement","range","resolvedSelectionPoints","internalResolveSelectionPoints","endContainer","anchorPoint","focusPoint","endPoint","firstNodeText","firstNodeTextLength","firstNodeParent","lastIndex","lastNodeParent","normalizeSelectionPointsForBoundaries","firstNodeFormat","firstNodeStyle","markedNodeKeysForKeep","firstElement","lastElement","lastElementChild","lastNodeChildren","selectedNodesSet","firstAndLastElementsAreEqual","insertionTarget","lastNodeChild","lastRemovedParent","childrenLength","selectedNode","removeText","formatText","formatType","selectedTextNodes","selectedTextNodesLength","startPoint","firstIndex","firstNextFormat","lastNextFormat","insertParagraph","firstBlock","last","removeTextAndSplitBlock","notInline","blocksParent","$wrapInlineNodes","nodeToSelect","blocks","isLI","isMergeable","shouldInsert","insertedParagraph","lastInsertedBlock","paragraph","firstToAppend","newBlock","insertNewAfter","insertLineBreak","lineBreak","shift","lastNodeText","lastNodeTextLength","pop","modify","alter","granularity","collapse","isIsolated","isKeyboardSelectable","nodeSelection","$createNodeSelection","elementKey","_rootElement","moveNativeSelection","rangeCount","getRangeAt","validNodes","shrinkSelection","firstValidNode","lastValidNode","$swapPoints","forwardDeletion","deleteCharacter","wasCollapsed","$removeSegment","$updateCaretSelectionForUnicodeCharacter","collapseAtStart","deleteLine","deleteWord","getCharacterOffset","anchorAndFocus","anchorType","characterOffset","splitLength","segmentOffset","restoreOffset","isLast","join","trim","shouldResolveAncestor","resolvedElement","resolvedOffset","internalResolveSelectionPoint","resolvedNode","childNodes","childNodesLength","hasBlockCursor","min","getFirstDescendant","resolveSelectionPointOnBoundary","lastAnchor","lastFocus","resolvedAnchorPoint","resolvedFocusPoint","$isBlockElementNode","focusType","$createRangeSelection","internalCreateSelection","$createRangeSelectionFromDom","eventType","isSelectionChange","useDOMSelection","nodeOffset","times","selectionOffset","newSelectionOffset","max","$updateSelectionResolveTextNodes","firstPointNode","lastPointNode","firstPointOffset","lastPointOffset","childSize","anchorOffsetAtEnd","focusOffsetAtEnd","applySelectionTransforms","updateDOMSelection","tags","nodeCount","anchorDOMNode","focusDOMNode","nextAnchorOffset","nextFocusOffset","nextAnchorNode","nextFocusNode","anchorFormatOrStyleChanged","preventScroll","setBaseAndExtent","selectionTarget","Text","createRange","selectNode","$insertNodes","$getTextContent","splitNodeAtPoint","insertPoint","newElement","virtualRoot","currentBlock","isLineBreakNode","activeEditorState","activeEditor","isReadOnlyMode","isAttemptingToRecoverFromReconcilerError","infiniteTransformCount","observerOptions","childList","subtree","internalGetActiveEditor","$applyTransforms","transformsCache","transformsArr","transforms","transformsArrLength","$isNodeValidForTransform","$normalizeAllDirtyTextNodes","$applyAllTransforms","untransformedDirtyLeaves","untransformedDirtyLeavesLength","untransformedDirtyElements","untransformedDirtyElementsLength","currentUntransformedDirtyElement","intentionallyMarkedAsDirty","$parseSerializedNode","internalSerializedNode","$parseSerializedNodeImpl","nodeClass","isArray","serializedJSONChildNode","childNode","parseEditorState","serializedEditorState","updateFn","createEmptyEditorState","previousActiveEditorState","previousReadOnlyMode","previousActiveEditor","previousDirtyElements","previousDirtyLeaves","previousCloneNotNeeded","previousDirtyType","handleDEVOnlyPendingUpdateGuarantees","_onError","readEditorState","callbackFn","commitPendingUpdates","recoveryEditorState","shouldSkipDOM","_headless","currentSelection","pendingSelection","needsUpdate","previouslyUpdating","_updating","disconnect","resetEditor","observe","deferred","_deferred","_editable","triggerMutationListeners","triggerListeners","triggerTextContentListeners","triggerDeferredUpdateCallbacks","triggerEnqueuedUpdates","currentTextContent","latestTextContent","updateTags","listeners","listenersLength","listener","isCurrentlyEnqueuingUpdates","apply","returnVal","e","commandListeners","_commands","listenerInPriorityOrder","listenersSet","j","queuedUpdates","_updates","queuedUpdate","options","beginUpdate","processNestedUpdates","initialSkipTransforms","skipTransforms","nextUpdateFn","onUpdate","discrete","editorStateWasCloned","cloneEditorState","_flushSync","startingCompositionKey","endingCompositionKey","pendingNodeMap","shouldUpdate","editorStateHasDirtySelection","DecoratorNode","ElementNode","getFormatType","getIndent","parentLastChild","getAllTextNodes","textNodes","subChildrenNodes","firstKey","getFirstChildOrThrow","getLastChildOrThrow","getDirection","childrenCount","nodesToAppend","setDirection","setIndent","indentLevel","deleteCount","nodesToInsertLength","oldSize","writableSelfKey","nodesToInsertKeys","nodesToRemoveKeys","nodeAfterRange","nodeBeforeRange","newSize","nodeToDelete","nodeKeyToDelete","writableNodeToDelete","nodeKeyToInsert","writablePrevNode","writableNodeAfterRange","nodesToRemoveKeySet","nodesToInsertKeySet","isPointRemoved","canIndent","excludeFromCopy","destination","canReplaceWith","canInsertAfter","canMergeWith","extractWithChild","RootNode","cachedText","$createRootNode","EditorState","exportNodeToJSON","serializedChildren","serializedChildNode","toJSON","hasTextFormat","p","convertParagraphElement","textAlign","textIndent","textFormat","rangeSelection","parseInt","COMMAND_PRIORITY_EDITOR","COMMAND_PRIORITY_LOW","COMMAND_PRIORITY_NORMAL","COMMAND_PRIORITY_HIGH","COMMAND_PRIORITY_CRITICAL","prevRootElement","nextRootElement","keyNodeMap","initializeConversionCache","additionalConversions","conversionCache","handledConversions","addConversionsToCache","map","keys","currentCache","call","createEditor","parentEditor","disableEvents","namespace","initialEditorState","onError","html","editable","replaceWithKlass","with","withKlass","proto","prototype","method","hasOwnProperty","console","warn","export","LexicalEditor","import","htmlConversions","textcontent","_htmlConversions","registerUpdateListener","listenerSetOrMap","registerEditableListener","registerDecoratorListener","registerTextContentListener","registerRootListener","registerCommand","commandsMap","listenersInPriorityOrder","String","registerMutationListener","registerNodeTransformToKlass","registerNodeTransform","registeredReplaceWithNode","hasNode","hasNodes","bind","getDecorators","setRootElement","userSelect","wordBreak","setEditorState","maybeStringifiedEditorState","JSON","parse","defaultSelection","blur","setEditable","q","Q","X","Y","Z","G","tt","et","nt","rt","Qn","mod","modDev","$normalizeSelection__EXPERIMENTAL","CSS_TO_STYLES","TEXT_NODE","getDOMIndexWithinParent","indexOf","createDOMRange","setStart","setEnd","createRectsFromDOMRange","rootRect","computedStyle","rootPadding","parseFloat","paddingLeft","paddingRight","selectionRects","getClientRects","selectionRectsLength","sort","abs","prevRect","isOverlappingRect","height","width","selectionSpansElement","getStyleObjectFromRawCSS","css","styleObject","styles","getStyleObjectFromCSS","getCSSFromStyleObject","$updateElementNodeProperties","source","$updateTextNodeProperties","$updateParagraphNodeProperties","$cloneWithProperties","$sliceSelectedTextNodeContent","isAnchor","isFocus","isSame","isFirst","$isAtNodeEnd","trimTextContentFromAnchor","remaining","descendantNode","lastDescendant","additionalElementWhitespace","currentNodeSize","slicedText","prevOffset","splitStart","splitEnd","excessNode","$addNodeStyle","CSSText","$patchStyle","patch","prevStyles","newStyles","entries","reduce","Function","newCSSText","$patchStyleText","startType","endType","selectedNodeKey","$setBlocksType","firstSelectedBlock","targetElement","isPointAttached","$removeParentEmptyElements","startingNode","$wrapNodes","wrappingElement","topLevelNode","descendants","$wrapNodesImpl","elementMapping","elements","targetIsPrevSibling","emptyElements","movedNodes","$shouldOverrideDefaultCharacterSelection","$moveCaretSelection","isHoldingShift","$isParentElementRTL","$moveCharacter","isRTL","topParent","firstType","lastType","$getNodeStyleValueForProperty","styleProperty","defaultValue","$getSelectionStyleValueForProperty","styleValue","endNode","nodeStyleValue","mergeRegister","func","f","px","mutationObserverConfig","attributes","positionNodeOnRange","onReposition","rootDOMNode","parentDOMNode","lastNodes","wrapperNode","position","rootLeft","rootTop","parentDOMNode_","rects","isConnected","hasRepositioned","rect","rectNode","rectNodeStyle","stop","restart","currentRootDOMNode","currentParentDOMNode","HTMLElement","nextRootDOMNode","nextParentDOMNode","removeRootListener","markSelection","previousAnchorNode","previousAnchorOffset","previousFocusNode","previousFocusOffset","removeRangeListener","compute","currentAnchorNode","currentAnchorNodeKey","currentAnchorOffset","currentFocusNode","currentFocusNodeKey","currentFocusOffset","currentAnchorNodeDOM","currentFocusNodeDOM","differentAnchorDOM","differentFocusDOM","anchorHTMLElement","focusHTMLElement","firstHTMLElement","firstOffset","lastHTMLElement","firstTextNode","lastTextNode","domNodes","domNodeStyle","background","color","zIndex","pointerEvents","marginTop","paddingTop","paddingBottom","addClassNamesToElement","classesToAdd","removeClassNamesFromElement","classesToRemove","isMimeType","file","acceptableMimeTypes","acceptableType","mediaFileReader","files","filesIterator","Symbol","iterator","reject","processed","handleNextFile","done","next","fileReader","FileReader","result","readAsDataURL","$dfs","endingNode","depth","$getDepth","innerNode","$getNearestNodeOfType","$getNearestBlockElementAncestorOrThrow","blockNode","$findMatchingParent","findFn","curr","registerNestedElementResolver","cloneNode","handleOverlap","$isTargetNode","$findMatch","elementNodeTransform","nextSiblingsLength","$restoreEditorState","$insertNodeToNearestRoot","focusChild","splitNode","splitOffset","paragraphNode","$wrapNodeInElement","createElementNode","objectKlassEquals","objectClass","getPrototypeOf","$filter","filterFn","$insertFirst","calculateZoomLevel","zoom","Number","h","m","E","v","w","y","N","P","S","$generateNodesFromDOM","lexicalNodes","IGNORE_TAGS","$createNodesFromDOM","concat","$generateHtmlFromNodes","global","container","topLevelChildren","$appendNodesToHTML","innerHTML","shouldInclude","shouldExclude","exportOutput","after","fragment","createDocumentFragment","shouldIncludeChild","getConversionFunction","cachedConversions","currentConversion","cachedConversion","domConversion","forChildMap","parentLexicalNode","currentLexicalNode","transformFunction","transformOutput","postTransform","transformNodes","forChildFunction","childLexicalNodes","$getListDepth","listNode","$isListItemNode","parentList","$isListNode","$getTopListNode","listItem","list","$getAllListItems","listItemNodes","listChildren","filter","listItemNode","isNestedListNode","$removeHighestEmptyListParent","sublist","emptyListPtr","wrapInListItem","listItemWrapper","$createListItemNode","$isSelectingEmptyListItem","insertList","listType","anchorNodeParent","$createListNode","handled","createListOrMerge","newListNode","nextParent","getListType","mergeLists","list1","list2","listItem1","listItem2","toMerge","removeList","listNodes","ListItemNode","insertionPoint","listItems","updateChildrenListItemValue","isNotChecklist","getStart","getValue","setValue","getChecked","setChecked","mergeNextSiblingListIfSameType","$handleIndent","removed","innerList","nextInnerList","newListItem","newList","$handleOutdent","grandparentListItem","greatGrandparentList","previousSiblingsListItem","previousSiblingsList","nextSiblingsListItem","nextSiblingsList","$handleListInsertParagraph","topListNode","grandparent","__value","__checked","checked","updateListItemChecked","$setListItemThemeClassNames","li","convertListItemElement","replaceWithNode","nodeToAppend","_","listNodeParent","isIndented","toggleChecked","currentIndent","editorThemeClasses","listTheme","listItemClassName","listitem","nestedListItemClassName","nested","isCheckList","listitemUnchecked","listitemChecked","nestedListItemClasses","prevListItemNode","getAttribute","ListNode","__listType","TAG_TO_LIST_TYPE","__tag","__start","_listType","getTag","setListType","writable","__lexicalListType","setListThemeClassNames","ol","convertListNode","ul","listLevelsClassNames","listDepth","normalizedListDepth","listLevelClassName","listClassName","nestedListClassName","nestedListTheme","checklistClassName","checklist","normalizeChildren","normalizedListItems","INSERT_UNORDERED_LIST_COMMAND","INSERT_ORDERED_LIST_COMMAND","INSERT_CHECK_LIST_COMMAND","REMOVE_LIST_COMMAND","U","$","H","SUPPORTED_URL_PROTOCOLS","LinkNode","__url","rel","__rel","__target","title","__title","url","href","sanitizeUrl","link","convertAnchorElement","$createLinkNode","parsedUrl","URL","protocol","_unused","getRel","getTarget","getTitle","getURL","setURL","setTarget","setRel","setTitle","linkNode","content","$isLinkNode","AutoLinkNode","$createAutoLinkNode","$isAutoLinkNode","TOGGLE_LINK_COMMAND","toggleLink","prevParent","d","r","$getHtmlContent","$getLexicalContent","stringify","$generateJSONFromSelectedNodes","$insertDataTransferForPlainText","$insertDataTransferForRichText","lexicalString","$generateNodesFromSerializedNodes","$insertGeneratedNodes","htmlString","parser","DOMParser","parseFromString","_unused2","$appendNodesToJSON","targetArray","serializedNodes","EVENT_LATENCY","clipboardEventTimeout","copyToClipboard","$copyToClipboardEvent","windowDocument","createTextNode","Range","addRange","removeListener","secondEvent","ClipboardEvent","clearTimeout","execCommand","clipboardData","plainString","setData","HISTORY_MERGE","HISTORY_PUSH","DISCARD_HISTORY_CANDIDATE","OTHER","COMPOSING_CHARACTER","INSERT_CHARACTER_AFTER_SELECTION","DELETE_CHARACTER_BEFORE_SELECTION","DELETE_CHARACTER_AFTER_SELECTION","getDirtyNodes","dirtyLeafKey","dirtyLeaf","dirtyElementKey","dirtyElement","getChangeType","dirtyLeavesSet","dirtyElementsSet","nextNodeMap","prevAnchorNode","nextDirtyNode","prevDirtyNode","prevText","nextAnchor","prevAnchor","prevAnchorOffset","textDiff","isTextNodeUnchanged","isDeletingLine","createMergeActionGetter","delay","prevChangeTime","Date","prevChangeType","currentHistoryEntry","changeTime","changeType","mergeAction","isSameEditor","shouldPushHistory","shouldMergeHistory","hasDirtyNodes","redo","historyState","redoStack","undoStack","historyStateEntry","undo","undoStackLength","clearHistory","registerHistory","getMergeAction","applyChange","unregisterCommandListener","unregisterUpdateListener","createEmptyHistoryState","$rootTextContent","$isRootTextContentEmpty","isEditorComposing","$isRootTextContentEmptyCurry","$canShowPlaceholder","topBlock","topBlockChildren","topBlockChildrenLength","$canShowPlaceholderCurry","$findTextIntersectionFromCharacters","targetCharacters","currentCharacters","mainLoop","characters","registerLexicalTextEntity","getMatch","isTargetNode","replaceWithSimpleText","textNodeTransform","combinedText","prevMatch","concatText","newTextContent","remainingText","nextMatch","nodeToReplace","reverseNodeTransform","removePlainTextTransform","removeReverseNodeTransform","caretFromPoint","caretRangeFromPoint","caretPositionFromPoint","offsetNode","DRAG_DROP_PASTE","QuoteNode","quote","blockquote","convertBlockquoteElement","$createQuoteNode","$isQuoteNode","HeadingNode","heading","h1","convertHeadingElement","h2","h3","h4","h5","h6","isGoogleDocsTitle","$createHeadingNode","anchorOffet","fontSize","headingTag","$isHeadingNode","onPasteForRichText","KeyboardEvent","onCutForRichText","eventFiles","DragEvent","types","hasFiles","includes","hasContent","handleIndentAndOutdent","indentOrOutdent","alreadyHandled","parentBlock","$isTargetWithinDecorator","$isSelectionAtEndOfRoot","registerRichText","eventOrText","clientX","clientY","eventRange","domOffset","normalizedSelection","isFileTransfer","hasTextContent","at","ct","ut","lt","dt","mt","ft","gt","l","PIXEL_VALUE_REG_EXP","TableCellHeaderStates","BOTH","COLUMN","NO_STATUS","ROW","TableCellNode","cellNode","__headerState","__colSpan","__width","__rowSpan","__backgroundColor","td","convertTableCellNodeElement","th","colSpan","rowSpan","$createTableCellNode","headerState","backgroundColor","tableCell","hasHeader","tableCellHeader","element_","maxWidth","colCount","border","getWidth","getBackgroundColor","getColSpan","setColSpan","getRowSpan","setRowSpan","setHeaderStyles","getHeaderStyles","setWidth","setBackgroundColor","newBackgroundColor","toggleHeaderStyle","headerStateToToggle","hasHeaderState","tableCellNode","$isTableCellNode","INSERT_TABLE_COMMAND","TableRowNode","__height","tr","convertTableRowElement","$createTableRowNode","getHeight","tableRow","setHeight","$isTableRowNode","$createTableNodeWithDimensions","rowCount","columnCount","includeHeaders","tableNode","$createTableNode","iRow","tableRowNode","iColumn","rows","columns","$getTableCellNodeFromLexicalNode","$getTableRowNodeFromTableCellNodeOrThrow","$getTableNodeFromLexicalNodeOrThrow","$isTableNode","$getTableRowIndexFromTableCellNode","findIndex","$getTableColumnIndexFromTableCellNode","$getTableCellSiblingsFromTableCellNode","table","getCordsFromCellNode","above","getCellNodeFromCords","below","$removeTableRowAtIndex","indexToDelete","tableRows","targetRowNode","$insertTableRow","targetIndex","shouldInsertAfter","tableRowCells","tableColumnCount","newTableRowNode","c","tableCellFromTargetRow","getHeaderState","currentState","possibleState","$insertTableRow__EXPERIMENTAL","$isTableSelection","focusCell","grid","$getNodeTriplet","gridMap","focusCellMap","$computeTableMap","startRow","focusStartRow","focusEndRow","focusEndRowMap","newRow","cell","currentCell","currentCellHeaderState","focusEndRowNode","focusStartRowMap","focusStartRowNode","$insertTableColumn","tableCellsToBeInserted","currentTableRowNode","tableRowChildren","targetCell","newTableCell","$insertTableColumn__EXPERIMENTAL","anchorCell","anchorCellMap","startColumn","insertAfterColumn","gridFirstChild","firstInsertedCell","$createTableCellNodeForInsertTableColumn","loopRow","rowLoop","currentRow","rowMap","currentStartColumn","currentStartRow","insertAfterCell","insertAfterCellRowStart","prevCellIndex","cell_","startRow_","$moveSelectionToCell","$deleteTableColumn","$deleteTableRow__EXPERIMENTAL","anchorStartRow","nextRow","nextRowNode","row","column","cellStartRow","cellStartColumn","previousCell","rowNode","previousRow","$deleteTableColumn__EXPERIMENTAL","anchorStartColumn","focusStartColumn","endColumn","selectedColumnCount","overflowLeft","inSelectedArea","focusRowMap","nextColumn","firstDescendant","$unmergeCell","cellMap","currentRowNode","currentRowMap","currentCellMap","cellA","cellB","tableMap","cellAValue","cellBValue","write","gridChildren","rowChildren","$getTableCellNodeRect","gridNode","cellMatrix","rowIndex","cells","columnIndex","cellIndex","TableSelection","tableKey","anchorCellKey","focusCellKey","getShape","anchorCellNode","anchorCellNodeRect","focusCellNode","focusCellNodeRect","startX","stopX","startY","stopY","fromX","fromY","toX","toY","anchorRow","focusCellGrid","gridParent","focusCellParent","cellAMap","cellBMap","minColumn","minRow","maxColumn","maxRow","exploredMinColumn","exploredMinRow","exploredMaxColumn","exploredMaxRow","expandBoundary","mapValue","rowDiff","previousColumn","columnDiff","lastRow","$getChildrenRecursively","$createTableSelection","stack","TableObserver","tableNodeKey","isHighlightingCells","anchorX","anchorY","focusX","focusY","listenersToRemove","domRows","tableSelection","anchorCellNodeKey","focusCellNodeKey","hasHijackedSelectionStyles","trackTable","isSelecting","getTable","removeListeners","gridNeedsRedraw","tableElement","clearHighlight","enableHighlightStyle","$updateDOMForSelection","disableHighlightStyle","updateTableTableSelection","setFocusCellForSelection","ignoreStart","cellX","cellY","elem","focusTableCellNode","$findTableNode","focusNodeKey","setAnchorCellForSelection","anchorTableCellNode","anchorNodeKey","formatCells","formatSelection","clearText","rootNode","LEXICAL_ELEMENT_KEY","applyTableHandlers","hasTabHandler","tableObserver","editorWindow","attachTableObserverToTableElement","createMouseHandlers","onMouseUp","onMouseMove","moveEvent","getDOMCellFromTarget","button","stopEvent","mouseDownCallback","$handleArrowKey","deleteTextHandler","$isSelectionInTable","isAnchorInside","isFocusInside","selectionContainsPartialTable","nearestElementNode","topLevelCellElementNode","deleteCellHandler","cellChildren","k","edgePosition","$getTableEdgeCursorPosition","$insertParagraphAtTableEdge","$findCellNode","currentCords","selectTableNodeInDirection","getObserverCellFromCellNode","getDOMCellFromCordsOrThrow","selectionPayload","isTableSelection","isRangeSelection","isSelectionInsideOfGrid","newGrid","newGridRows","newColumnCount","newRowCount","gridCellNode","gridRowNode","gridRowNodes","newRowIdx","newAnchorCellKey","newFocusCellKey","currentGridRowNode","newGridRowNode","gridCellNodes","newGridCellNodes","newColumnIdx","currentGridCellNode","newGridCellNode","originalChildren","newTableSelection","isPartialyWithinTable","isWithinTable","$addHighlightStyleToTable","isFocusOutside","$removeHighlightStyleToTable","getTableObserverFromTableElement","_cell","nodeMame","hasBackgroundColor","highlighted","selectedCellNodes","$forEachTableCell","$addHighlightToDOM","$removeHighlightFromDOM","cb","isForward","selectTableCellNode","getCellNodeFromCordsOrThrow","adjustFocusNodeInDirection","fromStart","BROWSER_BLUE_RGB","siblingNode","anchorCellTable","anchorCellTableElement","isExitingTableAnchor","$handleTableExit","anchorCellDom","edgeSelectionRect","edgeChild","edgeChildDOM","edgeRect","isExiting","cords","tableNodeFromSelection","cordsAnchor","stopImmediatePropagation","isExitingTableElementAnchor","isExitingTableTextAnchor","hasValidOffset","cellValue","isExitingCell","toNode","getExitingToNode","firstCell","lastCell","anchorSibling","parentTable","isAtFirstCell","isAtLastCell","TableNode","_node","convertTableElement","colGroup","tBody","firstRow","col","replaceChildren","getDOMCellFromCords","canSelectBefore","$getElementForTableNode","_domNode","ne"],"mappings":"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"}